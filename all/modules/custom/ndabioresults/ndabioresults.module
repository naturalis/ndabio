<?php
// Drupal
require_once 'ndabioresults.config.inc';
require_once 'ndabioresults.block.inc';

// Libraries
require_once 'common.inc';
require_once 'ndabioresults.parse.inc';
require_once 'ndabioresults.print.inc';
require_once 'Paginator.php';

// Namespaces not defined in common.inc
use nl\naturalis\bioportal\QuerySpec as QuerySpec;
use nl\naturalis\bioportal\ScientificNameGroupQuerySpec as ScientificNameGroupQuerySpec;
use nl\naturalis\bioportal\Condition as Condition;

// Clear previously stored debug info
_initDebug();
// Set language (copied from v1, dunno if necessary)
_setLanguage();



/**
 * Implements hook_menu().
 */
function ndabioresults_menu() {
  global $language;

  $items['admin/config/naturalis/ndaresult'] = array(
    'title' => 'NDA result config',
    'description' => 'Configuration for Naturalis module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ndabioresults_config_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['result/%'] = array(
    'page callback' => 'ndabioresults_pass',
    'load arguments' => array('%map', '%index'),
    'access callback' => TRUE,
  );
  $items['result'] = array(
    'page callback' => 'ndabioresults_pass',
    'load arguments' => array('%map', '%index'),
    'access callback' => TRUE,
  );
  $items['ajax'] = array(
   'page callback' => 'ndabioresults_ajax_callback',
   'access arguments' => array('access content'),
   'type' => MENU_CALLBACK,
  );


  /* This is the new shit */

	$items['result'] = array(
	    'page callback' => '_nba_general_result_callback',
	    'load arguments' => array('%map', '%index'),
	    'access callback' => true,
	);
	$items['result/multimedia'] = array(
	    'page callback' => '_nba_multimedia_result_callback',
	    'load arguments' => array('%map', '%index'),
	    'access callback' => true,
	);
	$items['result/specimen'] = array(
	    'page callback' => '_nba_specimen_result_callback',
	    'load arguments' => array('%map', '%index'),
	    'access callback' => true,
	);
	$items['result/specimen/taxon'] = array(
	    'page callback' => '_nba_specimen_taxon_result_callback',
	    'load arguments' => array('%map', '%index'),
	    'access callback' => true,
	);
	$items['taxon'] = array(
	    'page callback' => '_nba_taxon_callback',
	    'access callback' => true,
	  );
	$items['specimen'] = array(
	    'page callback' => '_nba_specimen_callback',
	    'access callback' => true,
	  );
	$items['multimedia'] = array(
		'page callback' => '_nba_multimedia_callback',
		'access callback' => true,
	);
	  
	return $items;
}



/*
 * Aanpassen: geen souceSystemID maar id!!
 */

function _nba_specimen_callback ($id = false, $scientificNameGroup = false, $search = false) {
	// Test if anything has been posted; if not return with error message
	if (!$id) {
		return _printOops();
	}
	
	$service = 'names.specimens';
	$data = _getSpecimenByUnitId($id);
	if (!$data) {
		return _printOops();
	}
	
	// Only id is set: fetch data
	if ($scientificNameGroup && $search) {
		$client = _initBioPortalClient();
		$terms = _getQueryTerms($service, $search);
    	$specimensFrom = isset($terms['from']) ? $terms['from'] : 0;
    	
    	unset($terms['size'], $terms['from']);
    
		$query = _buildQuery($service, $terms);
		$query
			->addCondition(new Condition('name', 'EQUALS', $scientificNameGroup))
			->setSpecimensFrom($specimensFrom)
			->setSpecimensSize(3);
		
		_addDebugMessage('previous, current and next item', $query);
		
		$set = json_decode($client->names()->setQuerySpec($query)->query());
		
		// We got an error; go oops
		if (isset($set->exception)) {
			return _printOops();
		}
		// Extract data for current id, plus ids of previous and next result
		$data = _addSpecimenDetailPageNavigation(
			$data,
			$search, 
			$set, 
			$id, 
			$specimensFrom, 
			$scientificNameGroup
		);
	}
	
	return _printSpecimenDetail(_parseSpecimenDetail($data));
}



function _addSpecimenDetailPageNavigation ($data, $search, $set, $id, $from, 
	$scientificNameGroup) {
	
//p($set);
	
	$previousId = $nextId = null;
	foreach ($set->resultSet[0]->item->specimens as $i => $row) {
		if (isset($row->unitID) && $row->unitID == $id) {
			//$output = $row;
			break;
		}
	}
	$data->offset = $from + 2;
	if (isset($set->resultSet[0]->item->specimens[($i - 1)]->unitID)) {
		$previousId = $set->resultSet[0]->item->specimens[($i - 1)]->unitID;
	} else {
		$data->offset = 1;
	}
	if (isset($set->resultSet[0]->item->specimens[($i + 1)]->unitID)) {
		$nextId = $set->resultSet[0]->item->specimens[($i + 1)]->unitID;
	}
	$data->previousUrl = _setSpecimenDetailPagePreviousLink(
		$search, 
		$previousId, 
		$scientificNameGroup
	);
	$data->nextUrl = _setSpecimenDetailPageNextLink(
		$search,
		$nextId, 
		$previousId, 
		$scientificNameGroup
	);
	$data->backUrl = _setSpecimenDetailPageBackLink(
		$search, 
		$from, 
		$scientificNameGroup
	);
	$data->scientificNameGroup = $scientificNameGroup;
	$data->totalSize = $set->resultSet[0]->item->specimenCount;
	return $data;
}

function _setSpecimenDetailPagePreviousLink ($search, $previousId, $scientificNameGroup) {
	if (isset($previousId)) {
		safe_parse_str($search, $p);
		// Strip size if it was provided; we don't need it
		if (isset($p['size'])) {
			unset($p['size']);
		}
		// Only proceed if size has been set; otherwise url has been tampered with
		// We have already validated that $p['from'] is an integer
		if (isset($p['from'])) {
			$p['from'] = $p['from'] == 0 ? $p['from'] : $p['from'] - 1;
			return _setBasePath() . 'specimen/' . urlencode($previousId) . '/' . 
				urlencode($scientificNameGroup) . '/' . http_build_query($p);
		}
	}
	return null;
}

function _setSpecimenDetailPageNextLink ($search, $nextId, $previousId, $scientificNameGroup) {
	if (isset($nextId)) {
		safe_parse_str($search, $p);
		// Strip size if it was provided; we don't need it
		if (isset($p['size'])) {
			unset($p['size']);
		}
		// Only proceed if size has been set; otherwise url has been tampered with
		// We have already validated that $p['from'] is an integer
		if (isset($p['from'])) {
			$p['from'] = !isset($previousId) ? $p['from'] : $p['from'] + 1;
			return _setBasePath() . 'specimen/' . urlencode($nextId) . '/' . 
				urlencode($scientificNameGroup) . '/' . http_build_query($p);
		}
	}
	return null;
}

function _setSpecimenDetailPageBackLink ($search, $from, $scientificNameGroup) {
	// Need to reset search to correct from value
	safe_parse_str($search, $p);
	$p['from'] = floor(($p['from'] + 1) * 0.01) * 100;
	return _setBasePath() . 'result/specimen/taxon/' . urlencode($scientificNameGroup) . 
		'/' .http_build_query($p);
}



function _getSpecimenByUnitId ($unitId = false) {
	if (!$unitId) {
		return false;
	}
	$client = _initBioPortalClient();
	$query = new QuerySpec();	
	$query
		->addCondition(new Condition('unitID', 'EQUALS', $unitId))
		->setConstantScore()
		->setSize(1);
	_addDebugMessage('specimen detail', $query);
	$data = json_decode($client->specimen()->setQuerySpec($query)->query());
	if (isset($data->exception)) {
		return false;
	}
	return $data->resultSet[0]->item;	
}




function _nba_multimedia_callback ($id = false, $search = false) {
	// Test if anything has been posted; if not return with error message
	if (!$id) {
		return _printOops();
	}
	
	$service = 'multimedia';
	$client = _initBioPortalClient();
	
	// Build query
	$condition = new Condition('unitID', 'EQUALS', $id);
	$query = new QuerySpec();
	$query->addCondition($condition);
	
	_addDebugMessage('single item', $query);
	
	// Fetch data
	$data = json_decode($client->{$service}()->setQuerySpec($query)->query());
	if (isset($data->exception)) {
		return _printOops();
	}
	$data = $data->resultSet[0]->item;

	if ($search) {
		$terms = _getQueryTerms($service, $search);		
		$terms['size'] = 3;		

		$query = _buildQuery($service, $terms);
		_addDebugMessage('previous, current and next item', $query);
		
		$set = json_decode($client->{$service}()->setQuerySpec($query)->query());
		
		// We got an error; go oops
		if (isset($set->exception)) {
			return _printOops();
		}
		// Extract data for current id, plus ids of previous and next result
		$data = _addMultimediaDetailPageNavigation($data, $search, $set, $id, $terms['from']);
	}
	
	$data = _setMultimediaAssociatedObject($data);
	
	if (isset($data->associatedTaxon)) {
		return _printTaxonMediaDetail(_parseTaxonMediaDetail($data));
	}
	return _printSpecimenMediaDetail(_parseSpecimenMediaDetail($data));
}


function _setMultimediaAssociatedObject ($data) {
	$client = _initBioPortalClient();
	foreach (['taxon', 'specimen'] as $service) {
		$field = 'associated' . ucfirst($service) . 'Reference';
		if (isset($data->{$field}) && !empty($data->{$field})) {
			$appendedField = 'associated' . ucfirst($service);
			$data->{$appendedField} = 
				json_decode($client->{$service}()->find($data->{$field}));
			_addDebugMessage('Associated ' . $service, $client->getNbaQueryUrl());
			unset($client, $query, $condition);
			return $data;
		}
	}
}


function _setMultimediaDetailPagePreviousLink ($search, $previousId) {
	if (isset($previousId)) {
		safe_parse_str($search, $p);
		// Strip size if it was provided; we don't need it
		if (isset($p['size'])) {
			unset($p['size']);
		}
		// Only proceed if size has been set; otherwise url has been tampered with
		// We have already validated that $p['from'] is an integer
		if (isset($p['from'])) {
			$p['from'] = $p['from'] == 0 ? $p['from'] : $p['from'] - 1;
			return _setBasePath() . 'multimedia/' . urlencode($previousId) . '/' . 
				http_build_query($p);
		}
	}
	return null;
}

function _setMultimediaDetailPageNextLink ($search, $nextId, $previousId) {
	if (isset($nextId)) {
		safe_parse_str($search, $p);
		// Strip size if it was provided; we don't need it
		if (isset($p['size'])) {
			unset($p['size']);
		}
		// Only proceed if size has been set; otherwise url has been tampered with
		// We have already validated that $p['from'] is an integer
		if (isset($p['from'])) {
			$p['from'] = !isset($previousId) ? $p['from'] : $p['from'] + 1;
			return _setBasePath() . 'multimedia/' . urlencode($nextId) . '/' . 
				http_build_query($p);
		}
	}
	return null;
}

function _setMultimediaDetailPageBackLink ($search, $from) {
	// Need to reset search to correct from value
	safe_parse_str($search, $p);
	$p['from'] = floor(($p['from'] + 1) * 0.01) * 100;
	return _setBasePath() . 'result/multimedia/' . http_build_query($p);
}

function _addMultimediaDetailPageNavigation ($data, $search, $set, $id, $from) {
	$previousId = $nextId = null;
	foreach ($set->resultSet as $i => $row) {
		if (isset($row->item->unitID) && $row->item->unitID == $id) {
			//$output = $row->item;
			break;
		}
	}
	$data->offset = $from + 2;
	if (isset($set->resultSet[($i - 1)]->item->unitID)) {
		$previousId = $set->resultSet[($i - 1)]->item->unitID;
	} else {
		$data->offset = 1;
	}
	if (isset($set->resultSet[($i + 1)]->item->unitID)) {
		$nextId = $set->resultSet[($i + 1)]->item->unitID;
	}
	$data->previousUrl = _setMultimediaDetailPagePreviousLink($search, $previousId);
	$data->nextUrl = _setMultimediaDetailPageNextLink($search, $nextId, $previousId);
	$data->backUrl =  _setMultimediaDetailPageBackLink($search, $from);
	$data->totalSize = $set->totalSize;
	return $data;
}

function _nba_taxon_callback ($taxon = false, $search = false) {
    // Test if anything has been posted; if not return with error message
    if (!$taxon) {
    	_printOops();
    }
    
    p(nbaFieldTypes());

    $client = _initBioPortalClient();

    // Only taxon is set: fetch data based on scientific name
    if (!$search) {
    	
        $p = explode('_', $taxon);
        $c = new Condition('taxa.acceptedName.genusOrMonomial', 'EQUALS_IC', $p[0]);
        if (count($p) == 2) {
            $c->setAnd('taxa.acceptedName.specificEpithet', 'EQUALS_IC', $p[1]);
            $c->setAnd('taxa.acceptedName.infraspecificEpithet', 'NOT_EQUALS');
        }
        if (count($p) == 3) {
            $c->setAnd('taxa.acceptedName.infraspecificEpithet', 'EQUALS_IC', $p[2]);
        }
        $query = new QuerySpec();
        $query->addCondition($c);
        die($query->getQuerySpec(false));
        die($client->names()->setQuerySpec($query)->query());
    }

    $query = _buildQuery('taxon', $p);
    $client->{$service}()->setQuerySpec($query);
    $remoteData[$service] = $client->query();


    $client->taxon()->setQuerySpec($q);

    return print_r($client->query());

    //return p($client->all()->getMapping());
    //return 'henk' . $taxon . '<br>' . $searchRequest;
}


function _buildQuery ($service, $terms = [], $options = []) {
	// Set operator used to string subconditions together: setOr for simple search, 
	// but setAnd for advanced search fields such as fullScientificName!
	$andOr = 'setAnd';
    if (isset($terms) && isset($terms['term'])) {
		$terms = _setSimpleQueryTerms($service, $terms['term'], $terms);
		$andOr = 'setOr';
	}
	// Names service must include prefix, so use names.taxa or names.specimens
	if (strpos($service, '.') !== false) {
		list($service, $type) = explode('.', $service);
		$lookupService = $type == 'taxa' ? 'taxon' : 'specimen';
		$type .= '.';
		$query = new ScientificNameGroupQuerySpec();
	} else {
		$type = '';
		$lookupService = $service;
		$query = new QuerySpec();
	}
	// Set QuerySpec options; these must exactly match the methods in QuerySpec
	foreach ($options as $method => $p) {
		if (method_exists($query, $method)) {
			$query->{$method}($p);
		}
	}
	// Logical operator is always AND (form and map are exclusive)
	$query->setLogicalOperator('AND');
	// Logical operator is important to compile main QuerySpec: 
	// - for OR we will create one big nested OR query
	// - for AND we will create separate conditions ruled by main logical operator AND
	$logicalOperator = isset($terms['logicalOperator']) && !empty($terms['logicalOperator']) ?
		strtoupper($terms['logicalOperator']) : 'OR';
	// Translate fields to NBA paths and get their operators
    foreach ($terms as $field => $value) {
    	$statement = [];
    	// Exclude search flags; these will be processed later
        if (!in_array($field, searchFlags())) {
            // Get NBA path(s) for field
            $nbaPaths = [$field];
            if (isset(nbaFieldMapping()[$lookupService][$field])) {
                $nbaPaths = nbaFieldMapping()[$lookupService][$field];
            }
            // Get NBA field type
            foreach ($nbaPaths as $path) {
            	$path = $type . $path;
            	// Names identifications are buried even deeper...
            	if ($service == 'names' && strpos($path, '.identifications.') !== false) {
            		$path = str_replace('identifications', 'matchingIdentifications', $path);
            	}
            	$statement[$path] = _getConditionOperator($service, $path, $value);
            	$paths[$path] = [
            		'operator' => $statement[$path],
            		'values' => _stringToElements($value),
            	]; 
            }
        }
        // Group associated statements
		if (!empty($statement)) {
			$statements[] = [
				'statement' => $statement,
				'value' => $value,
				'operator' => $andOr,
			];
		}
    }
    // Store paths for term highlighting
    if (isset($paths)) {
    	$_SESSION['nbaQuery'][empty($type) ? $service : $service . '.' . 
    		substr($type, 0, -1)]['paths'] = $paths;
    }
    // Compile conditions
	$conditions = [];
	foreach ($statements as $d) {
		$statement = $d['statement'];
		$elements = _stringToElements($d['value']);
		$condition = $subconditions = null;
		foreach ($elements as $element) {			
			$first = true;
			foreach ($statement as $path => $operator) {
				// Test if LIKE is still allowed; if not change to MATCHES
				if ($operator == 'LIKE' && !_likeOperatorAllowed($element)) {
					$operator = 'MATCHES';
				}	
				// geoShape is a special case
				if (strpos($path, 'geoShape') !== false) {
					// geoShape arrives from simple search as area name
					// check if location is present in NBA and use that!
					if (strpos($element, '@') === false && !_isValidJson($element)) {
						$area = _localityInNba($element);
						if ($area) {
							$element = $area;
						} else {
							continue;
						}
					// Valid geoShape (gid or geojson); isloate to process later;
					// can only be a single value
					} else {
						$geoShape = [
							'path' => $path,
							'value' => $elements[0],
						];
						continue;
					}
				}
				if ($first) {
					$condition = new Condition($path, $operator, $element);
					$first = false;
					continue;
				}
				$condition->setOr($path, $operator, $element);
			}
			if (!empty($condition)) {
				$subconditions[] = [
					'condition'	=> $condition,
					'operator' => $d['operator'],
				];
			}
		}
		// First make some sense of conditions and subconditions, plus remove potential
		// duplicate queries (in particular those from auto-generated simple search). 
		// Use serialized version of condition as array key to accomplish this.
		// Option 1. No subconditions, clip redundant information
		if (count($subconditions) == 1) {
			$conditions[serialize($subconditions[0]['condition'])] = 
				$subconditions[0]['condition'];
		// Option 2. Subconditions, reformat to slightly more concise notation
		} else if (!empty($subconditions[0]['condition'])) {
			$conditions[serialize(array_column($subconditions, 'condition'))] = [
				'conditions' => array_column($subconditions, 'condition'),
				'operator' => $subconditions[0]['operator'],
			];
		}
	}
	// OR search: string all conditions together with setOr()
	if ($logicalOperator == 'OR') {
		foreach (array_values($conditions) as $i => $condition) {
	    	if ($i == 0) {
	    		$mainCondition = _appendCondition($condition);
	    		continue;
	    	}
	    	$mainCondition = _appendCondition($condition, $mainCondition);
		}
    	$query->addCondition($mainCondition);
	// AND search: all conditions are top level conditions controlled by logicalOperator
	} else {
		foreach (array_values($conditions) as $condition) {
			$query->addCondition(_appendCondition($condition));
		}
	}
    // Add map condition if present
    if (isset($geoShape)) {
	    $query->addCondition(new Condition($geoShape['path'], 'IN', $geoShape['value']));
    }
    // Add search flags
    if (isset($terms['from']) && !empty($terms['from'])) {
        $query->setFrom($terms['from']);
    }
    if (isset($terms['size']) && !empty($terms['size'])) {
        $query->setSize($terms['size']);
    }
    if (isset($terms['sort']) && !empty($terms['sort'])) {
        $sortDirection = true;
        if (isset($terms['sortDirection']) && strtolower($terms['sortDirection']) == 'desc') {
            $sortDirection = false;
        }
        $query->sortBy($terms['sort'], $sortDirection);
    }
    return $query;
}

function _stringToElements ($value) {
	return array_map('trim', array_unique(array_filter(explode(' ', trim($value)))));	
}


function _appendCondition ($condition, $appendTo = false) {
	$andOr = is_array($condition) && isset($condition['operator']) ? 
		$condition['operator'] : 'setOr';
	if (!$appendTo) {
		if (is_object($condition)) {
			return $condition;
		}
		foreach ($condition['conditions'] as $i => $subcondition) {
			if ($i == 0) {
				$output = $subcondition;
				continue;
			}
			$output->{$andOr}($subcondition);
		}
		return $output;
	}
	if (is_object($condition)) {
		return $appendTo->{$andOr}($condition);
	}
	foreach ($condition['conditions'] as $i => $subcondition) {
		if ($i == 0) {
			$output = $subcondition;
			continue;
		}
		$output->{$andOr}($subcondition);
	}
	return $appendTo->{$andOr}($output);
}



/*
 * Sets operator (LIKE, EQUALS, etc) for condition.
 * Fairly simple now, as we only search string fields in BioPortal.
 * Will become more compilated once we allow searches on date or int fields.
 */
function _getConditionOperator ($service, $nbaPath, $value = '') {
    if (isset(nbaFieldTypes()[$service][$nbaPath])) {
        return _getOperatorFromMapping(nbaFieldTypes()[$service][$nbaPath], $value);
    }
    return 'EQUALS';
}


/*
 * Get operator from mapping. If present it's separated by a pipe symbol
 */
function _getOperatorFromMapping ($type, $value) {
    $p = explode('|', $type);
    if (isset($p[1])) {
        return trim($p[1]);
    }
    return 'EQUALS';
}

function _likeOperatorAllowed ($value = '') {
    return
        strlen($value) >= nbaMinLikeStringSize() &&
        strlen($value) <= nbaMaxLikeStringSize();
}


function _nba_multimedia_result_callback ($search = false) {
    global $base_path;
	
    $service = 'multimedia';
	$client = _initBioPortalClient();
	
    $terms = _getQueryTerms($service, $search);
    
    $headTitle = !isset($_SESSION['ndaSearch']['theme']) || empty($_SESSION['ndaSearch']['theme']) ?
        t('Search results') : t('Explore highlights');
    $pageTitle = isset($_GET['theme']) ? '' : $pageTitle;
    _setTitle($headTitle, $pageTitle);   
    
    
    // No search terms; die with grace
    if (!$terms) {
    	_printOops();
    }
    
	// Display full set on this page
	$terms['size'] = maxResults();
	// Save query
	_setQueryTerms($service, $terms);
	
	// Build query
	$query = _buildQuery($service, $terms);	
	
	// Store query in case user wants to print it on screen
	_addDebugMessage($service, $query);
	
	// Fetch data set
	$data = json_decode($client->{$service}()->setQuerySpec($query)->query());
		
	// We got an error; go oops
	if (isset($data->exception)) {
		return _printOops();
	}
	
	return _printDebug() . _printMultimedia(_parseMultimedia($data, ['paginator']));
}

function _nba_specimen_result_callback ($search = false) {
    $service = 'names.specimens';
	$client = _initBioPortalClient();
	
    $terms = _getQueryTerms($service, $search);
    
    $headTitle = !isset($_SESSION['ndaSearch']['theme']) || empty($_SESSION['ndaSearch']['theme']) ?
        t('Search results') : t('Explore highlights');
    $pageTitle = isset($_GET['theme']) ? '' : $pageTitle;
    _setTitle($headTitle, $pageTitle);   
    
    
    // No search terms; die with grace
    if (!$terms) {
    	_printOops();
    }
    
	// Display full set on this page
	$terms['size'] = maxResults();
	// Save query
	_setQueryTerms($service, $terms);
	
	// Build query
	$query = _buildQuery($service, $terms);	
	
	// Store query in case user wants to print it on screen
	_addDebugMessage($service, $query);
	
	// Fetch data set
	$data = json_decode($client->names()->setQuerySpec($query)->query());
	
	// We got an error; go oops
	if (isset($data->exception)) {
		return _printOops();
	}

	$data->specimensTotal = _getSpecimensTotal($terms);
	$data = _parseSpecimens($data, ['paginator']); 
	return _printDebug() . _printSpecimens($data);
}

function _nba_specimen_taxon_result_callback ($scientificNameGroup = false, $search = false) {
    $service = 'names.specimens';
	$client = _initBioPortalClient();
	
    $terms = _getQueryTerms($service, $search);
    $specimensFrom = isset($terms['from']) ? $terms['from'] : 0;
    unset($terms['size'], $terms['from']);
    
    $headTitle = !isset($_SESSION['ndaSearch']['theme']) || empty($_SESSION['ndaSearch']['theme']) ?
        t('Search results') : t('Explore highlights');
    $pageTitle = isset($_GET['theme']) ? '' : $pageTitle;
    _setTitle($headTitle, $pageTitle);   
    
    // No search terms; die with grace
    if (!$scientificNameGroup || !$terms) {
    	_printOops();
    }
    
	// Display full set on this page
	//$terms['size'] = maxResults();
	// Save query
	//_setQueryTerms($service, $terms);
	
	// Build query
	$query = _buildQuery($service, $terms);	
	$query
		->addCondition(new Condition('name', 'EQUALS', $scientificNameGroup))
		->setSpecimensFrom($specimensFrom)
		->setSpecimensSize(maxResults())
	;
//die($query->getQuerySpec(true));
	
	// Store query in case user wants to print it on screen
	_addDebugMessage($service, $query);
	
	// Fetch data set
	$data = json_decode($client->names()->setQuerySpec($query)->query());
	
	// We got an error; go oops
	if (isset($data->exception)) {
		return _printOops();
	}

	$data->specimensFrom = $specimensFrom;
	$data = _parseSpecimens($data, ['paginator']); 
	return _printDebug() . _printSpecimensTaxon($data);
}



function _setLanguage () {
    $langs = language_list(); // Note: No argument
    $langcode = isset($_GET["language"]) && !empty($_GET["language"]) ? $_GET["language"] : '';
    if (!empty($langcode)) {
        variable_set('language_default', $langs[$langcode]);
    }
}


/**
 * Sets head and (optionally) page title
 *
 * @param string $head Head title
 * @param string $page Page title
 */
function _setTitle ($head, $page = '') {
    $_SESSION['ndaPageTitle'] = $head;
    drupal_set_title($page);
}



/**
 * Accepts search form data and returns formatted result
 *
 * The main function that actually processes the incoming GET data, stores the
 * GET data in a SESSION, distributes the search to the appropriate channels
 * and returns the formatted output.
 *
 * Headers were added to avoid problems with "Webpage has expired" in IE after
 * hitting back button
 *
 * @return string The formatted output
*/
function _nba_general_result_callback () {
    global $base_path;
    
    $headTitle = !isset($_SESSION['ndaSearch']['theme']) || empty($_SESSION['ndaSearch']['theme']) ?
        t('Search results') : t('Explore highlights');
    $pageTitle = isset($_GET['theme']) ? '' : $pageTitle;
    _setTitle($headTitle, $pageTitle);   
    
    // GET data from the search form?
    // If so, add to SESSION or replace existing SESSION data
    if (isset($_GET['form_id']) && $_GET['form_id'] == 'ndabio_advanced_taxonomysearch') {
        //drupal_set_title(t("Search results"));
        $_SESSION['ndaSearch'] = $_GET;
        _logSearch();
        return empty($_SESSION['ndaSearch']['term']) ? 
        	_nbaAdvancedSearch() : _nbaSimpleSearch($_SESSION['ndaSearch']['term']);
    }

}

function _getTaxonFromNba ($taxon) {
	$client = _initBioPortalClient();
	$p = explode(' ', $taxon);
	$c = new Condition('taxa.acceptedName.genusOrMonomial', 'EQUALS_IC', $p[0]);
	if (count($p) > 1) {
		$c->setAnd('taxa.acceptedName.specificEpithet', 'EQUALS_IC', $p[1]);
		$c->setAnd('taxa.acceptedName.infraspecificEpithet', 
			(count($p) == 2 ? 'EQUALS' : 'EQUALS_IC'), 
			(count($p) == 2 ? null : $p[2]));
	}
	$query = new ScientificNameGroupQuerySpec();
	$query->addCondition($c);
	_addDebugMessage($taxon . ' exists in NBA', $query);
    $data = json_decode($client->names()->setQuerySpec($query)->query());
	return isset($data->resultSet) ? $data->resultSet : false;
}





/**
 * Distributes search parameters of the advanced search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output
 */
function _nbaAdvancedSearch () {

    // Delete previous search terms when performing new query
    unset($_SESSION['nbaQuery']);

    $services['multimedia'] = _setSectionParameters($_SESSION['ndaSearch'], 'm_');
    $services['names.specimens'] = _setSectionParameters($_SESSION['ndaSearch'], 's_');
    
 //@todo: enable other services!!!!   
//    $services['names.taxa'] = _setSectionParameters($_SESSION['ndaSearch'], 't_');
    
    // Test if anything has been posted; if not return with error message
    if (!dataPosted($services)) {
        _printOops();
    }

    // Get json response for each service that provides search parameters
    foreach ($services as $service => $p) {
        if (_serviceUsed($p)) {
            // Cap results
            $p['size'] = maxResultsInitial();
            // Init client
            $client = _setClientService(_initBioPortalClient(), $service);
            // Build QuerySpec
            $client->setQuerySpec(_buildQuery($service, $p));
            // Must use querySpecial() for names services
            $remoteData[$service] = strpos($service, 'names') === false ?
            	$client->query() : $client->querySpecial();
            // Save service-specific query terms to session; used for navigation
            _setQueryTerms($service);
            // Add to debug, so query can be printed
			_addDebugMessage($service, $client);
        }
    }

    $pageHeader = '';    
    if (isset($_SESSION['ndaSearch']['geoShape']) && !empty($_SESSION['ndaSearch']['geoShape'])) {
        $area = (!empty($_SESSION['ndaSearch']['location']) ?
            $_SESSION['ndaSearch']['location'] : t('area drawn on map'));
        $pageHeader .=
            _wrap(
                _wrap(
                    t("Showing only results in")
                   . " "
                   . _wrap($area, "span", "term"),
                   "h1"
            ), "div", "panel"
        );
    }
    $pageHeader .= _wrap(t('Search results'), "h1");

	// Order is multimedia > specimens > taxa
	if (!empty($remoteData['multimedia'])) {
		$data = _parseMultimedia(json_decode($remoteData['multimedia']), ['showAll']);
		$pageBody = _printDebug() . $pageBody . _printMultimedia($data);
	}
	
	if (!empty($remoteData['names.specimens'])) {
		$data = json_decode($remoteData['names.specimens']); 
		$data->specimensTotal = _getSpecimensTotal($services['names.specimens']);
		$data = _parseSpecimens($data, ['showAll']); 
		$pageBody = _printDebug() . $pageBody. _printSpecimens($data);
	}
	
	if (!empty($remoteData['names.taxa'])) {
		// to do!
	}
	
	

/*
	// Map functions to each channel result: parses and prints data
	$pageBody = '';
	$serviceToFunctions = serviceToFunctions();
	foreach ($remoteData as $service => $json) {
		if (!isset($serviceToFunctions[$service]) || empty($json)) {
			continue;
		}
		$parseFunction = isset($serviceToFunctions[$service]['parse']) ?
		    $serviceToFunctions[$service]['parse'] : false;
		$printFunction = isset($serviceToFunctions[$service]['print']) ?
		    $serviceToFunctions[$service]['print'] : false;
		if (!empty($parseFunction) && !empty($printFunction)) {
		    $pageBody .= $printFunction($parseFunction($json));
		}
	}
*/

    return $pageHeader . (!empty($pageBody) ? $pageBody : '<p>' . printNoResults() . '</p>');
}


function _getSpecimensTotal ($terms) {
	$client = _initBioPortalClient();
	foreach (['size', 'from'] as $p) {
		if (isset($terms[$p])) {
			unset($terms[$p]);
		}
	}
	$options = [
		'setConstantScore' => true,
		'setSize' => 1,
	];
	$client
		->specimen()
		->setQuerySpec(_buildQuery('specimen', $terms, $options)); 
	$data = json_decode($client->query());
	_addDebugMessage('total specimens', $client);
	if (isset($data->totalSize)) {
		return $data->totalSize;
	}
	return -1;
}


// Assume data on genus, species, infraspecies can be deduced from data first specimen
function _setSpecimensAllLink ($row) {
	if (isset($row->item->specimens[0]->matchingIdentifications[0]->scientificName->genusOrMonomial)) {
		$id = $row->item->specimens[0]->matchingIdentifications[0]->scientificName;
		$output = 'result/specimen/?genusOrMonomial=' . urlencode($id->genusOrMonomial);
		if (isset($id->specificEpithet) && !empty($id->specificEpithet)) {
			$output .= '&amp;specificEpithet=' . urlencode($id->specificEpithet);
		}
		if (isset($id->infraspecificEpithet) && !empty($id->infraspecificEpithet)) {
			$output .= '&amp;infraspecificEpithet=' . urlencode($id->infraspecificEpithet);
		}
	}
	return isset($output) ? $output : '';
}

function _setSpecimenSources ($row) {
	foreach ($row->item->specimens as $i => $specimen) {
		$output[$specimen->specimenDetails->sourceSystem->name] = $i;
	}
	return isset($output) ? array_flip($output) : false;
}


function _getSpecimenDetails (&$data) {
	if (!isset($data->resultSet) || empty($data->resultSet)) {
		return false;
	}
	$client = _initBioPortalClient();
	// Aggregate conditions for all specimens in result
	foreach ($data->resultSet as $i => $row) {
		foreach ($row->item->specimens as $item) {
			$condition = new Condition('unitID', 'EQUALS', $item->unitID);
			$query = new QuerySpec();
			$query
				->addCondition($condition)
				->setConstantScore()
				->setSize(1);
			$batch[$item->unitID] = $query;
			_addDebugMessage('details for ' . $item->unitID, $query);
		}
	}
	// Fetch all specimens at once
	if (isset($batch)) {
		$remoteData = $client->specimen()->batchQuery($batch);
		$specimens = array_map('json_decode', $remoteData);
		// Loop again over result and append the fetched specimen details
		foreach ($data->resultSet as $i => $row) {
			foreach ($row->item->specimens as $j => $item) {
				if (isset($specimens[$item->unitID])) {
					$detail = $specimens[$item->unitID];
					$data->resultSet[$i]->item->specimens[$j]->specimenDetails =
						$detail->resultSet[0]->item;
				}
			}
		}
//echo 'errors: ' ; echo count($client->getCurlErrors()); p($client->getCurlErrors());
		return $data;
	}
	return false;
}


function _setQueryTerms ($service, $terms = false) {
    // Search form
    if (!$terms) {
    	// Names again...
    	$section = strpos($service, '.') !== false ?
    		substr($service, strpos($service, '.') + 1, 1) . '_' : $service[0] . '_';
        $terms = _setSectionParameters($_GET, $section);
    }
    $_SESSION['nbaQuery'][$service]['terms'] = $terms;
    return $terms;
}

function _getStoredQueryTerms ($service) {
    return isset($_SESSION['nbaQuery'][$service]['terms']) ?
		$_SESSION['nbaQuery'][$service]['terms'] : false;
}

function _getQueryTerms ($service, $search) {
	// Convert query string to parameters
	if ($search) {
		safe_parse_str($search, $terms);
	// Revert to stored terms to fetch terms (non-preferred!)
    } else if ($service) {
    	$terms = _getStoredQueryTerms($service);
    }
	if (!$terms) {
		return false;
	}
	if (!isset($terms['from']) || !ctype_digit(strval($terms['from']))) {
		$terms['from'] = 0;
	}
	return $terms;
}

function _termsToQuerySpec ($service, $terms) {
	// Simple search
    if (isset($terms) && isset($terms['term'])) {
		$terms = _setSimpleQueryTerms($service, $terms['term'], $terms);
	}
	return $terms;
}

function _getSearchTerms (array $terms) {
	foreach (searchFlags() as $flag) {
		if (isset($terms[$flag])) {
			unset($terms[$flag]);
		}
	}
	return !empty($terms) ? $terms : false;
}


/*
function _getServiceSearchTerms ($service) {
	if (isset($_SESSION['nbaQuery'][$service]['terms'])) {
		$terms = $_SESSION['nbaQuery'][$service]['terms'];
        foreach (searchFlags() as $flag) {
            if (isset($terms[$flag])) {
                unset($terms[$flag]);
            }
        }
        return $terms;
    }
    return false;
}
*/

function _getQueryPaths ($service) {
	return isset($_SESSION['nbaQuery'][$service]['paths']) ?
		$_SESSION['nbaQuery'][$service]['paths']: false;
}

function _getPaginator ($service, $total, $from) {
	$offset = $from / maxResults() + 1;
	$paginator = new Paginator($total, maxResults(), $offset, _setPaginatorUrl());
	return $paginator->toHtml();
}

/**
 *
 * Sets url for paginator
 *
 * Strips offset from self link and replaces this with placeholder for paginator
 *
 * @param array $data Json
 * @param boolean $groupResult
 * @return string Url
 */
function _setPaginatorUrl () {
	// Strip off the from component of the url
    $search = basename(_setBasePath() . current_path());
    safe_parse_str($search, $p);
    if (isset($p['from'])) {
    	unset($p['from']);
    }
    return _setBasePath() . str_replace($search, '', current_path()) . 
    	http_build_query($p) . '&from=(:num)';
}

/**
 * Gets _offset from json
 *
 * @param array $data Json
 * @return int Offset
 */
function _getOffset ($service) {
    if (isset(_getStoredQueryTerms($service)['from'])) {
        return _getStoredQueryTerms($service)['from'];
    }
    return 0;
}



function _setSimpleQueryTerms ($service, $term, $additionalTerms = []) {
	if (strpos($service, '.') !== false) {
		$parts = explode('.', $service);
		$service = $parts[1] == 'taxa' ? 'taxon' : 'specimen';
	}
	if (isset(nbaFieldMapping()[$service])) {
		// Remove gid and search from mapping
		$mapping = array_diff_key(nbaFieldMapping()[$service], 
			array_flip(['gid', 'term']));
		// Remove search from additional terms
		if (isset($additionalTerms['term'])) {
			unset($additionalTerms['term']);
		}
		foreach ($mapping as $field => $paths) {
			$terms[$field] = $term;
		}
		$terms['logicalOperator'] = 'or';
		return array_filter(array_merge($terms, $additionalTerms));
	}
	return false;
}


function _localityInNba ($locality) {
	$locality = ucfirst($locality);
	$nbaAreas = (array) json_decode(nbaGeoAreas(), true);
	$suffices = [
		'Landschap Noord-Holland',
		'Staatsbosbeheer',
		'PWN',
		'Natura 2000',
		'Beschermde Natuurmonumenten',
		'Wetlands 2005',
	];
	$areas = array_merge(
		_arrayColumnRecursive($nbaAreas, 'en'),
		_arrayColumnRecursive($nbaAreas, 'nl')
	);
	if (in_array($locality, $areas)) {
		return $locality;
	}
	foreach ($suffices as $suffix) {
		if (in_array($locality . ' (' . $suffix . ')', $areas)) {
			return $locality . ' (' . $suffix . ')';
		}
	}
	return false;
}


/**
 * Distributes search parameter of the simple search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output
 */
function _nbaSimpleSearch ($term) {

	
	// Delete previous search terms when performing new query
    unset($_SESSION['nbaQuery']);
	
/*	
    foreach ($services as $service => $querySpec) {
    	if ($service == 'names.taxa') {
	    	header('Content-Type: application/json');
	    	echo $querySpec->getQuerySpec(false);
    	}
    }
*/    
    $p['term'] = $_SESSION['ndaSearch']['term'];
    
    
    // @todo: enable specimens and taxa!!
    //$services['names.taxa'] = $p;
    
    // Taxon search does not include geoShape and should not be invoked when coming from geo form
    // when a search are has been entered
    if (isset($_SESSION['ndaSearch']['gid']) && !empty($_SESSION['ndaSearch']['gid']) || 
    	isset($_SESSION['ndaSearch']['geoShape']) && !empty($_SESSION['ndaSearch']['geoShape'])) {
        unset($services['names.taxa']);

        $p['geoShape'] = $_SESSION['ndaSearch']['geoShape'];
        $p['gid'] = _setNbaGid($_SESSION['ndaSearch']['gid']);
       
        $area = (!empty($_SESSION['ndaSearch']['location']) ? $_SESSION['ndaSearch']['location'] :
            t('area drawn on map'));

        $pageHeader =
            _wrap(
                _wrap(
                    t("Showing only results in")
                   . " "
                   . _wrap($area, "span", "term"),
                   "h1"
                ), "div", "panel"
            );
    };
    
    //$services['names.specimens'] = $p;
    $services['multimedia'] = $p;
    
    // Get json response for each service that provides search parameters
    foreach ($services as $service => $terms) {
		// Cap results
		$p['size'] = maxResultsInitial();

		// Init client, construct query, fetch results in $remoteData
		$client = _setClientService(_initBioPortalClient(), $service);
        $client->setQuerySpec(_buildQuery($service, $p));
		$remoteData[$service] = $client->query();
		
		// Save service-specific query to session;
		// used for further navigation
		$_SESSION['nbaQuery'][$service]['terms'] = $terms;
		_addDebugMessage($service, $client);
    }
    
    $pageHeader = _printDebug(); 
    $pageHeader .= _wrap(t('Search results for') . ' ' .
        _wrap($_SESSION['ndaSearch']['term'], "span", "term"), "h1");
    $pageBody = '';

	// Order is multimedia > specimens > taxa
	if (!empty($remoteData['multimedia'])) {
		$data = json_decode($remoteData['multimedia']);
		$pageBody .= _printMultimedia(_parseMultimedia($data, ['showAll']));
	}
	
	if (!empty($remoteData['names.specimens'])) {
		$data = _enrichSpecimenData(json_decode($remoteData['names.specimens'])); 
		$pageBody .= _printSpecimens(_parseSpecimens($data));
	}
	
	if (!empty($remoteData['names.taxa'])) {
		// to do!
	}

    return $pageHeader . 
    	(!empty($pageBody) ? $pageBody : '<p>' . printNoResults() . '</p>');
}

/**
 * Sets url to search form
 *
 * Used to create links back to search form; differentiates between home and
 * geographic search page
 *
 * @return string Url to last used form
 */
function _setStartUrl () {
    if (isset($_SESSION['ndaSearch']['geoShape'])) {
        return _setBasePath() . "geographic-search/";
    }
    return _setBasePath();
}

/**
 * Sets base url
 *
 * Sometimes Drupal home is not accessible at the site root; this function returns the
 * base of of the Drupal installation
 *
 * @return string Url to Drupal root
 */
function _setBasePath () {
    global $base_root, $base_path;
    return $base_root . $base_path;
}








































/**
 * Distributes search parameter of the simple search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output
 */
function nbaSimpleSearch () {

    return 'Not so fast...';

    $pageHeader = '';
    $p['_search'] = $_SESSION['ndaSearch']['term'];

    // Taxon search does not include geoShape and should not be invoked when coming from geo form
    // when a search are has been entered
    if (!isset($_SESSION['ndaSearch']['gid']) || empty($_SESSION['ndaSearch']['gid']) &&
        empty($_SESSION['ndaSearch']['geoShape'])) {
        $services[taxonService()] = $p;
    }

    // Other searches do include geoShape if entered
    if (isset($_SESSION['ndaSearch']['geoShape']) && !empty($_SESSION['ndaSearch']['geoShape'])) {
        $p['_geoShape'] = $_SESSION['ndaSearch']['geoShape'];

        $area =  (!empty($_SESSION['ndaSearch']['location']) ? $_SESSION['ndaSearch']['location'] :
            t('area drawn on map'));

        $pageHeader =
            _wrap(
                _wrap(
                    t("Showing only results in")
                   . " "
                   . _wrap($area, "span", "term"),
                   "h1"
                ), "div", "panel"
            );
    };

    $pageHeader .= _wrap(t('Search results for') . ' ' .
        _wrap($_SESSION['ndaSearch']['term'], "span", "term"), "H1");

    $services[specimenNamesService()] = $p;
    $services[multimediaService()] = $p;
    $services[specimenService()] = $p;

    // Set session with NBA query type;
    // used to determine if show all should be printed
    unset($_SESSION['ndaFilters']);
    $_SESSION['ndaRequestType'] = 'form';
    $_SESSION['ndaPageDetail'] = 'result from simple form';

    $pageBody = performNdaRequest(setChannels($services));

    return $pageHeader . (!empty($pageBody) ? $pageBody : '<p>' . printNoResults() . '</p>');
}

/**
 * Implements template_preprocess_html().
 *
 * Add an extra class to the body to trigger CSS styles
 *
 */
function ndabioresults_preprocess_html(&$vars){
    if (isset($_SESSION['ndaRequestType']) && $_SESSION['ndaRequestType'] !== 'form'){
        $vars['classes_array'][] = "nba-result-detail";
    }
    if (isset($_SESSION['ndaPageTitle']) && current_path() != '') {
 	    $pathComponents = explode('/', current_path());
	    if (in_array($pathComponents[0], ['result', 'multimedia', 'specimen', 'taxon'])) {
        	$vars['head_title'] = $_SESSION['ndaPageTitle'] . ' | BioPortal';
		    $vars['classes_array'][] = 'page-nba-result';
	    }
	}
}

/**
 * Gets other specimens in "specimen collection" (Brahms)
 *
 * @param array $row Other specimens in set section of NBA response
 * @return array|void Array with other specimens
 */
function _getOtherSpecimens ($data) {
	if (isset($data->assemblageID) && !empty($data->assemblageID)) {
		// This information is not present anymore in v2, we must query ourselves
		$client = _initBioPortalClient();
		$query = new QuerySpec();
		$query
			->addCondition(new Condition('assemblageID', 'EQUALS', $data->assemblageID))
			->setConstantScore();
		_addDebugMessage('other specimens in assembly', $query);
		$result = json_decode($client->specimen()->setQuerySpec($query)->query());
		if ($result && $result->totalSize > 1) {
			foreach ($result->resultSet as $specimen) {
				if ($specimen->item->unitID != $data->unitID) {
					$s = [];
					$s['unitID'] = _setUnitId($specimen->item->unitID);
					$s['collectionType'] = $specimen->item->collectionType;
					$s['url'] = _getSpecimenInCollectionUrl(
						$specimen->item, 
						$data->scientificNameGroup
					);
					$c[] = $s;
				}
			}
		}
	}
	return isset($c) ? $c : null;
}


function _getSpecimenMultimedia ($id, $unitId, $scientificName) {
	$client = _initBioPortalClient();
	$query = new QuerySpec();
	$query
		->addCondition(new Condition('associatedSpecimenReference', 'EQUALS', $id))
		->setSize(5)
		->setConstantScore();
	_addDebugMessage('specimen multimedia', $query);
	$result = json_decode($client->multimedia()->setQuerySpec($query)->query());
	if ($result && $result->totalSize > 0) {
		$output = [];
		$output['totalSize'] = $result->totalSize;
		$output['showAllLink'] = $result->totalSize > 5 ?
			_setBasePath() . 'multimedia/unitID=' . url_encode($unitId) . 
			'&logicalOperator=AND&size=100' : null;
		foreach ($result->resultSet as $i => $media) {
			$output['items'][$i]['id'] = $media->item->id;
			$output['items'][$i]['src'] = $media->item->serviceAccessPoints[0]->accessUri;
			$output['items'][$i]['format'] = $media->item->serviceAccessPoints[0]->format;
			$output['items'][$i]['hits'] = isset($media->item->sourceSystem->name) ? 
				$media->item->sourceSystem->name : null;
			$output['items'][$i]['caption'] = $scientificName;
			$output['items'][$i]['url'] = _setBasePath() . 'multimedia/' . 
				urlencode($media->item->unitID);
		}
		return $output;
	}
	return null;
}










/* The old stuff */




/**
 * Mapping function: distributes parameters to appropriate specimen service
 *
 * Distributes specimens search parameters between specimen and specimen name
 * services. Important: list of parameters should be complete!
 *
 * @param array $sP Search parameters
 * @param string $type Service type
 *
 * @return array Reduced array of search criteria for the service of choice
 */
function setSpecimenParameters (array $sP, $type) {
    $parameters = array(
        specimenService() => array(
            'collectingStartDate',
            'collectionFieldNumber',
            'collectorsFieldNumber',
            'gatheringAgent',
            'localityText',
            'phaseOrStage',
            'unitID',
            'sex',
            'taxonomicStatus',
            'typeStatus',
            'sourceSystem',
            'collectionType',
            '_geoShape'
        ),
        specimenNamesService() => array(
            'className',
            'family',
            'genusOrMonomial',
            'kingdom',
            'order',
            'phylum',
            'specificEpithet',
            'infraspecificEpithet',
            'vernacularName',
            '_geoShape',
            '_showMap',
            'scientificName'
        )
    );
    foreach ($parameters[$type] as $p) {
        if (isset($sP[$p]) && (!empty($sP[$p]) || is_numeric($sP[$p]))) {
            $d[$p] = $sP[$p];
        }
    }
    // If any parameters are found, append andOr and geoShape (if applicable)
    if (isset($d)) {
        $d['_andOr'] = $sP['_andOr'];
        if (!empty($sP['geoShape'])) {
            $d['_geoShape'] = $sP['geoShape'];
        }
    }
    return isset($d) ? $d : null;
}

/**
 * Accepts search form data and returns formatted result
 *
 * The main function that actually processes the incoming POST data, stores the
 * POST data in a SESSION, distributes the search to the appropriate channels
 * and returns the formatted output.
 *
 * Headers were added to avoid problems with "Webpage has expired" in IE after
 * hitting back button
 *
 * @return string The formatted output

function ndabioresults_pass ($args = "") {
    global $base_path;
    $langs = language_list(); // Note: No argument
    $langcode = isset($_GET["language"]) && !empty($_GET["language"]) ? $_GET["language"] : '';
    if (!empty($langcode)) {
        variable_set('language_default', $langs[$langcode]);
    }

    // SESSION variables that have to be reset for each request
    unset($_SESSION['ndaPageTitle']);

    // Keep track of NBA search history
    if (isset($_GET['nba_request']) || isset($_GET['form_id']) || isset($_GET['back'])
        || isset($_GET['theme'])) {
        // Add direct requests to history if they are search service requests...
        if (isset($_GET['nba_request']) && isSearchService(urldecode($_GET['nba_request']))) {
             $_SESSION['ndaHistory'][] = $_GET['nba_request'];
        // ... or from the search form of course
        } else if (isset($_GET['form_id'])) {
            $_SESSION['ndaHistory'][] = 'form';
        // ... or from a menu link to a theme
        } else if (isset($_GET['theme'])) {
            $_SESSION['ndaHistory'][] = 'theme';
            // If coming from a back link itself, remove the link from history
        } else if (isset($_GET['back']) && isSearchService($_SESSION['ndaCurrentService'])) {
            array_pop($_SESSION['ndaHistory']);
        }
    }

    drupal_add_http_header('Expires', 'Sat, 01 Jan 2000 00:00:00 GMT');
    drupal_add_http_header('Last-Modified', gmdate("D, d M Y H:i:s") . ' GMT');
    drupal_add_http_header('Cache-Control', 'post-check=0, pre-check=0');
    session_cache_limiter("must-revalidate");
    drupal_add_js("var str_base_path = '$base_path' ", 'inline');

    // Thematic search
    if (isset($_GET['theme']) && !empty($_GET['theme'])) {
        unset($_SESSION['ndaSearch']);
        $_SESSION['ndaSearch']['theme'] = $_GET['theme'];
        return ndaThematicSearch();
    }

    // Back link clicked. Check search history to see if user comes from search form
    // or from paginated result set. If the latter, use history to navigate; else
    // proceed as if POST data was received but retrieve this from SESSION
    if (isset($_GET['back']) && isset($_SESSION['ndaSearch']) && !empty($_SESSION['ndaSearch'])) {
       drupal_set_title(t("Search results"));

       $lastSearch = isset($_SESSION['ndaHistory']) && !empty($_SESSION['ndaHistory']) ?
            end($_SESSION['ndaHistory']) : false;
       if ($lastSearch && $lastSearch != 'form' && $lastSearch != 'theme') {
            return ndaDirectRequest(end($_SESSION['ndaHistory']));
        } else if (!empty($_SESSION['ndaSearch']['term'])) {
            return ndaSimpleSearch();
        } else if (!empty($_SESSION['ndaSearch']['theme'])) {
            return ndaThematicSearch();
        } else {
            return ndaAdvancedSearch();
        }
    }

    // POST data from the search form?
    // If so, add to SESSION or replace existing SESSION data
    if (isset($_GET['form_id']) && $_GET['form_id'] == 'ndabio_advanced_taxonomysearch') {
        drupal_set_title(t("Search results"));

        $_SESSION['ndaSearch'] = $_GET;
        logSearch();
        return empty($_SESSION['ndaSearch']['term']) ? ndaAdvancedSearch() : ndaSimpleSearch();
    }

    // GET data from within NDA response?
    // Forward directly to appropriate service
    else if (isset($_GET['nba_request'])) {
        // @todo: check direct url for injection?
        return ndaDirectRequest(urldecode($_GET['nba_request']));
    }

    // If both POST and SESSION are empty we have a problem...
    else {
        // Probably best to redirect gracefully to search page?
        handleError('No POST data received! Form validation should trap this.
            Redirect to home if this occurs?');
        drupal_goto('');
    }
}
*/

/**
 * Logs searches to Drupal
 *
 * Agregates data from search form (as SESSION data) and stores search and
 * user data in json file for use in Kibana. Optiionally the same datab can
 * also be saved to the Drupal database (search_log content type).
 *
 *  * @param boolean $saveToDb When provided, data is also saved to database
 */
function _logSearch ($saveToDb = false) {
    foreach ($_SESSION['ndaSearch'] as $k => $v) {
        $skip = array(
            'op', 'form_build_id', 'form_token', 'form_id'

        );
        if (in_array(strtolower($k), $skip) ||
            $k == 'geoShape' && !empty($_SESSION['ndaSearch']['gid'])) {
            continue;
        }
        $data['field_' . strtolower($k)] = $v;
    }
    $data['field_timestamp'] = date('Y-m-d H:i:s');
    $data['field_ip_address'] = $_SERVER['REMOTE_ADDR'];
    $data['field_user_agent'] = $_SERVER['HTTP_USER_AGENT'];
    $data['field_search_type'] = !empty($_SESSION['ndaSearch']['geoShape']) ? 'geo ' :
        (empty($data['field_term']) ? 'advanced' : 'simple');
    $file = variable_get('ndabioresults_config_log', NBALOG); // "/tmp/bioportal.log.json";
    file_put_contents($file, json_encode($data) . "\r\n", FILE_APPEND);

    if ($saveToDb) {
        $node = new stdClass();
        $node->title = $data['field_search_type'] . ' | '. $data['field_ip_address'] .
                ' | ' . $data['field_timestamp'];
        $node->type = "search_log";
        node_object_prepare($node);

        $node->language = LANGUAGE_NONE; // Or 'en' if locale is enabled
        $node->uid = $user->uid;
        $node->status = 0; //(1 or 0): published or not
        $node->promote = 0; //(1 or 0): promoted to front page
        $node->comment = 0; // 0 = comments disabled
        foreach ($data as $k => $v) {
            if ($v != '') {
                $node->{$k}[$node->language][0]['value'] = $v;
            }
        }
        $node = node_submit($node); // Prepare node for saving
        node_save($node);
    }
}

/**
 * Returns NBA result as JSON, based on given request
 *
 * Returns json from NBA from Ajax call; request should be given as GET parameter.
 * Optionally this service can return just the total number of records, if getTotal
 * is provided as GET parameter.
 */
function ndabioresults_ajax_callback () {
    drupal_add_http_header('Content-Type', 'application/json');
    if (isset($_GET['nba_request'])) {
        // For the time being this service is used only to retrieve totalSize
        // Therefore maxResults is capped to 1 by default
        $remoteData = ndaAjaxRequest(urldecode($_GET['nba_request']));
        if (isset($_GET['getTotal'])) {
            $data = json_decode((reset($remoteData)));
            die($data->totalSize);
        }
        die(reset($remoteData));
    }
    die('Invalid NBA request');
}


/**
 * Distributes search parameter of the simple search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output

function ndaSimpleSearch () {

    $pageHeader = '';
    $p['_search'] = $_SESSION['ndaSearch']['term'];

    // Taxon search does not include geoShape and should not be invoked when coming from geo form
    // when a search are has been entered
    if (!isset($_SESSION['ndaSearch']['gid']) || empty($_SESSION['ndaSearch']['gid']) &&
        empty($_SESSION['ndaSearch']['geoShape'])) {
        $services[taxonService()] = $p;
    }

    // Other searches do include geoShape if entered
    if (isset($_SESSION['ndaSearch']['geoShape']) && !empty($_SESSION['ndaSearch']['geoShape'])) {
        $p['_geoShape'] = $_SESSION['ndaSearch']['geoShape'];

        $area =  (!empty($_SESSION['ndaSearch']['location']) ? $_SESSION['ndaSearch']['location'] :
            t('area drawn on map'));

        $pageHeader =
            _wrap(
                _wrap(
                    t("Showing only results in")
                   . " "
                   . _wrap($area, "span", "term"),
                   "h1"
                ), "div", "panel"
            );
    };

    $pageHeader .= _wrap(t('Search results for') . ' ' .
        _wrap($_SESSION['ndaSearch']['term'], "span", "term"), "H1");

    $services[specimenNamesService()] = $p;
    $services[multimediaService()] = $p;
    $services[specimenService()] = $p;

    // Set session with NBA query type;
    // used to determine if show all should be printed
    unset($_SESSION['ndaFilters']);
    $_SESSION['ndaRequestType'] = 'form';
    $_SESSION['ndaPageDetail'] = 'result from simple form';

    $pageBody = performNdaRequest(setChannels($services));

    return $pageHeader . (!empty($pageBody) ? $pageBody : '<p>' . printNoResults() . '</p>');
}
*/

/**
 * Distributes search parameters of the advanced search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output

function ndaAdvancedSearch () {

    $pageHeader = '';

    unset($_SESSION['ndaFilters']);
    $services[multimediaService()] = _setSectionParameters($_SESSION['ndaSearch'], 'm_');
    $services[taxonService()] = _setSectionParameters($_SESSION['ndaSearch'], 't_');
    $services[specimenService()] = _setSectionParameters($_SESSION['ndaSearch'], 's_');
    $services[specimenNamesService()] = _setSectionParameters($_SESSION['ndaSearch'], 'n_');

    // Special case for specimen/search: unset this service if only geoShape is present;
    // results of specimen/name-search and specimen/search will then be identical
    if (!serviceUsed($services[specimenService()])) {
        unset($services[specimenService()]);
    }

    // Another check: specimen/search is used but specimen/name-search is not
    if (isset($services[specimenService()]) && !serviceUsed($services[specimenNamesService()])) {
        unset($services[specimenNamesService()]);
    }

    // Now check if either multimedia or specimen has search parameters
    // If so, unset the "empty" service; if not, pass both
    if (!serviceUsed($services[specimenNamesService()]) && serviceUsed($services[multimediaService()])) {
        unset($services[specimenNamesService()]);
    } else if (serviceUsed($services[specimenNamesService()]) && !serviceUsed($services[multimediaService()])) {
        unset($services[multimediaService()]);
    }

    if (isset($_SESSION['ndaSearch']['geoShape']) && !empty($_SESSION['ndaSearch']['geoShape'])) {
        $area =  (!empty($_SESSION['ndaSearch']['location']) ?
            $_SESSION['ndaSearch']['location'] : t('area drawn on map'));

        $pageHeader =
            _wrap(
                _wrap(
                    t("Showing only results in")
                   . " "
                   . _wrap($area, "span", "term"),
                   "h1"
            ), "div", "panel"
        );
    }
    $pageHeader .= _wrap(t('Search results'),"H1");


    // Test if anything has been posted; if not return with error message
    if (!dataPosted($services)) {
        return $pageHeader. _wrap(t('Oops, something went wrong') . '. ' .
            "<a href='" . setStartUrl() . "'>" . t('Back to home page') . '</a>.', 'p');
    }

    // Set session with NBA query type;
    // used to determine if show all should be printed
    $_SESSION['ndaRequestType'] = 'form';
    $_SESSION['ndaPageDetail'] = 'result from advanced form';

    $pageBody = performNdaRequest(setChannels($services));

    return $pageHeader . (!empty($pageBody) ? $pageBody : '<p>' . printNoResults() . '</p>');
}
*/

/**
 * Sets url to search form
 *
 * Used to create links back to search form; differentiates between home and
 * geographic search page
 *
 * @return string Url to last used form
 */
function setStartUrl () {
    if (isset($_SESSION['ndaSearch']['geoShape'])) {
        return setBasePath() . "geographic-search/";
    }
    return setBasePath();
}

/**
 * Sets base url
 *
 * Sometimes Drupal home is not accessible at the site root; this function returns the
 * base of of the Drupal installation
 *
 * @return string Url to Drupal root
 */
function setBasePath () {
    global $base_root, $base_path;
    return $base_root . $base_path;
}

/**
 * Checks if any search parameters have been set for a service
 *
 * @param string $service Service
 * @return boolean
 */
function _serviceUsed ($service) {
    return _countSearchParameters($service) > 0;
}

/**
 * Performs thematic search
 *
 * For thematic search, two services are called: multimedia and specimen.
 * Currenty this service simply returns the search results. However, it is
 * already more or less ready to be used as an additional filter to the search form
 *
 * @return string Formatted result page
 */
function ndaThematicSearch () {

    unset($_SESSION['ndaFilters']);
    $services[multimediaService()] = _setSectionParameters($_SESSION['ndaSearch'], 'm_');
    $services[specimenService()] = _setSectionParameters($_SESSION['ndaSearch'], 's_');

    $services[multimediaService()]['theme'] = $_SESSION['ndaSearch']['theme'];
    // Sort multimedia by specimen name
    $services[multimediaService()]['_sort'] = 'identifications.scientificName.fullScientificName';
    $services[multimediaService()]['_sortDirection'] = 'ASC';

    $services[specimenService()]['theme'] = $_SESSION['ndaSearch']['theme'];
    // Sort specimens by registration number
    $services[specimenService()]['_sort'] = 'unitID';
    $services[specimenService()]['_sortDirection'] = 'ASC';

    $pageHeader = '';
    ctools_class_add(array('thematic-search'));

    // Test if anything has been posted; if not return with error message
    if (!dataPosted($services)) {
        return $pageHeader. _wrap(t('Oops, something went wrong') . '. ' .
            "<a href='" . setStartUrl() . "'>" . t('Back to home page') . '</a>.', 'p');
    }

    // Set session with NBA query type;
    // used to determine if show all should be printed
    $_SESSION['ndaRequestType'] = 'form';
    $_SESSION['ndaPageDetail'] = 'result from thematic search';

    // We have to override the default sort and sort direction for thematic search
    // Add true flag to setChannels()
    $pageBody = performNdaRequest(setChannels($services, true));

    return $pageHeader . (!empty($pageBody) ? $pageBody : '<p>' . printNoResults() . '</p>');
}

/**
 * Performs direct request
 *
 * Takes request from url as input, redirects this to the appropriate
 * service and returns formatted html.
 *
 * @param string $r Request url
 * @return string|void (empty array) Formatted output
 */
function ndaDirectRequest ($r) {
    foreach (serviceToFunctions() as $service => $d) {
        if (strpos($r, $service) !== false) {
            $url = parse_url($r);
            //parse_str($url['query'], $q);
            safe_parse_str($url['query'], $q);

            // Cap maxResults to max
            if (!isset($q['_maxResults']) || $q['_maxResults'] > maxResults()) {
                $q['_maxResults'] = isGroupService($service) ? maxGroupResults() : maxResults();
            }

            // Special case for specimens on map: remove _sort and _offset
            if (isset($q['_showMap'])) {
                unset($q['_sort'], $q['_offset']);
            }

            // Set geoShape from SESSION if geoShape is part of the request
            if (isset($q['_geoShape']) && $q['_geoShape'] == '[session]' &&
                isset($_SESSION['ndaStoredGeoShape'])) {
                $q['_geoShape'] = $_SESSION['ndaStoredGeoShape'];
            }

            $channels[0]['request'] = $service;
            $channels[0]['url'] = nbaBaseUrl() . $service;
    		$channels[0]['method'] = $d['method'];
    		// If ES request parameter contains dots, these should be replaced with @ and reverted to
    		// dots at this point
    		$channels[0]['postfields'] = http_build_query($q);
    		// Set session variable with last used service;
            // used to determine current detail page
            $_SESSION['ndaCurrentService'] = $service;
            // Set session with NBA query type;
            // used to determine if show all should be printed
            $_SESSION['ndaRequestType'] = 'url';
            // Set session with info about current page;
            // used to set appropriate blocks
            $_SESSION['ndaPageDetail'] = $d['info'];

            return performNdaRequest($channels);
        }
    }
    return array();
}

/**
 * Dedicated service to use for Ajax request
 *
 * Takes request url, redirects to the appropriate service and returns
 * unformatted NBA json
 *
 * @param string $r Request url
 * @param string $maxResults Optional max results
 * @return json|void
 */
function ndaAjaxRequest ($r, $maxResults = false) {
    foreach (serviceToFunctions() as $service => $d) {
        if (strpos($r, $service) !== false) {
            $url = parse_url($r);
            safe_parse_str($url['query'], $q);

            if ($maxResults && is_int($maxResults) && $maxResults <= maxResults()) {
                $q['_maxResults'] = $maxResults;
            }

            $channels[0]['request'] = $service;
    		$channels[0]['url'] = nbaBaseUrl() . $service;
    		$channels[0]['method'] = $d['method'];
    		$channels[0]['postfields'] = str_replace('%40', '.', http_build_query($q));
            return queryNda($channels);
        }
    }
    return null;
}

/**
 * Checks if data has been posted
 *
 * Takes the $services array from form submission and checks if any field contains data
 *
 * @param array $services
 * @return boolean
 */
function dataPosted ($services) {
    foreach ($services as $data) {
        if (!empty($data)) {
            return true;
        }
    }
    return false;
}


/**
 * Sets curl channels
 *
 * Sets request and url parameters for curl channels
 *
 * @param array Service array (service name => search parameters)
 * @return array|void Channels for curl
 */
function setChannels (array $services, $overrideDefault = false) {
    $i = 0;
    $serviceSettings = serviceToFunctions();
	foreach ($services as $s => $p) {
	    if (!empty($p)) {
	        $p = array_filter($p, 'strlen');

	        // Append default search parameters for form
	        $p['_maxResults'] = maxResultsInitial();
	        // Allow override for default sort and sort direction
	        // for special cases (thematic search)
	        if (!$overrideDefault) {
    	        $p['_sort'] = defaultSort();
    	        $p['_sortDirection'] = defaultSortDirection();
	        }

	        $channels[$i]['request'] = $s;
    		$channels[$i]['url'] = nbaBaseUrl() . $s;
    		$channels[$i]['method'] = $serviceSettings[$s]['method'];
    		$channels[$i]['postfields'] =  http_build_query($p);
    		$i++;
	    }
	}
	return isset($channels) ? $channels : array();
}

/**
 * Filters input parameters from advanced search
 *
 * Input parameters in advanced search form are prefixed with s_, t_, or m_
 * to differentiate between specimen, taxon and multimedia searches. This function
 * creates a new array of input parameters, filtering empty values and stripping
 * the prefix from the input.
 *
 * @param array $post The input as key => value pairs
 * @param string $typeId The input prefix (s_, t_, m_)
 *
 * @return array|void Filtered key => value pairs
 */
function _setSectionParameters (array $terms, $typeId = '') {
    if ($typeId == '') {
        return $terms;
    }
    $d = [];
    foreach ($terms as $k => $v) {
        if (strpos($k, $typeId) === 0 && (!empty($v) || is_numeric($v))) {
            $d[str_replace($typeId, '', $k)] = trim($v);
        }
    }
    // Append geoShape if entered
    if (isset($terms['geoShape']) && !empty($terms['geoShape']) &&
        in_array($typeId, ['m_', 's_'])) {
        $d['geoShape'] = $terms['geoShape'];
    }
    // Same for gid
    if (isset($terms['gid']) && !empty($terms['gid']) &&
        in_array($typeId, ['m_', 's_'])) {
        $d['gid'] = _setNbaGid($terms['gid']);
    }
    if (_countSearchParameters($d) >= 1) {
    	// Rewrite andOr to logicalOperator
        $d['logicalOperator'] = $d['andOr'] == 0 ? 'AND' : 'OR';
        $d['from'] = isset($d['from']) ? $d['from'] : 0;
        unset($d['andOr']);
        return $d;
    }
    // If only andOr flag is set, nothing has been entered;
    // return empty array
    return [];
}

/**
 * Calculates the number of search parameters excluding flags (andOr etc)
 *
 * @param array $d Search parameter
 * @return int Number of search items
 */
function _countSearchParameters ($d) {
    foreach ($d as $k => $v) {
        if (in_array($k, searchFlags())) {
            unset($d[$k]);
        }
    }
    return count($d);
}


/**
 * Performs curl requests and formats results
 *
 * Performs curl queries through multicurl. For each channel, resulting json is
 * parsed to an array by one function and subsequently printed by another.
 *
 * @param array $channels Service channels
 * @return string|void
 */
function performNdaRequest (array $channels = array()) {
	if (empty($channels)) {
		handleError('Cannot set curl channels');
	}
	// Get json response(s) with curl
	$remoteData = queryNda($channels);
	// Reorder responses in print order if more than one response
	if (count($remoteData) > 1) {
	   $remoteData = sortArrayByArray($remoteData, resultOrder());
	}
	// Map functions to each channel result:
	// parses and prints data
	$output = '';
	$serviceToFunctions = serviceToFunctions();
	foreach ($remoteData as $service => $json) {
		if (!isset($serviceToFunctions[$service]) || empty($json)) {
			continue;
		}
		$parseFunction = isset($serviceToFunctions[$service]['parse']) ?
		    $serviceToFunctions[$service]['parse'] : false;
		$printFunction = isset($serviceToFunctions[$service]['print']) ?
		    $serviceToFunctions[$service]['print'] : false;
		if (!empty($parseFunction) && !empty($printFunction)) {
		    $output .= $printFunction($parseFunction($json));
		}
	}

    // Debug: print queries
    if (DEBUG_CHANNELS == 1) {
        p($channels);
    }

	return $output;
}

/**
 * Performs multicurl queries
 *
 * Core function for multicurl requests
 *
 * @param unknown $channels Service channels
 * @param integer $timeout Optional timeout
 *
 * @return array Results as key => value pairs for each channel
 */
function queryNda ($channels = array(), $timeout = false) {
    $mh = curl_multi_init();
    for ($i = 0; $i < count($channels); $i++) {
        $ch[$i] = curl_init();

        if ($channels[$i]['method'] == 'post') {
            curl_setopt($ch[$i], CURLOPT_URL, $channels[$i]['url']);
            curl_setopt($ch[$i], CURLOPT_POST, true);
			curl_setopt($ch[$i], CURLOPT_HTTPHEADER, array('Expect:'));
            curl_setopt($ch[$i], CURLOPT_POSTFIELDS, $channels[$i]['postfields']);
        } else if ($channels[$i]['method'] == 'get') {
            $channels[$i]['url'] .= '/?'  . $channels[$i]['postfields'];
            curl_setopt($ch[$i], CURLOPT_URL, $channels[$i]['url']);
        }

        curl_setopt($ch[$i], CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch[$i], CURLOPT_HEADER, false);
        if ($timeout) {
       		curl_setopt($ch[$i], CURLOPT_TIMEOUT, $timeout);
        }
        curl_multi_add_handle($mh, $ch[$i]);
    }
    // While we're still active, execute curl
	do {
		$mrc = curl_multi_exec($mh, $active);
	} while ($mrc == CURLM_CALL_MULTI_PERFORM);

    while ($active && $mrc == CURLM_OK) {
        // Wait for activity on any curl-connection
        if (curl_multi_select($mh) == -1) {
            usleep(1);
        }
        // Continue to exec until curl is ready to
        // give us more data
        do {
            $mrc = curl_multi_exec($mh, $active);
        } while ($mrc == CURLM_CALL_MULTI_PERFORM);
    }
    // Place results in results array and close handlers
    for ($i = 0; $i < count($channels); $i++) {
        $remoteData[$channels[$i]['request']] = curl_multi_getcontent($ch[$i]);
        curl_multi_remove_handle($mh, $ch[$i]);
    }
    curl_multi_close($mh);
    return $remoteData;
}



/**
 * NSR id of a taxon
 *
 * @param array $data NBA json response
 * @return int|void ID of NRS taxon record
 */
function getTaxonId ($data) {
    foreach ($data->searchResults as $row) {
        if ($row->result->sourceSystem->code == 'NSR') {
            return $row->result->sourceSystemId;
        }
    }
    return null;
}


/**
 * Strips base url from string
 *
 * @param string $url
 * @return string $url Stripped url
 */
function stripBaseUrl ($url) {
    return str_replace(urlencode(nbaBaseUrl()), '', $url);
}


/**
 * Reverses setUnitId()
 *
 * @param string $string Unit id to "decode"
 * @return string $string
 */
function unsetUnitId ($string) {
    return str_replace('&nbsp;', ' ', $string);
}



/**
 * Gets sort direction
 *
 * Gets sort direction parameter from self link or, if self link is not provided,
 * returns default value
 *
 * @param string $self Self link
 * @param boolean $groupResult Service has grouped results?
 * @return string Result from self link or default value if self link is not provided
 */
function getSortDirection ($self, $groupResult = false) {
    $p = $groupResult ? '_groupSortDirection' : '_sortDirection';
    if (!empty($self)) {
        $value = getUrlParValue(urldecode($self), $p);
        if (!empty($value)) {
            return $value;
        }
    }
    return $groupResult ? defaultGroupSortDirection() : defaultSortDirection();
}

/**
 * Sets sort url
 *
 * @param string $column Field to sort on
 * @param string $dir Default sort direction for column
 * @param string $self Self link
 * @param boolean $groupResult Service has grouped results?
 * @return string Url
 */
function setSortUrl ($column, $dir, $self, $groupResult = false) {

    // Set parameters differently for default or grouped results
    $offset = $groupResult ? '_groupOffset' : '_offset';
    $sort = $groupResult ? '_groupSort' : '_sort';
    $sortDirection = $groupResult ? '_groupSortDirection' : '_sortDirection';

    // Column currently selected; only switch sort direction
    if ($column == getSort($self, $groupResult)) {
        return setUrlPars(
            geoShapeToSession($self, true),
            array(
                $sortDirection => getSortDirection($self, $groupResult) == 'DESC' ? 'ASC' : 'DESC',
                $offset => 0
            ),
            true
        );
    }
    // Other column is currently selected; set to current column in default direction
    return setUrlPars(
        geoShapeToSession($self, true),
        array(
            $sort => $column,
            $sortDirection => $dir,
            $offset => 0
        ),
        true
    );
}

/**
 * Paginator
 *
 * Returns html-formatted paginator based on json input. $groupResult is used to
 * differentiate between regular or grouped services.
 *
 * @param unknown $data Parsed json
 * @param boolean $groupResult Regular or grouped service?
 * @return Html-formatted paginator | void
 */
function getPaginator ($data) {
    if (isset($_SESSION['ndaRequestType']) && $_SESSION['ndaRequestType'] != 'form') {
        $paginator = new Paginator(
            getTotalRows($data),
            setPaginatorItemsPerPage($groupResult),
            setPaginatorCurrentPage($data, $groupResult),
            setPaginatorUrl($data, $groupResult)
        );
        return $paginator->toHtml();
    }
    return null;
}

/**
 * Special case: paginator used for results within grouped results
 *
 * A modified function for getPaginator for results within a grouped result. The problem
 * was that the $groupedResult flag in that function cannot be used, because getTotalRows
 * would need to differentiate to accept the results of a group or within a group
 * (for services that returned grouped results). Instead of introducing a potentialy
 * confusing third parameter, this special case function handles the paginator for results
 * within a grouped result.
 *
 * @param array $data Json
 * @return Formatted html|void
 */
function getPaginatorWithinGroup ($data) {
    if (isset($_SESSION['ndaRequestType']) && $_SESSION['ndaRequestType'] != 'form') {
        $paginator = new Paginator(
            getTotalRowsWithinGroup($data),
            setPaginatorItemsPerPage(),
            setPaginatorCurrentPage($data),
            setPaginatorUrl($data)
        );
        return $paginator->toHtml();
    }
    return null;
}

/**
 * Sets maximum number of results per page for paginator
 *
 * @param boolean $groupResult Regular or grouped service?
 * @return int Maximum number of results per page dependent of grouped or not
 */
function setPaginatorItemsPerPage ($groupResult = false) {
    return $groupResult ? maxGroupResults() : maxResults();
}

/**
 * Sets current page number for paginator
 *
 * @param boolean $groupResult Regular or grouped service?
 * @return int Current page number dependent of grouped or not
 */
function setPaginatorCurrentPage ($data, $groupResult = false) {
    return $groupResult ?
        getGroupOffset($data) / maxGroupResults() + 1 :
        getOffset($data) / maxResults() + 1;
}

/**
 *
 * Sets url for paginator
 *
 * Strips offset from self link and replaces this with placeholder for paginator
 *
 * @param array $data Json
 * @param boolean $groupResult
 * @return string Url
 */
function setPaginatorUrl ($data, $groupResult = false) {
    $offset = $groupResult ? 'groupOffset' : 'offset';
    return printDrupalLink(
        stripOffsetFromUrl(geoShapeToSession(urldecode(getSelfLink($data)))) . '&_' . $offset . '='
    ) . '(:num)';
}

/**
 * Adds or replaces parameters in url with new parameters
 *
 * @param string $url Input url
 * @param array $newValues New values as key => value pairs
 * @param boolean $decodeEncode Decode url before replacement?
 * @return string $url Output string
 */
function setUrlPars ($url, array $newValues, $decodeEncode = false) {
    if ($decodeEncode) {
        $url = urldecode($url);
    }
    $parts = parse_url($url);
    safe_parse_str($parts['query'], $q);
    foreach ($newValues as $p => $v) {
        $q[$p] = $v;
    }
    $parts['query'] = http_build_query($q);
    $url = reverse_parse_url($parts);
    return $decodeEncode ? urlencode($url) : $url;
}

/**
 *  Replaces the value of the _geoShape parameter from any NBA-created url with [session].
 *  Stores the value in a session parameter, which should be retrieved when creating the NBA request.
 *
 * @param string $url
 * @return string, session parameter
 */
function geoShapeToSession ($url, $decodeEncode = false) {
    if ($decodeEncode) {
        $url = urldecode($url);
    }
    $parts = parse_url($url);
    safe_parse_str($parts['query'], $q);
    if (isset($q['_geoShape'])) {
        $_SESSION['ndaStoredGeoShape'] = $q['_geoShape'];
        $q['_geoShape'] = '[session]';

        $parts['query'] = http_build_query($q);
        $url = reverse_parse_url($parts);
    }
    return $decodeEncode ? urlencode($url) : $url;
}

/**
 * Strips _offset and _groupOffset from url
 *
 * @param string $url Input url
 * @param string $decodeEncode Decode url before replacement?
 * @return string $url Output url
 */
function stripOffsetFromUrl ($url, $decodeEncode = false) {
    if ($decodeEncode) {
        $url = urldecode($url);
    }
    $parts = parse_url($url);
    safe_parse_str($parts['query'], $q);
    foreach (array('_offset', '_groupOffset') as $p) {
        if (isset($q[$p])) {
            unset($q[$p]);
        }
    }
    $parts['query'] = http_build_query($q);
    $url = reverse_parse_url($parts);
    return $decodeEncode ? urlencode($url) : $url;
}

/**
 * Gets value for specified parameter in url
 *
 * @param string $url Input utl
 * @param string $par Parameter to get value for
 * @return string|void Value
 */
function getUrlParValue ($url, $par) {
    if ($url != '' && $par != '') {
        $parts = parse_url($url);
        if (!empty($parts)) {
            safe_parse_str($parts['query'], $q);
            foreach ($q as $p => $v) {
                if ($p == $par) {
                    return $v;
                }
            }
        }
    }
    return false;
}

/**
 * Gets self link for current request
 *
 * Rather straightforward if the result is from a GET request. If the result is from
 * a POST request, the self link has to be reconstructed from the search terms in
 * the request.
 *
 * @param array $data Json
 * @return string|void Self link
 *
 */function getSelfLink ($data) {
    if (isset($data->links) && !empty($data->links)) {
        foreach ($data->links as $link) {
            if ($link->rel == '_self') {
                $self = $link->href;
                break;
            }
        }
    }
    if (!isset($self) || empty($self)) {
        return false;
    }
    // If data is returned from a POST request, we have to recompile the
    // self link from the search terms...
    $post = strpos(urldecode($self), '?') === false ? true : false;
    if ($post) {
        $p = '/?';
        foreach (getSearchTerms($data) as $k => $v) {
            $p .= $k . '=' . $v[0] . '&';
        }
        return $self . urlencode(substr($p, 0, -1));
    }
    return $self;
}

/**
 * Reassembles parsed url
 *
 * Function from php.net to reverse parse_url:
 * http://php.net/manual/en/function.parse-url.php#106731
 * Replacement for http_buil_url() because that function requires PECL.
 *
 * @param array $parsed_url Url components
 * @return string Reassembled url
 */
function reverse_parse_url ($parsed_url) {
    $scheme = isset($parsed_url['scheme']) ? $parsed_url['scheme'] . '://' : '';
    $host = isset($parsed_url['host']) ? $parsed_url['host'] : '';
    $port = isset($parsed_url['port']) ? ':' . $parsed_url['port'] : '';
    $user = isset($parsed_url['user']) ? $parsed_url['user'] : '';
    $pass = isset($parsed_url['pass']) ? ':' . $parsed_url['pass']  : '';
    $pass = ($user || $pass) ? "$pass@" : '';
    $path = isset($parsed_url['path']) ? $parsed_url['path'] : '';
    $query = isset($parsed_url['query']) ? '?' . $parsed_url['query'] : '';
    $fragment = isset($parsed_url['fragment']) ? '#' . $parsed_url['fragment'] : '';
    return "$scheme$user$pass$host$port$path$query$fragment";
}


/**
 * Validates json
 *
 * @param boolean Valid?
 */
function validJson ($string) {
	return is_object(json_decode($string));
}



/**
 * Creates properly formatted scientific name
 *
 * @param string $scientificname
 * @param object $nameObject Parsed json with individual name components
 * @param string $searchTerms Optional highlighting
 * @return string
 */
function formatScientificName ($scientificname, $nameObject, $searchTerms = false) {
	$output = $scientificname;
	$elements = getScientificNameElements($nameObject);
    $f = array(chr(4), chr(7));
	$r = array('<span class="scientific">', '</span>');

	foreach ($elements as $e) {
		if (!empty($e)) {
			$output = str_replace($e, chr(4) . $e . chr(7), $output);
		}
	}
	$output = str_replace($f, $r, $output);

	// Highlight the formatted output
	return $searchTerms ? highlightSearchTerms($output, $searchTerms) : $output;
}

/**
 * Highlight search terms
 *
 * @param string $string
 * @param array $searchTerms
 * @return string $string
 *
 */function highlightSearchTerms ($string, $searchTerms) {
    foreach ($searchTerms as $field => $value) {
        // Do not highlight search flags
         if (!in_array(str_replace('_', '', $field), searchFlags())) {
            $term = is_array($value) ? $value[0] : $value;
            // Split terms on space if necessary
            $t = explode(' ', $term);
            // Store as array keys to eliminate duplicates
            foreach ($t as $i => $v) {
                $terms[$v] = $field . $i;
            }
        }
    }
    if (isset($terms)) {
        $string = highlightMatch($string, array_flip($terms));
    }
    return $string;
}

/**
 * Extracts scientific name components from json name object
 *
 * Returns scientific name elements from name object. Stores as keys and
 * flips to avoid duplicates (as in Larus fuscus fuscus)
 *
 * @param object $name Name object from json
 * @return array
 */
function getScientificNameElements ($name) {
	$elements = array(
		$name->genusOrMonomial => 'genusOrMonomial',
		$name->subgenus => 'subgenus',
		$name->specificEpithet => 'specificEpithet',
		$name->infraspecificEpithet => 'infraspecificEpithet'
	);
	return array_flip($elements);
}

/**
 * Extracts scientific name components from json name object, but unlike
 * getScientificNameElements() does not filter out duplicates
 *
 * Returns scientific name elements from name object.
 *
 * @param object $name Name object from json
 * @return array
 */
function getScientificNameElementsWithDuplicates ($name) {
	return array(
		'genusOrMonomial' => $name->genusOrMonomial,
		'subgenus' => $name->subgenus,
		'specificEpithet' => $name->specificEpithet,
		'infraspecificEpithet' => $name->infraspecificEpithet
	);
}

/**
 * Checks if multimedia at specific url is mp4 file
 *
 * Visits url and checks headers. Movie files should be treated differently
 * from image files.
 *
 * @param string $url Url to multimedia file
 * @return boolean
 */
function _isMp4 ($url) {
	if ($url) {
	    $headers = get_headers($url);
	    foreach ($headers as $i => $v) {
	        if (strpos($v, 'mp4') !== false) {
	            return true;
	        }
	    }
	}
    return false;
}



/**
 * Decorates score in result table
 *
 * @param int $score Percentage from NBA response
 * @return string Formatted html
 */
function decorateScore ($score) {
    // Reset score so always one square is filled
    $score = $score < 20 ? 20 : $score;
	$roundScore = round( $score / 20 );
    $result = "<span class='score' title='$score %'>";

    for ($i = 1; $i <= 5; $i++){
        if ($i <= $roundScore){
            $result.= "<i class='icon-square_full'></i>";
        } else {
            $result.= "<i class='icon-square_empty'></i>";
        }
    }

    return $result .= "</span>";
}




/**
 * Wrapper for logging
 *
 * Currently log to watchdog and print error on screen. Can be adapted to
 * instantantly die() etc.
 *
 * @param string $message
 */
function handleError ($message) {
    //Log to the drupal error log
    watchdog("ndabioresults", $message, NULL, WATCHDOG_ERROR);
    //Log to the screen?
    drupal_set_message("Bioportal: " . $message);
}

/**
 * Translates NBA fields (usually ABCD/DC) to proper English
 *
 * Uses Drupal nba2text Taxonomy for translation
 *
 * @param string $str Input string
 * @return string Translated string
 */
function translateNdaField ($str) {
    $machine_name = "nba2text";
    $myvalue = taxonomy_get_term_by_name($str, $machine_name);
    if (is_array($myvalue)) {
        $myvalues = array_shift($myvalue);
        if(!empty($myvalues)) {
            return t($myvalues->description);
        }
    }
    return t($str);
}

/**
 * Recreates NBA request url for Drupal
 *
 * Enriches the NBA request url by appending the basic search parameters
 * to the base url and path to this module.
 *
 * @param string $url NBA search parameters
 * @return string Drupal url
 */
function printDrupalLink ($url) {
    return setBasePath() . 'nba/result?nba_request=' . urlencode($url);
}


/**
 * Translates decimal coordinate pair to DMS
 *
 * Adapted from
 * https://www.dougv.com/2012/03/converting-latitude-and-longitude-coordinates-between-decimal-and-degrees-minutes-seconds/
 *
 * Takes decimal coordinates and return degree, minute, second notation. Original function only
 * accepted single parameter; adapted to take both latitude and longitude immediately
 *
 * @param Decimal $lat Latitude
 * @param Decimal $lon Longitude
 * @return string Latitude, longitude
 */
function decimalToDMS ($lat, $lon) {
     $coordinates = array(
        'lat' => $lat,
        'lon' => $lon
     );
     foreach ($coordinates as $type => $decimal) {
        if (!is_numeric($decimal) || abs($decimal) > 180) {
            return false;
        }
        if ($type == 'lat' && $decimal < 0) {
              $direction = t('S');
        } else if ($type == 'lon' && $decimal < 0) {
          $direction = 'W';
        } else if ($type == 'lon') {
          $direction = t('E');
        } else {
          $direction = 'N';
        }
        $d = abs($decimal);
        $degrees = floor($d);
        $seconds = ($d - $degrees) * 3600;
        $minutes = floor($seconds / 60);
        $seconds = floor($seconds - ($minutes * 60));
        $output[$type] = $degrees . '&deg;' . $minutes . "'" . $seconds . '"' . $direction;
     }
     return isset($output) && count($output) == 2 ? implode(', ', $output) : false;
}

/**
 * Sets head and (optionally) page title
 *
 * @param string $head Head title
 * @param string $page Page title
 */
function setTitle ($head, $page = '') {
    $_SESSION['ndaPageTitle'] = $head;
    drupal_set_title($page);
}



/**
 * Determines if prettyPhoto library should be loaded
 *
 * Alternate function for parse_url that preserves periods and other special
 * characters in parameter names
 *
 * @param array $target Output
 * @param string $source Input
 * @return array
 */
function _loadPrettyPhoto ($imageUrl) {
    $maxWidth = $maxHeight = 600;
    $img = @getimagesize($imageUrl);
    if ($img && $img[0] > $maxWidth || $img[1] > $maxHeight) {
        $path = drupal_get_path('module', 'ndabioresults');
        drupal_add_css($path . "/css/prettyPhoto.css");
        drupal_add_js($path . "/js/jquery.prettyPhoto.js");
        drupal_add_js(
            'jQuery(document).ready(function($){
                $("a[rel^=\'prettyPhoto\']").prettyPhoto({
                    social_tools: false
                });
            });',
            array('type' => 'inline', 'scope' => 'footer'));
    }
    if (!$img) {
        return array(0, 0);
    }
    if ($img[0] < $maxWidth && $img[1] < $maxHeight) {
        return array($img[0], $img[1]);
    }
    if ($img[0] > $maxWidth && $img[0] >= $img[1]) {
        return array($maxWidth, round($img[1] * $maxWidth / $img[0]));
    }
    if ($img[1] > $maxHeight && $img[1] >= $img[0]) {
        return array(round($img[0] * $maxHeight / $img[1]), $maxHeight);
    }
}


/**
 * Determines if service is a search service (contrary to detail service)
 *
 * @param unknown $r Request
 * @return boolean true/false
 */
function isSearchService ($r) {
    foreach (searchServices() as $service) {
        if (strpos($r, $service) !== false) {
            return true;
        }
    }
    return false;
}

/**
 * Sets navigation SESSION for previous/next links in multimedia
 *
 * Returns the searchId, which can be usedfor background updating of
 * the navigation SESSION.
 *
 * @param array $data Parsed json
 * @return string $searchId
*/
function setNavigation ($data) {
    $terms = getSearchTerms($data);
    $searchId = setSearchId($terms);

    // Search has already been stored previously
    if (isset($_SESSION['ndaNavigation'][$searchId])) {
        return $searchId;
    }

    $_SESSION['ndaNavigation'][$searchId]['offset'] =
        array_key_exists('_offset', $terms) ? $terms['_offset'][0] : 0;
    $_SESSION['ndaNavigation'][$searchId]['total'] = $data->totalSize;
    // Previous/next set links
    $navigation = getNavigationPreviousNextSets($data, multimediaService());
    $_SESSION['ndaNavigation'][$searchId]['nextSet'] = $navigation['next'];
    $_SESSION['ndaNavigation'][$searchId]['previousSet'] = $navigation['previous'];
    // Links within results
    $_SESSION['ndaNavigation'][$searchId]['currentSet'] = array();
    foreach ($data->searchResults as $row) {
        $_SESSION['ndaNavigation'][$searchId]['currentSet'][] =
            stripNBABASEURL(getMultimediaDetailLink($row)) . '&searchID=' . $searchId;
    }

    return $searchId;
}

/**
 * Sets the urls for the previous/next result sets
 *
 * This should be pretty straightforward, as the NBA returns these links in the
 * response. However, this is not the case for POST requests! These have to
 * created from the search terms.
 *
 * @param array $data Parsed json data
 * @param string $service Service, required to determine GET/POST request
 * @return array $d Array with next and previous links
 */
function getNavigationPreviousNextSets ($data, $service) {
    // POST or GET service?
    $config = serviceToFunctions();
    foreach ($data->links as $i => $link) {
        $links[$link->rel] = $link->href;
    }
    // For GET determining the sets is easy
    if (strtolower($config[$service]['method']) == 'get') {
        $d['next'] = $links['_self'] != $links['_nextPage'] ?
            $links['_nextPage'] : false;
        $d['previous'] = $links['_self'] != $links['_prevPage'] ?
            $links['_prevPage'] : false;
    // For POST we need to parse the queryParameters
    } else {
        $d['next'] = setNavigationSetLink($data, 'next');
        $d['previous'] = setNavigationSetLink($data, 'previous');
    }
    return $d;
}

/**
 * Creates links for previous next result sets for POST request
 *
 * If GET request is used, the NBA returns correct links for previous and next
 * results sets. For POST however, these have to be reconstructed using the
 * queryParameters.
 *
 * @param array $data Parsed json data
 * @param string $direction previous/next
 * @return boolean|string
 */
function setNavigationSetLink ($data, $direction) {
    foreach ($data->links as $i => $link) {
        $links[$link->rel] = $link->href;
    }
    $terms = getSearchTerms($data);
    // Append _offset if this has not been set yet
    if (!array_key_exists('_offset', $terms)) {
        $terms['_offset'] = array(0, $data->totalSize - 1);
    }
    $p = '';
    foreach ($terms as $k => $v) {
        if ($k == '_offset') {
            if ($direction == 'previous' && ($v[0] - $terms['_maxResults'][0] >= 0)) {
                $p .= $k . '=' . ($v[0] - $terms['_maxResults'][0])  . '&';
            } else if ($direction == 'next' &&
                ($v[0] + $terms['_maxResults'][0] < $data->totalSize - 1)) {
                 $p .= $k . '=' . ($v[0] + $terms['_maxResults'][0])  . '&';
            } else {
                return false;
            }
        } else {
            $p .= $k . '=' . $v[0] . '&';
        }
    }
    return $links['_self'] . urlencode('?' . substr($p, 0, -1));
}


/**
 * Background reset of the navigation SESSION
 *
 * Called when the user arrives at the first or last item in the navigation set.
 * The next/previous NBA request is called in the background and the SESSION is
 * reset. In this special case, the SESSION should not be reset again when the
 * new page loads. This is handled by setting reset = 0.
 *
 * @param string $r NBA request
 * @return string Updated $searchId

 function updatePreviousNext ($r) {
    $json = file_get_contents(setBasePath() . 'nba/ajax?nba_request=' . $r);
    if (!empty($json)) {
        // Set new SESSION and return new searchId
        return setNavigation(json_decode($json));
    }
}
*/

/**
 *  Sets unique id for search terms
 *
 *  Creates a hash based on the search terms. Used for navigation purpose.
 *
 * @param array $terms Search terms
 */
function setSearchId ($terms) {
    ksort($terms);
    return md5(serialize($terms));
}

/**
 *  Get search id from NBA request
 *
 * @param string $r NBA request
 * @return string|false
 */
function getSearchId ($r) {
    safe_parse_str(urldecode($r), $q);
    return isset($q['searchID']) ? $q['searchID'] : false;
}

function stripNBABASEURL ($url) {
    $url = str_replace(nbaBaseUrl(), '', urldecode($url));
    if ($url[0] == '/') {
        $url = substr($url, 1);
    }
    return $url;
}

function setAnchor ($a) {
    return str_replace('/', '_', $a);
}


/**
 * Translates NBA fields (usually ABCD/DC) to proper English
 *
 * Uses Drupal nba2text Taxonomy for translation
 *
 * @param string $str Input string
 * @return string Translated string
 */
function _translateNdaField ($str) {
    $machine_name = "nba2text";
    $myvalue = taxonomy_get_term_by_name($str, $machine_name);
    if (is_array($myvalue)) {
        $myvalues = array_shift($myvalue);
        if(!empty($myvalues)) {
            return t($myvalues->description);
        }
    }
    return t($str);
}


