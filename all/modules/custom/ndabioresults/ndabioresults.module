<?php
// Config
require_once 'ndabioresults.config.inc';
require_once 'ndabioresults.block.inc';

// Libraries
require_once 'common.inc';
require_once 'ndabioresults.parse.inc';
require_once 'ndabioresults.print.inc';
require_once 'Paginator.php';

// Old code
//require_once 'redundant.inc';


// Namespaces not defined in common.inc
use nl\naturalis\bioportal\QuerySpec as QuerySpec;
use nl\naturalis\bioportal\GroupByScientificNameQuerySpec as GroupByScientificNameQuerySpec;
use nl\naturalis\bioportal\Condition as Condition;
use nl\naturalis\bioportal\Filter as Filter;

/**
 * Things to do when loading the module
 */
function ndabioresults_init () {
	//_checkIfNbaIsUp();
	// Clear previously stored debug info
	unset($_SESSION['nbaDebug'], $_SESSION['nbaErrorMessage']);
	$_SESSION['nbaDebug']['server'] = _nbaBaseUrl();
	$_SESSION['nbaNameResolutionTaxa'] = null;
}

/**
 * Add an extra class to the body to trigger CSS styles
 */
function ndabioresults_preprocess_html (&$vars) {
	$pathComponents = explode('/', current_path());
    if (in_array($pathComponents[0], ['multimedia', 'specimen', 'taxon'])) {
	    $vars['classes_array'][] = 'nba-result-detail';
    }
    if (isset($_SESSION['nbaPageTitle']) && current_path() != '') {
 	    if (in_array($pathComponents[0], ['result', 'multimedia', 'specimen', 'taxon'])) {
        	$vars['head_title'] = $_SESSION['nbaPageTitle'] . ' | BioPortal';
		    $vars['classes_array'][] = 'page-nba-result';
	    }
	}
}

/**
 * Implements hook_menu().
 */
function ndabioresults_menu () {
	$items['admin/config/naturalis/ndaresult'] = array(
	    'title' => 'NBA Results config',
	    'description' => 'Configuration for Naturalis module',
	    'page callback' => 'drupal_get_form',
	    'page arguments' => array('ndabioresults_config_form'),
	    'access arguments' => array('administration site configuration'),
	    'type' => MENU_NORMAL_ITEM,
	);
	$items['result'] = array(
	    'page callback' => '_nba_general_result_callback',
	    'load arguments' => array('%map', '%index'),
	    'access callback' => true,
	);
	$items['result/multimedia'] = array(
	    'page callback' => '_nba_multimedia_result_callback',
	    'load arguments' => array('%map', '%index'),
	    'access callback' => true,
	);
	$items['result/taxon'] = array(
	    'page callback' => '_nba_taxon_result_callback',
	    'load arguments' => array('%map', '%index'),
	    'access callback' => true,
	);
	$items['result/specimen'] = array(
	    'page callback' => '_nba_specimen_result_callback',
	    'load arguments' => array('%map', '%index'),
	    'access callback' => true,
	);
	$items['result/specimen/taxon'] = array(
	    'page callback' => '_nba_specimen_taxon_result_callback',
	    'load arguments' => array('%map', '%index'),
	    'access callback' => true,
	);
	$items['result/specimen/map'] = array(
	    'page callback' => '_nba_specimen_map_result_callback',
	    'load arguments' => array('%map', '%index'),
	    'access callback' => true,
	);
	$items['taxon'] = array(
	    'page callback' => '_nba_taxon_callback',
	    'access callback' => true,
	);
	$items['specimen'] = array(
	    'page callback' => '_nba_specimen_callback',
	    'access callback' => true,
	);
	$items['multimedia'] = array(
		'page callback' => '_nba_multimedia_callback',
		'access callback' => true,
	);
	$items['ajax'] = array(
		'page callback' => 'ndabioresults_ajax_callback',
		'access arguments' => array('access content'),
		'type' => MENU_CALLBACK 
	);
    /*
	$items['nba/'] = array(
		'page callback' => '_nba_redirect_old_links',
		'load arguments' => array('%map', '%index'),
		'access callback' => true,
	);
    */
	return $items;
}


/**
 * Simple method to query api through Ajax
 *
 * Requires two GET parameters: source and term; key is optional
 */
function ndabioresults_ajax_callback () {
    //drupal_add_http_header('Content-Type', 'application/json');
    if (empty($_GET['term']) || empty($_GET['source'])) {
        die(json_encode('Both "source" and "term" should be passed as get parameters!'));
    }
    if ($_GET['source'] == 'bhl') {
        die(_getBhlReferences(5));
    }
    if ($_GET['source'] == 'wc') {
        die(_getWorldCatReferences(5));
    }
    die(json_encode('Invalid request or request timed out'));
}

function _getWorldCatReferences ($max = 10) {
    $result = _queryApi(
        'http://www.worldcat.org/webservices/catalog/search/worldcat/opensearch?q=' . $_GET['term'] .
            '&wskey=[k]&cformat=chicago',
       'p8KSpphVF5QV3RDa0oinF4K6y4R7TvSXM7DYBjPde0IvOviDbC0DM4W6zUax407GzWYhe8kKlYOnlWrm',
        30
    );

    $output['references'] = [];
    if (_isValidXml($result)) {
        $data = simplexml_load_string($result);
        $nr = count($data->entry);
        if ($nr > $max) {
            $nr = $max;
        }

        for ($i = 0; $i < $nr; $i++) {
            $output['references'][$i]['title'] = strip_tags((string)$data->entry[$i]->content);
            $output['references'][$i]['url'] = (string)$data->entry[$i]->link['href'];
        }

        $output['count'] = $nr;
        $output['source_url'] = $nr > 0 ? 'https://www.worldcat.org/search?qt=worldcat_org_all&q=' .
            $_GET['term'] : null;
    }
    return json_encode($output);
}


function _getBhlReferences ($max = 10) {
    $result = _queryApi(
        'https://www.biodiversitylibrary.org/api3?op=PublicationSearch&format=json&searchType=C&searchterm="' .
        urlencode($_GET['term']) . '"&apikey=[k]',
        '92209bfc-0702-4d1d-a086-ff85bfd88e1e',
        30
    );
    $output['references'] = [];
    if (_isValidJson($result)) {
        $data = json_decode($result, true);

        if ($data['Status'] == 'ok' && !empty($data['Result'])) {
            foreach ($data['Result'] as $i => $r) {
                if ($i >= $max) {
                    break;
                }
                $output['references'][$i]['title'] = _compileReference([
                    'authors' => array_column($r['Authors'],'Name'),
                    'title' => isset($r['Title']) ? $r['Title'] : null,
                    'year' => isset($r['Date']) ? $r['Date'] : null,
                    'journal' => isset($r['ContainerTitle']) ? $r['ContainerTitle'] : null,
                    'volume' => isset($r['Volume']) ? $r['Volume'] : null,
                    'pages' => isset($r['PageRange']) ? $r['PageRange'] : null,
                    'issue' => isset($r['Issue']) ? $r['Issue'] : null,
                    'publisher' => [
                        'name' => isset($r['PublisherName']) ? $r['PublisherName'] : null,
                        'place' => isset($r['PublisherPlace']) ? $r['PublisherPlace'] : null,
                        'year' => isset($r['PublisherDate']) ? $r['PublisherDate'] : null
                    ]
                ]);
                $output['references'][$i]['url'] =
                    !empty($r['PartUrl']) ? $r['PartUrl'] : $r['TitleUrl'];
            }
        }
        $output['count'] = isset($i) ? $i + 1 : 0;
        $output['source_url'] = isset($i) ? 'https://www.biodiversitylibrary.org/search?searchTerm=' .
            urlencode($_GET['term']) . '&stype=F' : null;

        return json_encode($output);
    }
}

/**
 * @param $parts Individuals parts used to compile a reference
 * @return string
 */
function _compileReference ($parts)
{
    foreach ($parts as $k => $v) {
        if (!is_array($v)) {
            $$k = trim($v, ' .,/');
        }
    }
    if (!empty($pages)) {
        $tmp = explode('--', $pages);
        $pages = $tmp[0] == $tmp[1] ? $tmp[0] : $tmp[0] . '-' . $tmp[1];
    }
    $authors = array_map(function($value) {
        return trim($value, ' .,/');
    }, $authors);
    $authors = array_pop($parts['authors']);
    if ($parts['authors']) {
        $authors = implode(', ', $parts['authors']) . ' & ' . $authors;
    }
    $publisher = implode(' ', $parts['publisher']);
    $output =
        (!empty($authors) ? $authors . '. ' : '') .
        (!empty($year) ? $year . '. ' : '') .
        (!empty($title) ? $title . '. ' : '') .
        (!empty($journal) ? $journal . ', ' : '') .
        (!empty($volume) ? $volume : '') .
        (!empty($issue) ? '(' . $issue . ')' : '') .
        (!empty($pages) ? ': ' . $pages . '.' : '') .
        (!empty(trim($publisher)) ? ': ' . trim($publisher) . '.' : '');
    return $output;

}


/**
 * Very basic curl request to retrieve data from external apis.
 * Pass url as http://domain?query=[q](&key=[k])
 *
 * @param string $url
 * @param string $query // Will be encoded here!
 * @param string $key
 * @param int $timeout
 * @return bool|string
 */
function _queryApi ($url, $key = false, $timeout = 10) {
    if ($key) {
        $url = str_replace('[k]', $key, $url);
    }
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);
    $data = curl_exec($ch);
    curl_close($ch);
    return $data;

}


/*
 * Aanpassen: geen souceSystemID maar id!!
 */

function _nba_specimen_callback ($id = false, $scientificNameGroup = false, $search = false) {
	// Test if anything has been posted; if not return with error message
	if (!$id) {
		_setErrorMessage('Specimen ID missing');
		return _printOops();
	}
	$service = _getSpecimenService();
	$data = _getSpecimenByUnitId($id);
	if (!$data) {
		_setErrorMessage($data->exception);
		return _printOops();
	}
	
//p($data);
	
	$client = _setNbaClient($service, true);
	if (!$client) {
		return _printOops();
	}
	
	if (!$scientificNameGroup && !$search) {
		_setDetailPageNoSearchBackLink();
		$data = _addDetailPageNavigation($service, $data);
		if (isset($_GET['referrer'])) {
			$data->referrer = $_GET['referrer'];
		}
	}	
	
	// Added non-aggregated specimen browse option;
	// parameter names now are incorrect...
	else if ($scientificNameGroup && !$search) {
		$search = $scientificNameGroup;
		$terms = _getQueryTerms('specimen', $search);

		$data->referrer = _encodeReferrer($terms);		
		$terms['size'] = 3;		
		
		try {

			$query = _buildNbaQuery('specimen', $terms);
			_addDebugMessage('previous, current and next item', $query);
			
			$timer = _setTimer();
			$set = json_decode($client->setQuerySpec($query)->query());
			_addDebugMessage('navigation query', _getTimer($timer));
			_setGenericDetailPageBackLink('specimen', $search);
			
			// Only show navigation if this is available
			if ($set->totalSize > 0) {
				// Extract data for current id, plus ids of previous and next result
				$data = _addDetailPageNavigation(
					$service, 
					$data, 
					$search, 
					$set, 
					$id, 
					$terms['from']
				);
			}
			
		} catch (Exception $e) {
			_setErrorMessage($e);
		}
		
		$error = _checkInvalidNbaRequest(isset($set) ? $set : false);
	}
	
	else if ($scientificNameGroup && $search) {
		$terms = _getQueryTerms('names.specimens', $search);
		$data->referrer = _encodeReferrer($terms);		
		$specimensFrom = isset($terms['from']) ? $terms['from'] : 0;
    	
    	unset($terms['size'], $terms['from']);
    	
    	try {
    	
	    	$filter = new Filter();
	    	$filter->acceptValues([$scientificNameGroup]);
	 
	    	$query = _buildNbaQuery('names.specimens', $terms);
			$query
				->setSpecimensFrom($specimensFrom)
				->setSpecimensSize(3)
				->setGroupFilter($filter);
			
			_addDebugMessage('previous, current and next item', $query);
			
			$timer = _setTimer();
			$set = json_decode($client->setQuerySpec($query)->groupByScientificName());
			_addDebugMessage('navigation query', _getTimer($timer));
    		_setGenericDetailPageBackLink('specimen', $search);
		
			// Set back link -- from taxon detail
			if (_getReferredSearch($search)) {
				_setBackLink(
					'taxon/' .  ucfirst(str_replace(' ', '_', $scientificNameGroup)) . 
						'/' . _getReferredSearch($search),
					'Back to taxon'
				);
			}
	
			// Only show navigation if this is available
			if ($set->totalSize > 0) {
				// Extract data for current id, plus ids of previous and next result
				$data = _addSpecimenDetailPageNavigation(
					$data,
					$search, 
					$set, 
					$id, 
					$specimensFrom, 
					$scientificNameGroup
				);
			}
			
    	} catch (Exception $e) {
			_setErrorMessage($e);
		}
		
		$error = _checkInvalidNbaRequest(isset($set) ? $set : false);
	}

	if ($error) {
		return $error;
	}
	
	// Get map when geo search has been used
	$data->geoJson = null;
	if (!empty($terms['gid']) || !empty($terms['geoShape'])) {
		$data->geoJson = _getStoredGeoShape();
	}
	
	$data->multimedia = _getSpecimenMultimedia($data);

	return _printSpecimenDetail(_parseSpecimenDetail($data));
}



function _addSpecimenDetailPageNavigation ($data, $search = false, $set = false, 
	$id = false, $from = false, $scientificNameGroup = false) {
	
	if ($set && $search && $scientificNameGroup) {
		$previousId = $nextId = null;
		foreach ($set->resultSet[0]->item->specimens as $i => $row) {
			if (isset($row->unitID) && $row->unitID == $id) {
				//$output = $row;
				break;
			}
		}
		$offset = $from + 2;
		if (isset($set->resultSet[0]->item->specimens[($i - 1)]->unitID)) {
			$previousId = $set->resultSet[0]->item->specimens[($i - 1)]->unitID;
		} else {
			$offset = 1;
		}
		if (isset($set->resultSet[0]->item->specimens[($i + 1)]->unitID)) {
			$nextId = $set->resultSet[0]->item->specimens[($i + 1)]->unitID;
		}
		$previousUrl = _setSpecimenDetailPagePreviousLink(
			$search, 
			$previousId, 
			$scientificNameGroup
		);
		$nextUrl = _setSpecimenDetailPageNextLink(
			$search,
			$nextId, 
			$previousId, 
			$scientificNameGroup
		);
	} 
	$data->offset = isset($offset) ? $offset : 1;
	$data->previousUrl = isset($previousUrl) ? $previousUrl : null;
	$data->nextUrl = isset($nextUrl) ? $nextUrl : null;
	$data->backUrl = _getBackLink();
	$data->scientificNameGroup = $scientificNameGroup;
	$data->totalSize = $set ? $set->resultSet[0]->item->specimenCount : 1;
	return $data;
}

function _setSpecimenDetailPagePreviousLink ($search, $previousId, $scientificNameGroup) {
	if (isset($previousId)) {
		safe_parse_str($search, $terms);
		// Strip size if it was provided; we don't need it
		if (isset($terms['size'])) {
			unset($terms['size']);
		}
		// Only proceed if size has been set; otherwise url has been tampered with
		// We have already validated that $p['from'] is an integer
		if (isset($terms['from'])) {
			$terms['from'] = $terms['from'] == 0 ? $terms['from'] : $terms['from'] - 1;
			return _setBasePath() . 'specimen/' . urlencode($previousId) . '/' . 
				urlencode($scientificNameGroup) . '/' . safe_http_build_query($terms);
		}
	}
	return null;
}

function _setSpecimenDetailPageNextLink ($search, $nextId, $previousId, $scientificNameGroup) {
	if (isset($nextId)) {
		safe_parse_str($search, $terms);
		// Strip size if it was provided; we don't need it
		if (isset($terms['size'])) {
			unset($terms['size']);
		}
		// Only proceed if size has been set; otherwise url has been tampered with
		// We have already validated that $p['from'] is an integer
		if (isset($terms['from'])) {
			$terms['from'] = !isset($previousId) ? $terms['from'] : $terms['from'] + 1;
			return _setBasePath() . 'specimen/' . urlencode($nextId) . '/' . 
				urlencode($scientificNameGroup) . '/' . safe_http_build_query($terms);
		}
	}
	return null;
}

function _getSpecimenByUnitId ($unitId = false) {
	if (!$unitId) {
		return false;
	}
	try {
		$client = _initNbaClient();
		$query = new QuerySpec();	
		$query
			->addCondition(new Condition('unitID', 'EQUALS', $unitId))
			->setConstantScore()
			->setSize(1);
		_addDebugMessage('specimen detail', $query);
		$data = json_decode($client->specimen()->setQuerySpec($query)->query());
		if (isset($data->exception)) {
			_setErrorMessage($data->exception);
			return false;
		}
	} catch (Exception $e) {
		_setErrorMessage($e);
	}
	return isset($data->resultSet[0]->item) ? $data->resultSet[0]->item : false;	
}

function _nba_multimedia_callback ($id = false, $search = false) {
	// Test if anything has been posted; if not return with error message
	if (!$id) {
		_setErrorMessage('Multimedia ID missing');
		return _printOops();
	}
	
	$service = 'multimedia';
	$client = _setNbaClient($service, true);
	if (!$client) {
		return _printOops();
	}
	
	try {
		$condition = new Condition('unitID', 'EQUALS', $id);
		$query = new QuerySpec();
		$query->addCondition($condition);
		
		_addDebugMessage($service, $query);
		
		$timer = _setTimer();
		
		$data = json_decode($client->setQuerySpec($query)->query());
	} catch (Exception $e) {
		_setErrorMessage($e);
	}
	
	_addDebugMessage('multimedia query', _getTimer($timer));
	
	// Check NBA response; break if invalid
	$error = _checkInvalidNbaRequest(isset($data) ? $data : false, true);
	if ($error) {
		return $error;
	}
	
	$data = $data->resultSet[0]->item;
	$data = _setMultimediaAssociatedObject($data);
	
	if ($search) {
		// Generic back link (will be overridden for referred search)
		_setGenericDetailPageBackLink($service, $search);
		
		$terms = _getQueryTerms($service, $search);		
		$data->referrer = _encodeReferrer($terms);		
		$terms['size'] = 3;		

		try {
			$query = _buildNbaQuery($service, $terms);
			_addDebugMessage('previous, current and next item', $query);
			
			$timer = _setTimer();
			$set = json_decode($client->setQuerySpec($query)->query());
			_addDebugMessage('navigation query', _getTimer($timer));
		} catch (Exception $e) {
			_setErrorMessage($e);
		}
		
		// Check NBA response; break if invalid
		$error = _checkInvalidNbaRequest(isset($set) ? $set : false);
		if ($error) {
			return $error;
		}
		
		// Referred search; replace generic back link!
		if (isset($data->associatedTaxon) && _getReferredSearch($search)) {
			_setBackLink(
				'taxon/' .  urlencode(_setTaxonId($data->associatedTaxon->acceptedName)) . 
				'/' . _getReferredSearch($search),
				'Back to taxon'
			);
		} else if (isset($data->associatedSpecimen) && _getReferredSearch($search)) {
			$backLink = 'specimen/' .  urlencode($data->associatedSpecimen->unitID) . '/';
			if (_getSpecimenService() != 'specimen') {
				$backLink .= urlencode($data->associatedSpecimen->identifications[0]->scientificName->scientificNameGroup) . '/';
			}
			$backLink .= _getReferredSearch($search);
			_setBackLink($backLink, 'Back to specimen');
		}
		// Extract data for current id, plus ids of previous and next result
		if ($set->totalSize > 0) {
			$data = _addDetailPageNavigation($service, $data, $search, $set, $id, $terms['from']);
		}
	}	
	
	else {
		_setDetailPageNoSearchBackLink();
		$data = _addDetailPageNavigation($service, $data);
	}
	
	if (isset($data->associatedTaxon)) {
		return _printTaxonMediaDetail(_parseTaxonMediaDetail($data));
	}
	return _printSpecimenMediaDetail(_parseSpecimenMediaDetail($data));
}

function _setDetailPageNoSearchBackLink () {
	if (isset($_SERVER["HTTP_REFERER"]) && 
		strpos($_SERVER["HTTP_REFERER"], _setStartUrl()) !== false) {
		return $_SESSION['nbaBackLink'] = [
			'href' => $_SERVER["HTTP_REFERER"],
			'label' => t('Back'),
		];		
	}
	return _setBackLink('', 'Home');	
}

function _setBackLink ($href, $label) {
	$_SESSION['nbaBackLink'] = [
		'href' => _setStartUrl() . $href,
		'label' => t($label),
	];
}

function _setGenericDetailPageBackLink ($service, $search) {
	// Need to reset search to correct from value
	safe_parse_str($search, $terms);
	if ($service && $terms) {
		$terms['from'] = floor(($terms['from'] + 1) * 0.01) * 100;
		// Cannot use _setBackLink here!
		$_SESSION['nbaBackLink'] = [
			'href' => _setBasePath() . 'result/' . $service . '/' . 
				safe_http_build_query($terms),
			'label' => t('Back to search results'),
		];
	} else {
		_setBackLink('', 'Home');
	}
}

function _setGenericResultPageBackLink () {
	if (isset($_SESSION['nbaSearch']) && !empty($_SESSION['nbaSearch'])) {
		_setBackLink(
			'result?' . safe_http_build_query($_SESSION['nbaSearch']),
			t('Back to general results')
		);
	} else {
		_setBackLink('', 'Home');	
	}
}

function _getBackLink () {
	if (isset($_SESSION['nbaBackLink'])) {
		return $_SESSION['nbaBackLink']['href'];
	}
	return false;
}

function _getBackLinkFormatted () {
	if (isset($_SESSION['nbaBackLink'])) {
		return '<a href="' . $_SESSION['nbaBackLink']['href'] . '"' .
			'><i class="icon-arrow-left"></i>' . $_SESSION['nbaBackLink']['label'] . '</a>';
	}
	return '&nbsp;';
}

function _setMultimediaAssociatedObject ($data) {
	$client = _initNbaClient();
	foreach (['taxon', 'specimen'] as $service) {
		$field = 'associated' . ucfirst($service) . 'Reference';
		if (isset($data->{$field}) && !empty($data->{$field})) {
			$appendedField = 'associated' . ucfirst($service);
			$timer = _setTimer();
			$data->{$appendedField} = 
				json_decode($client->{$service}()->find($data->{$field}));
			_addDebugMessage('Associated ' . $service, $client->getNbaQueryUrl());
			_addDebugMessage('Associated ' . $service . ' query', _getTimer($timer));
			unset($client, $query, $condition);
			return $data;
		}
	}
}


function _setDetailPagePreviousLink ($service, $search, $previousId) {
	if (isset($previousId)) {
		safe_parse_str($search, $terms);
		// Strip size if it was provided; we don't need it
		if (isset($terms['size'])) {
			unset($terms['size']);
		}
		// Only proceed if size has been set; otherwise url has been tampered with
		// We have already validated that $p['from'] is an integer
		if (isset($terms['from'])) {
			$terms['from'] = $terms['from'] == 0 ? $terms['from'] : $terms['from'] - 1;
			return _setBasePath() . $service . '/' . urlencode($previousId) . '/' . 
				safe_http_build_query($terms);
		}
	}
	return null;
}

function _setDetailPageNextLink ($service, $search, $nextId, $previousId) {
	if (isset($nextId)) {
		safe_parse_str($search, $terms);
		// Strip size if it was provided; we don't need it
		if (isset($terms['size'])) {
			unset($terms['size']);
		}
		// Only proceed if size has been set; otherwise url has been tampered with
		// We have already validated that $p['from'] is an integer
		if (isset($terms['from'])) {
			$terms['from'] = !isset($previousId) ? $terms['from'] : $terms['from'] + 1;
			return _setBasePath() . $service . '/' . urlencode($nextId) . '/' . 
				safe_http_build_query($terms);
		}
	}
	return null;
}

function _setDetailPageBackLink ($service, $search) {
	// Need to reset search to correct from value
	safe_parse_str($search, $terms);
	$terms['from'] = floor(($terms['from'] + 1) * 0.01) * 100;
	return _setBasePath() . 'result/' . $service . '/' . safe_http_build_query($terms);
}


function _addDetailPageNavigation ($service, $data, $search = false, $set = false, 
		$id = false, $from = false) {
	if ($set) {
		$previousId = $nextId = null;
		foreach ($set->resultSet as $i => $row) {
			if (isset($row->item->unitID) && $row->item->unitID == $id) {
				//$output = $row->item;
				break;
			}
		}
		$offset = $from + 2;
		if (isset($set->resultSet[($i - 1)]->item->unitID)) {
			$previousId = $set->resultSet[($i - 1)]->item->unitID;
		} else {
			$offset = 1;
		}
		if (isset($set->resultSet[($i + 1)]->item->unitID)) {
			$nextId = $set->resultSet[($i + 1)]->item->unitID;
		}
		$previousUrl = _setDetailPagePreviousLink($service, $search, $previousId);
		$nextUrl = _setDetailPageNextLink($service, $search, $nextId, $previousId);
	}
	$data->offset = isset($offset) ? $offset : 1;
	$data->previousUrl = isset($previousUrl) ? $previousUrl : null;
	$data->nextUrl = isset($nextUrl) ? $nextUrl : null;
	$data->backUrl = _getBackLink();
	$data->totalSize = isset($set->totalSize) ? $set->totalSize : 1;
	return $data;
}



function _nba_taxon_callback ($taxon = false, $search = false) {

    if (!$taxon) {
    	_setErrorMessage('Taxon missing');
    	_printOops();
    }
    
    $service = 'names.taxa';
    
    $data = _getTaxonByName($taxon);
	if (!$data) {
		return _printOops();
	}
	
    $client = _setNbaClient($service, true);
	if (!$client) {
		return _printOops();
	}
    
    if ($search) {
		$terms = _getQueryTerms($service, $search);		
		$data->referrer = _encodeReferrer($terms);		
		$terms['size'] = 3;		
		
		try {

			$query = _buildNbaQuery($service, $terms);
			$query->setSpecimensSize(0);
			_addDebugMessage('previous, current and next item', $query);
			
			$timer = _setTimer();
			$set = json_decode($client->setQuerySpec($query)->groupByScientificName());
			_addDebugMessage('navigation query', _getTimer($timer));
					
			// Generic back link (will be overridden for referred search)
			_setGenericDetailPageBackLink('taxon', $search);
			
			if ($set->totalSize > 0) {
				// Extract data for current id, plus ids of previous and next result
				$data = _addTaxonDetailPageNavigation(
					$data, 
					$search, 
					$set, 
					$data->name, 
					$terms['from']
				);
			}
			
		} catch (Exception $e) {
			_setErrorMessage($e);
		}
		
		$error = _checkInvalidNbaRequest(isset($set) ? $set : false);
		if ($error) {
			return $error;
		}
		
    } else {
		_setDetailPageNoSearchBackLink();
		$data = _addDetailPageNavigation($service, $data);
	}
     
	// Get specimens
	$data->specimens = _getTaxonSpecimens($data);
	$data->multimedia = _getTaxonMultimedia($data);
  	return _printTaxonDetail(_parseTaxonDetail($data));
     
//die(p($data));
    
}

function _createTaxonSubsectionLink ($object, $resultPath) {
	$output = _setBasePath() . $resultPath;
	foreach (_scientificNameElementsInItalics() as $field) {
		$value = isset($object->{$field}) ? urlencode($object->{$field}) : null;
		$output .= $field . '=' . $value . '&' . $field . 'Operator=EQUALS&';
	}
	return $output . 'logicalOperator=AND';
}

function _getTaxonMultimedia ($object) {
	$client = _setNbaClient('multimedia', true);
	if (!$client) {
		return null;
	}
	
	try {
		$condition = new Condition('identifications.scientificName.genusOrMonomial', 'EQUALS', 
			$object->taxa[0]->acceptedName->genusOrMonomial);
		$condition->setAnd('identifications.scientificName.specificEpithet', 'EQUALS', 
			$object->taxa[0]->acceptedName->specificEpithet);
		$condition->setAnd('identifications.scientificName.infraspecificEpithet', 'EQUALS', 
			isset($object->taxa[0]->acceptedName->infraspecificEpithet) ? 
				$object->taxa[0]->acceptedName->infraspecificEpithet : null);
		// Make sure only Naturalis sources are queried
		if (_naturalisOnly() == 1) {
    		$condition->setAnd(_naturalisOnlyCondition());
		}
		
		$query = new QuerySpec();
		$query
			->addCondition($condition)
			->setSize(5);
		_addDebugMessage('taxon multimedia', $query);
		$data = json_decode($client->setQuerySpec($query)->query());
	} catch (Exception $e) {
		_setErrorMessage($e);
	}
//p($data);		
	if (isset($data->totalSize) && $data->totalSize > 0) {
		$output = [];
		$output['totalSize'] = $data->totalSize;
		$output['showAllLink'] = $data->totalSize > 5 ?
			_createTaxonSubsectionLink($object->taxa[0]->acceptedName, 
			'result/multimedia/') . '&from=0&logicalOperator=AND&size=100' . 
			(isset($object->referrer) ? '&referrer=' . $object->referrer : '') : null;
			
		foreach ($data->resultSet as $i => $media) {
			$output['items'][$i]['id'] = $media->item->id;
			$output['items'][$i]['src'] = $media->item->serviceAccessPoints[0]->accessUri;
			$output['items'][$i]['format'] = $media->item->serviceAccessPoints[0]->format;
			$output['items'][$i]['hits'] = isset($media->item->associatedSpecimenReference) ?
				_getMultimediaSpecimenUnitId($media) : 
					isset($media->item->caption) ? $media->item->caption : null;
			$output['items'][$i]['caption'] = _getSpecimenScientificNames('multimedia', $media);
			$output['items'][$i]['url'] = _createTaxonSubsectionLink($object->taxa[0]->acceptedName, 
				'multimedia/' . urlencode($media->item->unitID) . '/') .
				'&from=' . (max(0, $i - 1)) . 
				(isset($object->referrer) ? '&referrer=' . $object->referrer : '');
		}
		return $output;
	}
	return null;	
}

function _getTaxonSpecimens ($object) {
	if (isset($object->specimens)) {
		$data = new stdClass();
		$data->totalSize = $object->specimenCount;
		$data->showAllLink = $object->specimenCount > 5 ?
			_createTaxonSubsectionLink($object->taxa[0]->acceptedName, 
				'result/specimen/taxon/' . urlencode($object->name) . '/')  . 
				(isset($object->referrer) ? '&referrer=' . $object->referrer : '') : null; 
		foreach ($object->specimens as $i => $specimen) {
			$items[$i]['unitID'] = $specimen->unitID;
			$items[$i]['collectionType'] = isset($specimen->collectionType) ? 
				$specimen->collectionType : null;
			$items[$i]['url'] = _createTaxonSubsectionLink($object->taxa[0]->acceptedName, 
				'specimen/' . urlencode($specimen->unitID) . '/'. urlencode($object->name) . '/') .
				'&from=' . (max(0, $i - 1) . 
				(isset($object->referrer) ? '&referrer=' . $object->referrer : ''));
		}
		$data->items = $items;
		return $data;
	}
	return null;
}
	


function _getSpecimenMultimedia ($object) {
	
	$client = _setNbaClient('multimedia', true);
	if (!$client) {
		return null;
	}
	
	try {
	    
	    $condition = new Condition('associatedSpecimenReference', 'EQUALS', $object->id);
	    if (_naturalisOnly() == 1) {
	       $condition->setAnd(_naturalisOnlyCondition());
	    }
		$query = new QuerySpec();
		$query
		    ->addCondition($condition)
			->setSize(5)
			->setConstantScore();
		_addDebugMessage('specimen multimedia', $query);
		
		$names = _getSpecimenNames($object->identifications);
		$scientificName = $names[0]['name'];
		
		$data = json_decode($client->setQuerySpec($query)->query());
	} catch (Exception $e) {
		_setErrorMessage($e);
	}
	
//p($data);
	if (isset($data->totalSize) && $data->totalSize > 0) {
		$output = [];
		$output['totalSize'] = $data->totalSize;
		$output['showAllLink'] = $data->totalSize > 5 ?
			_setBasePath() . 'multimedia/associatedSpecimenReference=' . 
			urlencode($object->id) . '&associatedSpecimenReferenceOperator=EQUALS' . 
			'&logicalOperator=AND&size=100&referrer=' . $object->referrer : null;
		foreach ($data->resultSet as $i => $media) {
			$output['items'][$i]['id'] = $media->item->id;
			$output['items'][$i]['src'] = $media->item->serviceAccessPoints[0]->accessUri;
			$output['items'][$i]['format'] = $media->item->serviceAccessPoints[0]->format;
			$output['items'][$i]['hits'] = _getMultimediaSpecimenUnitId($media);
			$output['items'][$i]['caption'] = $scientificName;
			$output['items'][$i]['url'] = _setBasePath() . 'multimedia/' . 
				urlencode($media->item->unitID) . '/associatedSpecimenReference=' . 
				urlencode($object->id) . '&associatedSpecimenReferenceOperator=EQUALS&from=' . 
				(max(0, $i - 1)) . 
				(isset($object->referrer) ? '&referrer=' . $object->referrer : '');
		}
		return $output;
	}
	return null;
}



function _addTaxonDetailPageNavigation ($data, $search, $set, $name, $from) {
	$previousId = $nextId = null;
	foreach ($set->resultSet as $i => $row) {
		if (isset($row->item->name) && strtolower($row->item->name) == strtolower($name)) {
			break;
		}
	}
	$data->offset = $from + 2;
	if (isset($set->resultSet[($i - 1)]->item->name)) {
		$previousId = _setTaxonUrlName($set->resultSet[($i - 1)]->item->name);
	} else {
		$data->offset = 1;
	}
	if (isset($set->resultSet[($i + 1)]->item->name)) {
		$nextId = _setTaxonUrlName($set->resultSet[($i + 1)]->item->name);
	}
	$data->previousUrl = _setDetailPagePreviousLink('taxon', $search, $previousId);
	$data->nextUrl = _setDetailPageNextLink('taxon', $search, $nextId, $previousId);
	$data->backUrl =  _setDetailPageBackLink('taxon', $search);
	$data->totalSize = $set->totalSize;
	return $data;
}

function _setTaxonUrlName ($id) {
	return ucfirst(str_replace(' ', '_', $id));
}

function _getTaxonScientificNameById ($id = false) {
	if ($id) {
		if (!isset($_SESSION['nbaNameResolutionTaxa'][$id])) {
		  	$client = _setNbaClient('taxon');
			if (!$client) {
				return false;
			}
		  	$timer = _setTimer();
		  	$data = json_decode($client->find($id));
			_addDebugMessage('scientific name for ' . $id, _getTimer($timer));
			$_SESSION['nbaNameResolutionTaxa'][$id] = 
				_formatScientificName($data->acceptedName);
		}
		return $_SESSION['nbaNameResolutionTaxa'][$id];
	}
	return false;
}


function _getTaxonByName ($name) {
    $taxon = explode('_', $name);
  	$client = _setNbaClient('taxon');
	if (!$client) {
		return false;
	}
  	try {
	  	$condition = new Condition('acceptedName.genusOrMonomial', 'EQUALS_IC', $taxon[0]);
		if (count($taxon) > 1) {
			$condition->setAnd('acceptedName.specificEpithet', 'EQUALS_IC', $taxon[1]);
			$condition->setAnd('acceptedName.infraspecificEpithet', 
				(count($taxon) == 2 ? 'EQUALS' : 'EQUALS_IC'), 
				(count($taxon) == 2 ? null : implode(' ', array_slice($taxon, 2))));
		}
		if (_naturalisOnly() == 1) {
            $condition->setAnd(_naturalisOnlyCondition());
		}
	    $query = new GroupByScientificNameQuerySpec();
	    $query->addCondition($condition)->setSpecimensSize(5);
	    $data = json_decode($client->setQuerySpec($query)->groupByScientificName());
		if (isset($data->exception)) {
			_setErrorMessage($data->exception);
			return false;
		}
		$data = _getTaxonDetails($data);
  	} catch (Exception $e) {
		_setErrorMessage($e);
	}
	return isset($data->resultSet[0]->item) ? $data->resultSet[0]->item : false;	
}

/**
 * Operators manually set in query string (not form)
 * 
 * @param array $terms
 * @return array
 */
function _filterQueryOperators (&$terms) {
	foreach ($terms as $field => $value) {
		if (substr($field, -strlen('Operator')) === 'Operator') {
			$operators[str_replace('Operator', '', $field)] = $value;
			unset($terms[$field]);
		}
	}
	return isset($operators) ? $operators : [];
}

/**
 * Main function that builds NBA query
 * 
 * See inline documentation for logic!
 * 
 * @param string $service
 * @param array $terms
 * @param bool $useNameResolution
 * @return \nl\naturalis\bioportal\GroupByScientificNameQuerySpec|\nl\naturalis\bioportal\QuerySpec
 */
function _buildNbaQuery ($service, $terms = [], $useNameResolution = false) {
	// Logical operator is important to compile main QuerySpec: 
	// - for OR we will create one big nested OR query
	// - for AND we will create separate conditions ruled by main logical operator AND
	$logicalOperator = isset($terms['logicalOperator']) && !empty($terms['logicalOperator']) ?
		strtoupper($terms['logicalOperator']) : 'OR';
	// Set operator used to string subconditions together: setOr for simple search, 
	// but setAnd for advanced search fields such as fullScientificName!
	// Simple search
    if (isset($terms) && isset($terms['term'])) {
 		$terms = _setSimpleQueryTerms($service, $terms['term'], $terms);
		// Always use name resolution for simple search
		$useNameResolution = true;
		$andOr = 'setOr';
		$simpleSearch = true;
	// Advanced search
    } else {
		$andOr = $logicalOperator == 'OR' ? 'setOr' : 'setAnd';
		$simpleSearch = false;
	}
	// Names service must include prefix, so use names.taxa or names.specimens
	if (strpos($service, '.') !== false) {
		$lookupService = _normaliseServiceName($service);
		$query = new GroupByScientificNameQuerySpec();
	} else {
		$lookupService = $service;
		$query = new QuerySpec();
	}
	// Logical operator is always AND (form and map are exclusive)
	$query->setLogicalOperator('AND');
	// Filter any specific operators from terms; these are used later when constructing the query.
	// Currently the form only allows a global AND/OR, but users can manually construct links that
	// support specific operators. These are set as [field]Operator=AND/OR.
	$operators = _filterQueryOperators($terms);
	
	// Translate fields to NBA paths and get their operators
	// Assumes term is an array, taking into account multi-selects
    foreach ($terms as $field => $values) {
    	if (!is_array($values)) {
    		$values = [$values];
		}
		// Exception for CC licenses :(
		if ($field == 'license') {
		    _setLicenseSearchValues($values);
		}
		foreach ($values as $value) {
			$statement = $elements = $boost = [];
			$value = trim($value);
			// Exclude search flags; these will be processed later
			if (!in_array($field, _searchFlags())) {
				// Get NBA path(s) for field
				$nbaPaths = [$field];
				if (isset(_nbaFieldMapping()[$lookupService][$field])) {
					$nbaPaths = _nbaFieldMapping()[$lookupService][$field];
				}
				if ($useNameResolution && isset(_nbaNameResolutionFieldMapping()[$lookupService][$field])) {
					$nbaPaths = array_merge($nbaPaths, _nbaNameResolutionFieldMapping()[$lookupService][$field]);
				}
				// Get NBA field type
				foreach ($nbaPaths as $path) {
					// Operator: difference between simple and advanced search
					// If operator has been set in url use this; overrules all other settings
				    if (isset($operators[$field])) {
						$statement[$path] = strtoupper($operators[$field]);
					// Advanced search
					} else if (!$simpleSearch) {
						// Default
						$statement[$path] = 'STARTS_WITH_IC';
						// Select: always EQUALS_IC *except* license
						if (_isAdvancedSelect($field)) {
							$statement[$path] = 'EQUALS_IC';
						// Exception
						} else if (isset(_nbaAdvancedSearchExceptions()[$lookupService][$field])) {
							$statement[$path] = _nbaAdvancedSearchExceptions()[$lookupService][$field]['operator'];
						}
					// Simple search
					} else {
						$statement[$path] = _getConditionOperator($service, $path, $value);
					}
					// Used to determine hits
					$settings = [];
					if ($simpleSearch) {
						$settings = [
							'threshold' => NBAMINSTRINGLENGTHSIMPLESEARCH,
							'shorten' => _nbaMaxContainsStringSize(),
						];
					}
					$paths[$path] = [
					    'operator' => $statement[$path],
					    'values' => _stringToElements($value, $settings)  
					];
				}
			}
			// Value: to split or not to split?
			// Split simple search and specific advanced search fields
			// Add original term to value if it has been split
			if ($simpleSearch || (isset(_nbaAdvancedSearchExceptions()[$lookupService][$field]) && 
				_nbaAdvancedSearchExceptions()[$lookupService][$field]['split'] === true)) {
				$elements = array_merge(_stringToElements($value), [$value]);
				$boost = [$value => NBASIMPLESEARCHFULLTERMBOOST];
			}
			// Check if multiselect; change locical operator to OR!
			$operator = $andOr;
			if (!$simpleSearch && in_array($service[0] . '_' . $field, _advancedMultiSelectFields())) {
			    $operator = 'setOr';
			}
			// Group associated statements
			if (!empty($statement)) {
				$statements[] = [
					'statement' => $statement,
					'value' => !empty($elements) ? $elements : [$value],
				    'operator' => $operator,
					'boost' => $boost
				];
			}
		}
    }
    
    // Store paths for term highlighting
    if (isset($paths)) {
    	//$_SESSION['nbaQuery'][empty($type) ? $service : $service . '.' . 
    	//	substr($type, 0, -1)]['paths'] = $paths;
    	$_SESSION['nbaQuery'][$service]['paths'] = $paths;
    }
    
    // Concatenate multiselects into single value!
    // Otherwise we will end up with separate AND statements...
    foreach ($statements as $i => $statement) {
        // Get the NBA field
        $field = array_keys($statement['statement'])[0];
        // Field is new; append to temp list
        if (!isset($fields) || !in_array($field, $fields)) {
            $fields[$i] = $field;
        // Field already exists; this can only occur for multiselects.
        // Merge values with existing and delete current
        } else {
            $key = array_search($field, $fields);
            $statements[$key]['value'][] = $statement['value'][0];
            unset($statements[$i]);
        }
    }
    
    // Compile conditions
	$conditions = [];
	foreach ($statements as $d) {
		$statement = $d['statement'];
		$elements = $d['value'];
		// Set boost only if there is more than one element
		$boost = count($elements) > 1 ? $d['boost'] : [];
		$condition = $subconditions = null;
		foreach ($elements as $element) {
			// Simple search check: 
			// skip individual elements that are shorter than min size
			if ($simpleSearch && strlen($element) < NBAMINSTRINGLENGTHSIMPLESEARCH) {
				continue;
			}
			$first = true;
			foreach ($statement as $path => $operator) {
				// Search for empty value
				if ($element == '') {
					// Reset operator to EQUALS if it's not either EQUALS/NOT_EQUALS
					if (!in_array($operator, ['EQUALS', 'NOT_EQUALS'])) {
						$operator = 'EQUALS';
					}
					$element = null;
				// Option "all" from select
				} else if ($element == 'NOT_NULL') {
					$operator = 'NOT_EQUALS';
					$element = null;
				}
				// Test if CONTAINS is still allowed; if not:
				if ($operator == 'CONTAINS' && !_containsOperatorAllowed($element)) {
					// Simple search: shorten term to max length
					if ($simpleSearch) {
						$element = substr($element, 0, _nbaMaxContainsStringSize());
					// Advanced search: change operator to STARTS_WITH_IC
					} else {
						$operator = 'STARTS_WITH_IC';
					}
					
				}
				// geoShape is a special case
				if (strpos($path, 'geoShape') !== false) {
					// geoShape arrives from simple search as area name
					// check if location is present in NBA and use that!
					if (strpos($element, '@') === false && !_isValidJson($element)) {
						$area = _localityInNba($element);
						if ($area) {
							$element = $area;
						} else {
							continue;
						}
					// Valid geoShape (gid or geojson); isolate to process later;
					// can only be a single value
					} else {
						$geoShape = [
							'path' => $path,
							'value' => $elements[0],
						];
						continue;
					}
				}
				// Encode search term
				if (!is_null($element)) {
					$element = html_entity_decode($element);
				}
				// Create condition
				$condition = new Condition($path, $operator, $element);
				// Boost
				if (isset($boost[$element]) || isset(_boostPaths()[$lookupService][$path])) {
					$boostValue = 1;
					// Regular boost
					if (isset(_boostPaths()[$lookupService][$path])) {
						$boostValue *= _boostPaths()[$lookupService][$path];
					}
					// Simple search boost; will multiply regular boost
					if (isset($boost[$element])) {
						$boostValue *= $boost[$element];
					}
					$condition->setBoost($boostValue);
				}
				// Add extra condition for exact match
				if (!in_array($operator, ['EQUALS', 'EQUALS_IC', 'IN']) && !is_null($element)) {
					$boostEquals = new Condition($path, 'EQUALS_IC', $element);
					$boostEquals->setBoost(NBAEXACTMATCHBOOST);
					$condition->setOr($boostEquals);
				}
				// First condition
				if ($first) {
					$mainCondition = $condition;
					$first = false;
					continue;
				}
				// Append other elements if necessary
				$mainCondition->setOr($condition);
			}
			if (!empty($condition)) {
				$subconditions[] = [
					'condition'	=> $mainCondition,
					'operator' => $d['operator'],
				];
			}
		}
		// First make some sense of conditions and subconditions, plus remove potential
		// duplicate queries (in particular those from auto-generated simple search). 
		// Use serialized version of condition as array key to accomplish this.
		// Option 1. No subconditions, clip redundant information
		if (count($subconditions) == 1) {
			$conditions[serialize($subconditions[0]['condition'])] = 
				$subconditions[0]['condition'];
		// Option 2. Subconditions, reformat to slightly more concise notation
		} else if (!empty($subconditions[0]['condition'])) {
			$conditions[serialize(array_column($subconditions, 'condition'))] = [
				'conditions' => array_column($subconditions, 'condition'),
				'operator' => $subconditions[0]['operator'],
			];
		}
	}
	
	// OR search: string all conditions together with setOr()
	if ($logicalOperator == 'OR') {
		foreach (array_values($conditions) as $i => $condition) {
	    	if ($i == 0) {
	    		$mainCondition = _setCondition($condition);
	    		continue;
	    	}
	    	$mainCondition = _setCondition($condition, $mainCondition);
		}
		if (isset($mainCondition)) {
    		$query->addCondition($mainCondition);
		}
	// AND search: all conditions are top level conditions controlled by logicalOperator
	} else {
		foreach (array_values($conditions) as $condition) {
			$query->addCondition(_setCondition($condition));
		}
	}
	// Naturalis only
	if (_naturalisOnly() == 1) {
	   $query->addCondition(_naturalisOnlyCondition());
	}
	
    // Add map condition if present
    if (isset($geoShape)) {
	    $query->addCondition(new Condition($geoShape['path'], 'IN', $geoShape['value']));
    }
    // Add search flags
    if (isset($terms['from']) && !empty($terms['from'])) {
        $query->setFrom($terms['from']);
    }
    if (isset($terms['size']) && !empty($terms['size'])) {
        $query->setSize($terms['size']);
    }
    // Regular sort
    if (isset($terms['sort']) && !empty($terms['sort'])) {
    	$sortPaths = array_map('trim', explode(',', $terms['sort']));
   		$sortDirections = array_map('trim', explode(',', $terms['sortDirection']));
   		foreach ($sortPaths as $i => $path) {
   			$sort[] = [$path, isset($sortDirections[$i]) ? $sortDirections[$i] : null];
   		}
        $query->setSortFields($sort);
        // If sort is used, we can safely turn it into a constant score query
        $query->setConstantScore();
    }
    // groupSort
    if (isset($terms['groupSort']) && !empty($terms['groupSort']) && 
    	$query->getQuerySpecType() == 'GroupByScientificNameQuerySpec') {
    	$query->setGroupSort($terms['groupSort']);
        // If sort is used, we can safely turn it into a constant score query
        $query->setConstantScore();
    }
//p($query->getQuerySpec(true)); die();
    
    return $query;
}

/**
 * Search exception for CC licenses
 * 
 * Appends hard-coded version numbers
 * 
 * @param array $values Search term(s)
 * @return array
 */
function _setLicenseSearchValues (&$values) {
    $append = ['1.0', '2.0', '2.5', '3.0', '4.0'];
    foreach ($values as $value) {
        foreach ($append as $suffix) {
            $values[] = $value . ' ' . $suffix;
        }
    }
    return $values;    
}


function _setCondition ($condition, $appendTo = false) {
	$andOr = is_array($condition) && isset($condition['operator']) ? 
		$condition['operator'] : 'setOr';
	if (!$appendTo) {
		if (is_object($condition)) {
			return $condition;
		}
		foreach ($condition['conditions'] as $i => $subcondition) {
			if ($i == 0) {
				$output = $subcondition;
				continue;
			}
			$output->{$andOr}($subcondition);
		}
		return $output;
	}
	if (is_object($condition)) {
		return $appendTo->{$andOr}($condition);
	}
	foreach ($condition['conditions'] as $i => $subcondition) {
		if ($i == 0) {
			$output = $subcondition;
			continue;
		}
		$output->{$andOr}($subcondition);
	}
	return $appendTo->{$andOr}($output);
}



/*
 * Sets operator (LIKE, EQUALS, etc) for condition.
 * Fairly simple now, as we only search string fields in BioPortal.
 * Will become more compilated once we allow searches on date or int fields.
 */
function _getConditionOperator ($service, $nbaPath, $value = '') {
	if (strpos($service, '.') !== false) {
		$service = array_values(array_slice(explode('.', $service), -1))[0] == 'taxa' ? 
			'taxon' : 'specimen';
	}
	if (isset(_nbaFieldTypes()[$service][$nbaPath])) {
        return _getOperatorFromMapping(_nbaFieldTypes()[$service][$nbaPath], $value);
    }
    return 'EQUALS';
}


/*
 * Get operator from mapping. If present it's separated by a pipe symbol
 */
function _getOperatorFromMapping ($type, $value) {
    $p = explode('|', $type);
    if (isset($p[1])) {
        return trim($p[1]);
    }
    return 'EQUALS';
}

function _containsOperatorAllowed ($value = '') {
    return
        strlen($value) >= _nbaMinContainsStringSize() &&
        strlen($value) <= _nbaMaxContainsStringSize();
}

function _nba_taxon_result_callback ($search = false) {
    $service = 'names.taxa';
	$client = _setNbaClient($service, true);
	if (!$client) {
		return _printOops();
	}
	
    $terms = _getQueryTerms($service, $search);
    
    $headTitle = !isset($_SESSION['nbaSearch']['theme']) || empty($_SESSION['nbaSearch']['theme']) ?
        t('Search results') : t('Explore highlights');
    _setTitle($headTitle, '');   
    
    // No search terms; die with grace
    if (!$terms) {
    	_setErrorMessage('Missing search terms');
    	_printOops();
    }
    
	// Display full set on this page
	$terms['size'] = _maxResults();
	_setQueryTerms($service, $terms);
	
	try {
		
		$query = _buildNbaQuery($service, $terms);	
		$query->setSpecimensSize(0);
		
		_addDebugMessage($service, $query);
		_setBackLink('result/specimen/' . $search, 'Back to search results');	
		
		$data = json_decode($client->setQuerySpec($query)->groupByScientificName());
		
		_setGenericResultPageBackLink();
		$data = _parseTaxa($data, ['paginator']); 
		
	} catch (Exception $e) {
		_setErrorMessage($e);
	}
	
	$error = _checkInvalidNbaRequest(isset($data) ? $data : false);
	return $error ? $error : _printDebug() . _printTaxa($data);
}


function _nba_multimedia_result_callback ($search = false) {    

	$service = 'multimedia';
    $terms = _getQueryTerms($service, $search);
    $client = _setNbaClient($service, true);
	if (!$client) {
		return _printOops();
	}
    
    $headTitle = !isset($_SESSION['nbaSearch']['theme']) || empty($_SESSION['nbaSearch']['theme']) ?
        t('Search results') : t('Explore highlights');
    _setTitle($headTitle, '');   
    
    // No search terms; die with grace
    if (!$terms) {
    	_setErrorMessage('Missing search terms');
    	_printOops();
    }
    
	// Display full set on this page
	$terms['size'] = _maxResults();
	// Save query
	_setQueryTerms($service, $terms);
	
	try {
		$query = _buildNbaQuery($service, $terms);	
		_addDebugMessage($service, $query);
	    $timer = _setTimer();
		$data = json_decode($client->setQuerySpec($query)->query());
		
		_addDebugMessage($service . ' query', _getTimer($timer));
		_setGenericResultPageBackLink();
	} catch (Exception $e) {
		_setErrorMessage($e);
	}
		
	$error = _checkInvalidNbaRequest(isset($data) ? $data : false, true);
	
	return $error ? $error :
		_printDebug() . _printMultimedia(_parseMultimedia($data, ['paginator']));
}

function _nba_specimen_result_callback ($search = false) {
	
	$service = _getSpecimenService($search);
	$terms = _getQueryTerms($service, $search);
	$client = _setNbaClient($service, true);
	if (!$client) {
		return _printOops();
	}
	
    $headTitle = !isset($_SESSION['nbaSearch']['theme']) || empty($_SESSION['nbaSearch']['theme']) ?
        t('Search results') : t('Explore highlights');
    //$pageTitle = isset($_GET['theme']) ? '' : $pageTitle;
    _setTitle($headTitle, '');   
    
    // No search terms; die with grace
    if (!$terms) {
    	_setErrorMessage('Missing search terms');
    	_printOops();
    }
    
	// Display full set on this page
	$terms['size'] = _maxResults();
	// Save query
	_setQueryTerms($service, $terms);
	_setGenericResultPageBackLink();
	
	// Scientific name group query
	if ($service == 'names.specimens') {

		try {
			$query = _buildNbaQuery($service, $terms);	
			$query->setGroupFilter(_setFilterRejectEmptyGenus());
			
			_addDebugMessage('Specimen by taxon', $query);
			
			$timer = _setTimer();
			
			// Fetch data set
			$data = json_decode($client->setQuerySpec($query)->groupByScientificName());
			_addDebugMessage('Specimen by taxon query', _getTimer($timer));
		
			$data->specimensTotal = _getSpecimensTotal($terms);
			$data = _parseSpecimensTaxon($data, ['paginator']); 
			
		} catch (Exception $e) {
			_setErrorMessage($e);
		}
		
		$error = _checkInvalidNbaRequest(isset($data) ? $data : false);
		return $error ? $error : _printDebug() . _printSpecimensTaxon($data);
	
	}
	
	try {
		
		$query = _buildNbaQuery($service, $terms);	
		$timer = _setTimer();
		$data = json_decode($client->setQuerySpec($query)->query());
		
		_addDebugMessage('Specimen query', _getTimer($timer));		
		$data = _parseSpecimens($data, ['paginator']);
		_addDebugMessage("Specimen", $query);
		
	} catch (Exception $e) {
		_setErrorMessage($e);
	}
	
	$error = _checkInvalidNbaRequest(isset($data) ? $data : false);
	return $error ? $error : _printDebug() . _printSpecimens($data);
}



function _getSearchPaths ($service) {
	$data = _nbaFieldMapping()[_normaliseServiceName($service)];
	foreach ($data as $term => $paths) {
		foreach ($paths as $i => $path) {
			$result[$path] = $term . $i;
		}
	}
	//return $data;
	return isset($result) ? array_values(array_flip($result)) : false;
}


function _nba_specimen_taxon_result_callback ($scientificNameGroup = false, $search = false) {
	
    $service = 'names.specimens';
	$client = _setNbaClient($service, true);
	if (!$client) {
		return _printOops();
	}
	$terms = _getQueryTerms($service, $search);
	$terms['size'] = _maxResults();
	_setQueryTerms($service, $terms);
    
    $specimensFrom = isset($terms['from']) ? $terms['from'] : 0;
	unset($terms['size'], $terms['from']);
     
    // No search terms; die with grace
    if (!$scientificNameGroup || !$terms) {
    	_setErrorMessage('Missing name group or search terms');
    	_printOops();
    }
   
    try {

		$query = _buildNbaQuery($service, $terms);	
	    $filter = new Filter();
	    $filter->acceptValues([$scientificNameGroup]);
		$query
			->setGroupFilter($filter)
			->setSpecimensFrom($specimensFrom)
			->setSpecimensSize(_maxResults());
			
		// Store query in case user wants to print it on screen
		_addDebugMessage('specimens of ' . ucfirst($scientificNameGroup), $query);
		
		// Trim from from $search
		safe_parse_str($search, $parts);
		unset($parts['from']);
		_setBackLink('result/specimen/' . safe_http_build_query($parts), 'Back to search results');
		
		// Fetch data set
		$timer = _setTimer();
		$data = json_decode($client->setQuerySpec($query)->groupByScientificName());
		_addDebugMessage('specimens of ' . ucfirst($scientificNameGroup) . ' query', _getTimer($timer));
		
		$data->specimensFrom = $specimensFrom;
		$data = _parseSpecimensTaxon($data, ['paginator']); 
		
    } catch (Exception $e) {
		_setErrorMessage($e);
	}
	
	$error = _checkInvalidNbaRequest(isset($data) ? $data : false);
	return $error ? $error : _printDebug() . _printSpecimensSingleTaxon($data);
}


function _nba_specimen_map_result_callback ($scientificNameGroup = false, $search = false) {

	$service = 'names.specimens';
	$client = _setNbaClient($service, true);
	if (!$client) {
		return _printOops();
	}
	$terms = _getQueryTerms($service, $search);
    $size = isset($terms['size']) ? $terms['size'] : _maxResults();
    unset($terms['size'], $terms['from']);
    
    $headTitle = !isset($_SESSION['nbaSearch']['theme']) || empty($_SESSION['nbaSearch']['theme']) ?
        t('Search results') : t('Explore highlights');
    _setTitle($headTitle, '');   
    
    // No search terms; die with grace
    if (!$scientificNameGroup || !$terms) {
    	_setErrorMessage('Missing name group or search terms');
    	_printOops();
    }
    
	try {
		$query = _buildNbaQuery($service, $terms);	
	    $filter = new Filter();
	    $filter->acceptValues([$scientificNameGroup]);
		$query
			->setGroupFilter($filter)
			->setSpecimensFrom(0)
			->setSpecimensSize($size);
		_addDebugMessage($service, $query);
		$data = json_decode($client->setQuerySpec($query)->groupByScientificName());
		
		// Set geoShape
	    if (!empty(_getStoredGeoShape()) && _getStoredGeoShape() != -1) {
	    	$data->geoJson = _getStoredGeoShape();
	    } else if (isset($terms['gid'])) {
	    	$data->geoJson = _getGeoShapeForGeoId($terms['gid']);
	    } else if (isset($terms['geoShape'])) {
	    	$data->geoJson = $terms['geoShape'];
	    }
	    
		_setGenericDetailPageBackLink('specimen', $search);
	    
	} catch (Exception $e) {
		_setErrorMessage($e);
	}	
	
	$error = _checkInvalidNbaRequest(isset($data) ? $data : false, true);
	return $error ? $error : _printSpecimensMap(_parseSpecimensMap($data));
}


/*
function _setLanguage () {
    $langs = language_list(); // Note: No argument
    $langcode = isset($_GET["language"]) && !empty($_GET["language"]) ? $_GET["language"] : '';
    if (!empty($langcode)) {
        variable_set('language_default', $langs[$langcode]);
    }
}
*/

/**
 * Sets head and (optionally) page title
 *
 * @param string $head Head title
 * @param string $page Page title
 */
function _setTitle ($head, $page = '') {
    $_SESSION['nbaPageTitle'] = $head;
    drupal_set_title($page);
}



/**
 * Accepts search form data and returns formatted result
 *
 * The main function that actually processes the incoming GET data, stores the
 * GET data in a SESSION, distributes the search to the appropriate channels
 * and returns the formatted output.
 *
 * Headers were added to avoid problems with "Webpage has expired" in IE after
 * hitting back button
 *
 * @return string The formatted output
*/
function _nba_general_result_callback () {
	
	// BIOPORVTWO-262: always revert to specimen search when searching
	_resetSpecimenService();
	
    $headTitle = !isset($_SESSION['nbaSearch']['theme']) || empty($_SESSION['nbaSearch']['theme']) ?
        t('Search results') : t('Explore highlights');
    _setTitle($headTitle, '');   
    $_SESSION['nbaSearch'] = $_GET;
    
    // GET data from the search form?
    // If so, add to SESSION or replace existing SESSION data
    if (isset($_GET['form_id']) && $_GET['form_id'] == 'ndabio_advanced_taxonomysearch') {
        //drupal_set_title(t("Search results"));
        _setBackLink('?searchagain=1', 'Modify search');
        _logSearch();
        if (isset($_SESSION['nbaSearch']['term']) && !empty($_SESSION['nbaSearch']['term'])) {
        	return _nbaSimpleSearch();
        }
        return _nbaAdvancedSearch();
    }
    if (isset($_SESSION['nbaSearch']['theme']) && !empty($_SESSION['nbaSearch']['theme'])) {
    	_setBackLink('/', 'Home');
        return _nbaThemeSearch();
    }
    return _printOops();

}

/**
 * Get taxon data for name from NBA
 * 
 * Optionally, only boolean can be returned. This speeds up the query, as no 
 * GroupByScientificNameQuerySpec has to be used.
 * 
 * @param string|array $taxon
 * @param bool $existsOnly Return only exists true/false, no data
 * @return object|boolean
 */
function _getTaxonFromNba ($taxon, $existsOnly = false) {
	if (is_string($taxon)) {
		$taxon = explode(' ', $taxon);
	} 
	$taxon = array_filter($taxon);
	if (isset($taxon[0]) && isset($taxon[1])) {
		try {
			$condition = new Condition('acceptedName.genusOrMonomial', 'EQUALS_IC', $taxon[0]);
			if (count($taxon) > 1) {
				$condition->setAnd('acceptedName.specificEpithet', 'EQUALS_IC', $taxon[1]);
				$condition->setAnd('acceptedName.infraspecificEpithet', 
					(count($taxon) == 2 ? 'EQUALS' : 'EQUALS_IC'), 
					(count($taxon) == 2 ? null : implode(' ', array_slice($taxon, 2))));
			}
			if (_naturalisOnly() == 1) {
                $condition->setAnd(_naturalisOnlyCondition());
			}
			$client = _setNbaClient('taxon');
			if (!$client) {
				return false;
			}
			$timer = _setTimer();
			// Full data
			if (!$existsOnly) {
				$query = new GroupByScientificNameQuerySpec();
				$query
					->addCondition($condition)
					->setConstantScore()
					->setSpecimensSize(0);
				_addDebugMessage(implode(' ', $taxon) . ' exists in NBA', $query);
			    $data = json_decode($client->setQuerySpec($query)->groupByScientificName());
			// Exists true/false only
			} else {
				$query = new QuerySpec();
				$query
					->addCondition($condition)
					->setConstantScore();
				_addDebugMessage(implode(' ', $taxon) . ' exists in NBA', $query);
			    $data = json_decode($client->setQuerySpec($query)->query());
			    return isset($data->totalSize) && $data->totalSize > 0;
			}
			_addDebugMessage(implode(' ', $taxon) . ' query', _getTimer($timer));
		} catch (Exception $e) {
			_setErrorMessage($e);
		}
	    return isset($data->resultSet) ? $data->resultSet : false;
	} 
	return false;
}





/**
 * Distributes search parameters of the advanced search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output
 */
function _nbaAdvancedSearch () {

    // Delete previous search terms when performing new query
    unset($_SESSION['nbaQuery']);
    
    $useNameResolution = false;
    $timeOuts = [];
 //   $useNameResolution = true; // @todo: nog verwijderen!
    
    $services['names.taxa'] = _setSectionParameters($_SESSION['nbaSearch'], 't_');
    $services['multimedia'] = _setSectionParameters($_SESSION['nbaSearch'], 'm_');
    $services[_getSpecimenService()] = _setSectionParameters($_SESSION['nbaSearch'], 's_');
    
    // Test if anything has been posted; if not return with error message
    if (!_dataPosted($services)) {
    	_setErrorMessage('Missing search terms');
        _printOops();
    }
    
    // BIOPORVTWO-363: if geo search is used, check if advanced search has been used. 
    // If so disable the section that has no criteria!
    if (_isGeoSearch()) {
    	$pM = _countSearchParameters($services['multimedia']);
    	$pS = _countSearchParameters($services[_getSpecimenService()]);
    	// Either specimen of multimedia has at least one criterium
    	if ($pM + $pS > 2) {
    		if ($pM == 1) {
    			$services['multimedia'] = [];
    		} else if ($pS == 1) {
    			$services[_getSpecimenService()] = [];
    		}
    	}
    }

    // Get json response for each service that provides search parameters
    foreach ($services as $service => $terms) {
        if (_serviceUsed($terms)) {
            // Init client
        	$client = _setNbaClient($service, true);
	        if (!$client) {
				return _printOops();
			}
	        	// Cap results
            $terms['size'] = _maxResultsInitial();
            // Set default score; only has to be set for names.specimens;
            // defaults to score for others.
        	if ($service == 'names.specimens' && !isset($terms['groupSort'])) {
				$terms['groupSort'] = 'name_asc';
			}
			
			try {
	            // Build QuerySpec; do not use name resolution
				$query = _buildNbaQuery($service, $terms, $useNameResolution);
	            // Trim specimens from taxon query
	            if ($service == 'names.taxa') {
	            	$query->setSpecimensSize(0);
	            } 
	            
	            // Trim ? scientific names from specimen
	            if ($service == 'names.specimens') {
	            	$query->setGroupFilter(_setFilterRejectEmptyGenus());
	            } 
	            
	            $client->setQuerySpec($query);
				_addDebugMessage($service, $client);
	            
	            $timer = _setTimer();
	            // Must use groupByScientificName() for names services
				$remoteData[$service] = strpos($service, 'names') === false ? 
					$client->query() : $client->groupByScientificName();
				
				$timerEnd = _getTimer($timer);
				
	            if ($timerEnd > _nbaTimeout()) {
	            	$timeOuts[$service] = $timerEnd;
	            }
	
	            _addDebugMessage($service . ' query', $timerEnd);

	            // Save service-specific query terms to session; used for navigation
	            _setQueryTerms($service);
	            
	            // Check if multimedia exists for this query
	            if (empty($services['multimedia']) && $service != 'multimedia' && 
	            	_allTermsExistInMultimediaService($terms)) {
	            	$query = _buildNbaQuery('multimedia', $terms, $useNameResolution);
	            	$associatedReference = 'associated' . ucfirst(_normaliseServiceName($service)) . 
	            		'Reference';
	            	$condition = 
	            		new Condition($associatedReference, 'NOT_EQUALS');
	            	$query
	            		->addCondition($condition)
	            		->setSize(0);
					
	            	$timer = _setTimer();
	
	            	$data = json_decode($client->multimedia()->setQuerySpec($query)->query());
	            	
	            	_addDebugMessage($service . ' media query', _getTimer($timer));
	            	
	            	if (isset($data->totalSize) && $data->totalSize > 0) {
	            		$mediaLinks[$service] = [
	            			'total' => $data->totalSize,
	            			'url' => _setBasePath() . 'result/multimedia/' .
								safe_http_build_query(_getQueryTerms($service)) . '&' . 
	            				$associatedReference . '=&' . $associatedReference . 'Operator=NOT_EQUALS'
	            		];
	            	}
	            }
	            
			} catch (Exception $e) {
				_setErrorMessage($e);
			}
        }
    }
    
    $pageBody = $pageHeader = '';

    if (_isGeoSearch()) {
		$area = !empty(_getStoredLocation()) ? _getStoredLocation() : t('area drawn on map');
        $pageHeader .=
            _wrap(
                _wrap(
                    t("Showing only results in")
                   . " "
                   . _wrap($area, "span", "term"),
                   "h1"
            ), "div", "panel"
        );
    }
    $pageHeader .= _wrap(t('Search results'), "h1");

	// Order is multimedia > specimens > taxa
	if (!empty($remoteData['multimedia'])) {
		$data = _parseMultimedia(json_decode($remoteData['multimedia']), ['showAll']);
		$pageBody .= _printMultimedia($data);
	}

/*/ Disabled by request
	if (!empty($remoteData['names.specimens'])) {
		$data = json_decode($remoteData['names.specimens']); 
		$data->specimensTotal = _getSpecimensTotal($services['names.specimens'],
			$useNameResolution);
		$pageBody .= _printSpecimensTaxon(_parseSpecimensTaxon($data, ['showAll']));
	}
*/


	if (!empty($remoteData['specimen'])) {
		$data = json_decode($remoteData['specimen']);
		$data->mediaLink = isset($mediaLinks['specimen']) ?
			$mediaLinks['specimen'] : null;
		$options = ['showAll'];
		if (empty($remoteData['multimedia'])) {
			$options[] = 'mediaLink';
		}
		$pageBody .= _printSpecimens(_parseSpecimens($data, $options));
	}

	if (!empty($remoteData['names.taxa'])) {
		$data = json_decode($remoteData['names.taxa']); 
		$data->mediaLink = isset($mediaLinks['names.taxa']) ?
			$mediaLinks['names.taxa'] : null;
		$pageBody .= _printTaxa(_parseTaxa($data, ['showAll', 'mediaLink']));
	}
	
	// Lieveheersbeestje! Check if we can present an alternate query
	if (empty($pageBody)) {
		// Check if characters > 15 and uses contains
		$service = _advancedSearchSingleServiceUsed($services);
		if ($service) {
			$suggestion =_advancedSearchNoResultSuggestion($service);
			if ($suggestion) {
				$pageBody = _printAdvancedSearchSuggestion($suggestion);
			}
		}
	}
	
	return $pageHeader . _printDebug() . 
		(!empty($pageBody) ? $pageBody : _printNoResults($timeOuts));
}


/**
 * Quick test if only a single service is used for advanced search
 * 
 * @param array $services
 * @return boolean
 */
function _advancedSearchSingleServiceUsed ($services) {
	foreach ($services as $service => $values) {
		if (!empty($values)) {
			$used[] = $service;
		}
	}
	return isset($used) && count($used) == 1 ? $used[0] : false;
}

function _advancedSearchNoResultSuggestion ($service) {
	// If session is not set, skip the whole thing
	if (!isset($_SESSION['nbaQuery'][$service]['terms'])) {
		return false;
	}
	$terms = $_SESSION['nbaQuery'][$service]['terms'];
	$paths = $_SESSION['nbaQuery'][$service]['paths'];
	
	foreach ($paths as $path => $p) {
		foreach ($p['values'] as $value) {
			if ($p['operator'] == 'CONTAINS') {
				if (strlen($value) > _nbaMaxContainsStringSize()) {
					$modified[_nbaPathToTerm($service, $path)] = 
						substr($value, 0, _nbaMaxContainsStringSize());
				}
			}
		}
	}
	// Do we have at least one hit?
	if (isset($modified)) {
		return [
			'modified' => $modified,
			'original' => _getSearchTerms($terms),
			'url' => _setStartUrl() . 'result' . '/' . _normaliseServiceName($service) . 
				'/' . http_build_query(array_merge($terms, $modified)),
		];
	}
	return false;
}

function _nbaPathToTerm ($service, $checkPath) {
	foreach (_nbaFieldMapping()[_normaliseServiceName($service)] as $term => $paths) {
		foreach ($paths as $path) {
			if ($checkPath == $path) {
				return $term;
			}
		}
	}
	return false;
}

/**
 * Used to check if all terms in taxon/specimen query exist in multimedia index
 * 
 * If so, query can be repeated for multimedia link
 * 
 * @param array $terms
 * @return boolean
 */
function _allTermsExistInMultimediaService ($terms) {
	foreach ($terms as $field => $value) {
		if (!in_array($field, _searchFlags())) {
			if (!isset(_nbaFieldMapping()['multimedia'][$field])) {
				return false;
			}
		}
	}
	return true;
}

function _getSpecimensTotal ($terms, $useNameResolution = false) {
	$client = _setNbaClient('names.specimens', true);
	if (!$client) {
		return -1;
	}
	foreach (['size', 'from', 'sort', 'sortDirection'] as $p) {
		if (isset($terms[$p])) {
			unset($terms[$p]);
		}
	}
	$query = _buildNbaQuery('specimen', $terms, $useNameResolution);
	$query
		->setConstantScore()
		->setSize(1);
	_addDebugMessage('total specimens', $query);
	$timer = _setTimer();
	try {
        $data = json_decode($client->setQuerySpec($query)->query());
        _addDebugMessage('total specimens query', _getTimer($timer));
        if (isset($data->totalSize)) {
            return $data->totalSize;
        }
    } catch (Exception $e) {
        _setErrorMessage($e);
    }
	return -1;
}

/**
 * Filter to exclude records with an empty genus name
 * 
 * @return \nl\naturalis\bioportal\Filter
 */
function _setFilterRejectEmptyGenus () {
	$filter = new Filter();
	$filter->rejectRegexp("\?.*");
	return $filter;
}

// Assume data on genus, species, infraspecies can be deduced from data first specimen
function _setSpecimensAllLink ($row) {
	if (isset($row->item->specimens[0]->identifications[0]->scientificName->genusOrMonomial)) {
		$id = $row->item->specimens[0]->identifications[0]->scientificName;
		$output = 'result/specimen/?genusOrMonomial=' . urlencode($id->genusOrMonomial);
		if (isset($id->specificEpithet) && !empty($id->specificEpithet)) {
			$output .= '&amp;specificEpithet=' . urlencode($id->specificEpithet);
		}
		if (isset($id->infraspecificEpithet) && !empty($id->infraspecificEpithet)) {
			$output .= '&amp;infraspecificEpithet=' . urlencode($id->infraspecificEpithet);
		}
	}
	return isset($output) ? $output : '';
}

function _getSpecimenSources ($row) {
	foreach ($row->item->specimens as $i => $specimen) {
		$output[$specimen->sourceSystem->name] = $i;
	}
	return isset($output) ? array_flip($output) : false;
}


function _getSpecimenDetails (&$data) {
	if (!isset($data->resultSet) || empty($data->resultSet)) {
		return false;
	}
	$client = _initNbaClient();
	// Aggregate conditions for all specimens in result
	foreach ($data->resultSet as $i => $row) {
		foreach ($row->item->specimens as $item) {
			$condition = new Condition('unitID', 'EQUALS', $item->unitID);
			if (_naturalisOnly() == 1) {
                $condition->setAnd(_naturalisOnlyCondition());
			}
			$query = new QuerySpec();
			$query
				->addCondition($condition)
				->setConstantScore()
				->setSize(1);
			$batch[$item->unitID] = $query;
			_addDebugMessage('details for ' . $item->unitID, $query);
		}
	}
	// Fetch all specimens at once
	if (isset($batch)) {
		$remoteData = $client->specimen()->singleClientBatchQuery($batch);
		$specimens = array_map('json_decode', $remoteData);
		// Loop again over result and append the fetched specimen details
		foreach ($data->resultSet as $i => $row) {
			foreach ($row->item->specimens as $j => $item) {
				if (isset($specimens[$item->unitID])) {
					$detail = $specimens[$item->unitID];
					$data->resultSet[$i]->item->specimens[$j]->specimenDetails =
						$detail->resultSet[0]->item;
				}
			}
		}
//echo 'errors: ' ; echo count($client->getCurlErrors()); p($client->getCurlErrors());
		return $data;
	}
	return false;
}

function _getTaxonDetails (&$data) {
	if (!isset($data->resultSet) || empty($data->resultSet)) {
		return false;
	}
	$client = _initNbaClient();
	// Aggregate conditions for all specimens in result
	foreach ($data->resultSet as $i => $row) {
		foreach ($row->item->taxa as $item) {
			// Cannot use id for batch query unfortunately...
			try {
				$condition = new Condition('sourceSystem.code', 'EQUALS', $item->sourceSystem->code);
				$condition->setAnd('acceptedName.fullScientificName', 'EQUALS', 
					$item->acceptedName->fullScientificName);
				$query = new QuerySpec();
				$query
					->addCondition($condition)
					->setConstantScore()
					->setSize(1);
				$batch[$item->id] = $query;
				_addDebugMessage('details for ' . $item->acceptedName->fullScientificName, $query);
			} catch (Exception $e) {
				_setErrorMessage($e);
			}
		}
	}
	// Fetch all specimens at once
	if (isset($batch)) {
		$remoteData = $client->taxon()->singleClientBatchQuery($batch);
		$taxa = array_map('json_decode', $remoteData);
		// Loop again over result and append the fetched specimen details
		foreach ($data->resultSet as $i => $row) {
			foreach ($row->item->taxa as $j => $item) {
				if (isset($taxa[$item->id])) {
					$detail = $taxa[$item->id];
					$data->resultSet[$i]->item->taxa[$j]->taxonDetails =
						$detail->resultSet[0]->item;
				}
			}
		}
		return $data;
	}
	return false;
}

function _setQueryTerms ($service, $terms = false) {
    // Search form
    if (!$terms) {
    	// Names again...
    	$section = strpos($service, '.') !== false ?
    		substr($service, strpos($service, '.') + 1, 1) . '_' : $service[0] . '_';
        $terms = _setSectionParameters($_GET, $section);
    }
    $_SESSION['nbaQuery'][$service]['terms'] = $terms;
    return $terms;
}

function _getStoredQueryTerms ($service) {
    return isset($_SESSION['nbaQuery'][$service]['terms']) ?
		$_SESSION['nbaQuery'][$service]['terms'] : false;
}

function _getQueryTerms ($service, $search = false) {
	// Convert query string to parameters
	if ($search) {
		safe_parse_str($search, $terms);
		// Specimen view option
		if (isset($terms['service']) && !empty($terms['service'])) {
			unset($terms['service']);
		}
	// Revert to stored terms to fetch terms (non-preferred!)
    } else if ($service) {
    	$terms = _getStoredQueryTerms($service);
    }
	if (!$terms) {
		return false;
	}
	// Reset empty strings to null to allow searching for missing values
	foreach ($terms as $field => $value) {
		if ($value === '') {
			$terms[$field] = null;
		}
	}
	// Both geoShape and gid set; unset first
	if (isset($terms['gid']) && !empty($terms['gid']) &&
		isset($terms['geoShape']) && !empty($terms['geoShape'])) {
		unset($terms['geoShape']);
	}
	if (!isset($terms['from']) || !ctype_digit(strval($terms['from']))) {
		$terms['from'] = 0;
	}
	// Make sure size does not exceed maximum
	$terms['size'] = isset($terms['size']) ? 
		min($terms['size'], _maxResults()) : _maxResults();
	// Check if size plus from does not exceed maximum results;
	// if so, quietly reset both to zero.
	if (_exceedsMaxResults($service, ($terms['size'] + $terms['from'] - 1))) {
		$terms['size'] = $terms['from'] = 0;
	}
	
	return $terms;
}


function _getSpecimenService ($search = false) {
	if ($search) {
		safe_parse_str($search, $terms);
		if (isset($terms['service'])) {
			$_SESSION['nbaSpecimenService'] = 
				$terms['service'] == 'taxon' ? 
					'names.specimens' : 'specimen';
		}
	}
	if (isset($_SESSION['nbaSpecimenService']) && 
		!empty($_SESSION['nbaSpecimenService'])) {
		return $_SESSION['nbaSpecimenService'];
	}
	$_SESSION['nbaSpecimenService'] = 'specimen';
	return $_SESSION['nbaSpecimenService'];
}

function _resetSpecimenService () {
	$_SESSION['nbaSpecimenService'] = 'specimen';
	return $_SESSION['nbaSpecimenService'];	
}

function _termsToQuerySpec ($service, $terms) {
	// Simple search
    if (isset($terms) && isset($terms['term'])) {
		$terms = _setSimpleQueryTerms($service, $terms['term'], $terms);
	}
	return $terms;
}

function _getSearchTerms (array $terms) {
	foreach (_searchFlags() as $flag) {
		if (isset($terms[$flag])) {
			unset($terms[$flag]);
		}
	}
	return !empty($terms) ? $terms : false;
}


function _getQueryPaths ($service) {
	return isset($_SESSION['nbaQuery'][$service]['paths']) ?
		$_SESSION['nbaQuery'][$service]['paths']: false;
}

function _getPaginator ($service, $total, $from) {
	// Reset total to max results if necessary
	$total = min($total, _getMaxResultsPerPage($service));
	$offset = $from / _maxResults() + 1;
	$paginator = new Paginator($total, _maxResults(), $offset, _setPaginatorUrl());
	return $paginator->toHtml();
}

/**
 * Sets url for paginator
 *
 * Strips offset from self link and replaces this with placeholder for paginator
 *
 * @param array $data Json
 * @param boolean $groupResult
 * @return string Url
 */
function _setPaginatorUrl () {
	// Strip off the from component of the url
    $search = basename(_setBasePath() . current_path());
    safe_parse_str($search, $terms);
    if (isset($terms['from'])) {
    	unset($terms['from']);
    }
    return _setBasePath() . str_replace($search, '', current_path()) . 
    	safe_http_build_query($terms) . '&from=(:num)';
}

/**
 * Gets _offset from json
 *
 * @param array $data Json
 * @return int Offset
 */
function _getPaginatorOffset ($service) {
    if (isset(_getQueryTerms($service)['from'])) {
        return _getQueryTerms($service)['from'];
    }
    return 0;
}



function _setSimpleQueryTerms ($service, $term, $additionalTerms = []) {
	$service = _normaliseServiceName($service);
	if (isset(_nbaFieldMapping()[$service])) {
		// Remove gid and search from mapping
		$mapping = array_diff_key(_nbaFieldMapping()[$service], 
			array_flip(['gid', 'term']));
		// Remove search from additional terms
		if (isset($additionalTerms['term'])) {
			unset($additionalTerms['term']);
		}
		foreach ($mapping as $field => $paths) {
			$terms[$field] = $term;
		}
		$terms['logicalOperator'] = 'or';
		return array_filter(array_merge($terms, $additionalTerms));
	}
	return false;
}


function _localityInNba ($locality) {
	$locality = ucfirst($locality);
	$nbaAreas = (array) json_decode(_nbaGeoAreas(), true);
	$areas = array_merge(
		_arrayColumnRecursive($nbaAreas, 'en'),
		_arrayColumnRecursive($nbaAreas, 'nl')
	);
	// We must use the English version!
	foreach ($nbaAreas as $type => $areas) {
		foreach ($areas as $i => $area) {
			// English version
			if ($area['locality']['en'] == $locality) {
				return $locality;
			}
			// Dutch
			if ($area['locality']['nl'] == $locality) {
				return $nbaAreas[$type][$i]['locality']['en'];
			}
		}
	}
	// Nature areas (no translation required)
	foreach (_geoNatureAreasSuffices() as $suffix) {
		if (in_array($locality . ' (' . $suffix . ')', $areas)) {
			return $locality . ' (' . $suffix . ')';
		}
	}
	return false;
}


/**
 * Distributes search parameter of the simple search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output
 */
function _nbaSimpleSearch () {

	
	// Delete previous search terms when performing new query
    unset($_SESSION['nbaQuery']);
    
    $pageBody = $pageHeader = '';
    $useNameResolution = true;
    $timeOuts = [];
    
    $terms['term'] = $_SESSION['nbaSearch']['term'];
    $services['names.taxa'] = $terms;
    
    // Taxon search does not include geoShape and should 
    // not be invoked when coming from geo form
    // when a search are has been entered
    if (_isGeoSearch()) {
        unset($services['names.taxa']);

        $terms['geoShape'] = _getStoredGeoShape();
        $terms['gid'] = _setNbaGid(_getStoredGid());
        
        $area = !empty(_getStoredLocation()) ? _getStoredLocation() :
            t('area drawn on map');

        $pageHeader .=
            _wrap(
                _wrap(
                    t("Showing only results in")
                   . " "
                   . _wrap($area, "span", "term"),
                   "h1"
                ), "div", "panel"
            );
    };
    
    $services[_getSpecimenService()] = $terms;
    $services['multimedia'] = $terms;
    
    // Get json response for each service that provides search parameters
    foreach ($services as $service => $terms) {
		// Init client, construct query, fetch results in $remoteData
		$client = _setNbaClient($service, true);
		if (!$client) {
			return _printOops();
		}
    	// Cap results
		$terms['size'] = _maxResultsInitial();
		
		try {
			// Build QuerySpec; use name resolution
			$query = _buildNbaQuery($service, $terms, $useNameResolution);
			// Trim specimens from taxon query
			if ($service == 'names.taxa') {
				$query->setSpecimensSize(0);
			}
	        // Trim ? scientific names from specimen
	        if ($service == 'names.specimens') {
	            $query->setGroupFilter(_setFilterRejectEmptyGenus());
	        } 
	 
			_addDebugMessage('service ' . $service, $query);
	
			$multiQuery[_normaliseServiceName($service)] = [
	 			'queryType' => strpos($service, 'names') === false ? 
	 				'query' : 'groupByScientificName',
	 			'querySpec' => $query
	 		];
	 		
			// Save service-specific query to session;
			// used for further navigation
			$_SESSION['nbaQuery'][$service]['terms'] = $terms;
			//_setQueryTerms($service);
			
		 	// Batch query
		 	$timer = _setTimer();
		    $remoteData = $client->multiClientBatchQuery($multiQuery);
		 	$timerEnd = _getTimer($timer);
			
			if ($timerEnd > _nbaTimeout()) {
				$timeOuts[] = $timerEnd;
			}
			
		 	_addDebugMessage('batch query', $timerEnd);
		
		} catch (Exception $e) {
			_setErrorMessage($e);
		}
    }
    
    $pageHeader .= _wrap(t('Search results for') . ' ' .
        _wrap($_SESSION['nbaSearch']['term'], "span", "term"), "h1");

	// Order is multimedia > specimens > taxa
	if (!empty($remoteData['multimedia'])) {
		$data = json_decode($remoteData['multimedia']);
		$pageBody .= _printMultimedia(_parseMultimedia($data, ['showAll']));
	}
	
	/* Disabled by request
	if (!empty($remoteData['names.specimens'])) {
		$data = json_decode($remoteData['names.specimens']); 
		$data->specimensTotal = _getSpecimensTotal($services['names.specimens'], 
			$useNameResolution);
		$pageBody .= _printSpecimensTaxon(_parseSpecimensTaxon($data, ['showAll']));
	}
	*/
	
//p($remoteData);
	
	if (!empty($remoteData['specimen'])) {
		$data = json_decode($remoteData['specimen']); 
		$pageBody .= _printSpecimens(_parseSpecimens($data, ['showAll']));
	}
	
	if (!empty($remoteData['names.taxa'])) {
		$data = json_decode($remoteData['names.taxa']); 
		$pageBody .= _printTaxa(_parseTaxa($data, ['showAll']));
	}
	
	if (!empty($remoteData['taxon'])) {
		$data = json_decode($remoteData['taxon']); 
		$pageBody .= _printTaxa(_parseTaxa($data, ['showAll']));
	}
	
    return $pageHeader .  _printDebug() . 
    	(!empty($pageBody) ? $pageBody : _printNoResults($timeOuts));
}


function _rewriteSimpleSearchTerm ($terms) {
	foreach ($terms as $i => $term) {
		$terms[$i] = substr($term, 0, _nbaMaxContainsStringSize());
	}
	return $terms;
}

/**
 * Test if number of results exceeds maximum
 * 
 * Used to issue warning on result pages and to trim paginator
 * 
 * @param string $service
 * @param int $total
 * @return boolean
 */
function _exceedsMaxResults ($service, $total = 1) {
	// Grouped service
	if (strpos($service, '.') !== false) {
		return $total >= _nbaMaxNumPerScientificNameGroup()[_normaliseServiceName($service)];
	}
	// Regular service
	return $total > _nbaMaxResultWindow()[$service];
}






function _nbaThemeSearch () {
	
	// Delete previous search terms when performing new query
    unset($_SESSION['nbaQuery']);
    
    $pageBody = $pageHeader = '';
    ctools_class_add(array('thematic-search'));
    
    $terms['theme'] = $_SESSION['nbaSearch']['theme'];
    
    $services[_getSpecimenService()] = $terms;
    $services['multimedia'] = $terms;
    
    // Get json response for each service that provides search parameters
    foreach ($services as $service => $terms) {
		// Init client, construct query, fetch results in $remoteData
		$client = _setNbaClient($service, true);
    	if (!$client) {
			return _printOops();
		}
		// Cap results
		$terms['size'] = _maxResultsInitial();
		
		// Set default sort
		if ($service == 'names.specimens' || $service == 'multimedia') {
			$terms['sort'] = 
				'identifications.scientificName.genusOrMonomial,' . 
				'identifications.scientificName.specificEpithet,' .
				'identifications.scientificName.infraspecificEpithet';
			$terms['sortDirection'] = 'asc,asc,asc';
		} else if ($service == 'specimen') {
			$terms['sort'] = 'unitID';
			$terms['sortDirection'] = 'asc';
		}
		
		// Build QuerySpec; use name resolution
		try {
            $query = _buildNbaQuery($service, $terms, true);
            $client->setQuerySpec($query);

            $remoteData[$service] = strpos($service, 'names') === false ?
                $client->query() : $client->groupByScientificName();

            // Save service-specific query to session;
            // used for further navigation
            $_SESSION['nbaQuery'][$service]['terms'] = $terms;
            //_setQueryTerms($service);
            _addDebugMessage($service, $client);
        } catch (Exception $e) {
            _setErrorMessage($e);
        }
    }

	// Order is multimedia > specimens > taxa
	if (!empty($remoteData['multimedia'])) {
		$data = json_decode($remoteData['multimedia']);
		$pageBody .= _printMultimedia(_parseMultimedia($data, ['showAll']));
	}
	
	if (!empty($remoteData['names.specimens'])) {
		$data = json_decode($remoteData['names.specimens']); 
		$data->specimensTotal = _getSpecimensTotal($services['names.specimens']);
		$pageBody .= _printSpecimensTaxon(_parseSpecimensTaxon($data, ['showAll']));
	}
	
	if (!empty($remoteData['specimen'])) {
		$data = json_decode($remoteData['specimen']); 
		$pageBody .= _printSpecimens(_parseSpecimens($data, ['showAll']));
	}
    return $pageHeader .  _printDebug() . 
    	(!empty($pageBody) ? $pageBody : '<p>' . _printNoResults() . '</p>');
}

/**
 * Sets url to search form
 *
 * Used to create links back to search form; differentiates between home and
 * geographic search page
 *
 * @return string Url to last used form
 */
function _setStartUrl () {
    if (_isGeoSearch()) {
        return _setBasePath() . "geographic-search/";
    }
    return _setBasePath();
}

/**
 * Sets base url
 *
 * Sometimes Drupal home is not accessible at the site root; this function returns the
 * base of of the Drupal installation
 *
 * @return string Url to Drupal root
 */
function _setBasePath () {
    global $base_root, $base_path;
    return $base_root . $base_path;
}

/**
 * Gets other specimens in "specimen collection" (Brahms)
 *
 * @param array $row Other specimens in set section of NBA response
 * @return array|void Array with other specimens
 */
function _getOtherSpecimens ($data) {
	if (isset($data->assemblageID) && !empty($data->assemblageID)) {
		// This information is not present anymore in v2, we must query ourselves
		$client = _initNbaClient();
		try {
		    $condition = new Condition('assemblageID', 'EQUALS', $data->assemblageID);
		    if (_naturalisOnly() == 1) {
                $condition->setAnd(_naturalisOnlyCondition());
		    }
		    $query = new QuerySpec();
			$query
			    ->addCondition($condition)
				->setConstantScore();
			_addDebugMessage('other specimens in assemblage', $query);
			$result = json_decode($client->specimen()->setQuerySpec($query)->query());
		} catch (Exception $e) {
			_setErrorMessage($e);
		}
		if (isset($result->totalSize) && $result->totalSize > 1) {
			foreach ($result->resultSet as $specimen) {
				if ($specimen->item->unitID != $data->unitID) {
					$s = [];
					$s['unitID'] = $specimen->item->unitID;
					$s['collectionType'] = $specimen->item->collectionType;
// 					$s['url'] = _getSpecimenInCollectionUrl(
// 						$specimen->item, 
// 						$data->scientificNameGroup
// 					);
					$s['url'] = _setBasePath() . 'specimen/' . urlencode($specimen->item->unitID);
					$c[] = $s;
				}
			}
		}
	}
	return isset($c) ? $c : null;
}

/**
 * Logs searches to Drupal
 *
 * Agregates data from search form (as SESSION data) and stores search and
 * user data in json file for use in Kibana. Optiionally the same datab can
 * also be saved to the Drupal database (search_log content type).
 *
 *  * @param boolean $saveToDb When provided, data is also saved to database
 */
function _logSearch ($saveToDb = false) {
    foreach ($_SESSION['nbaSearch'] as $k => $v) {
        $skip = array(
            'op', 'form_build_id', 'form_token', 'form_id'

        );
        if (in_array(strtolower($k), $skip) ||
            $k == 'geoShape' && !empty($_SESSION['nbaSearch']['gid'])) {
            continue;
        }
        $data['field_' . strtolower($k)] = $v;
    }
    $data['field_timestamp'] = date('Y-m-d H:i:s');
    $data['field_ip_address'] = $_SERVER['REMOTE_ADDR'];
    $data['field_user_agent'] = $_SERVER['HTTP_USER_AGENT'];
    $data['field_search_type'] = _isGeoSearch() ? 'geo ' :
        (empty($data['field_term']) ? 'advanced' : 'simple');
    $file = variable_get('ndabioresults_config_log', NBALOG); // "/tmp/bioportal.log.json";
    file_put_contents($file, json_encode(['bioportal' => ['production' => removeEmptyFromArray($data)]]) . "\r\n", FILE_APPEND);

    if ($saveToDb) {
        $node = new stdClass();
        $node->title = $data['field_search_type'] . ' | '. $data['field_ip_address'] .
                ' | ' . $data['field_timestamp'];
        $node->type = "search_log";
        node_object_prepare($node);

        $node->language = LANGUAGE_NONE; // Or 'en' if locale is enabled
        $node->uid = $user->uid;
        $node->status = 0; //(1 or 0): published or not
        $node->promote = 0; //(1 or 0): promoted to front page
        $node->comment = 0; // 0 = comments disabled
        foreach ($data as $k => $v) {
            if ($v != '') {
                $node->{$k}[$node->language][0]['value'] = $v;
            }
        }
        $node = node_submit($node); // Prepare node for saving
        node_save($node);
    }
}

/**
 * Removes empty values from array
 * 
 * @param array $array
 * @return array
 */
function removeEmptyFromArray (&$array)
{
    foreach ($array as $key => &$value){
        if (is_array($value)){
            $value = removeEmptyFromArray($value);
            if (!count($value)) {
                unset($array[$key]);
            }
        } else if (!strlen($value)) {
            unset($array[$key]);
        }
    }
    return $array;
}


/**
 * Checks if any search parameters have been set for a service
 *
 * @param string $service Service
 * @return boolean
 */
function _serviceUsed ($service) {
    return _countSearchParameters($service) > 0;
}


/**
 * Checks if data has been posted
 *
 * Takes the $services array from form submission and checks if any field contains data
 *
 * @param array $services
 * @return boolean
 */
function _dataPosted ($services) {
    foreach ($services as $data) {
        if (!empty($data)) {
            return true;
        }
    }
    return false;
}



/**
 * Filters input parameters from advanced search
 *
 * Input parameters in advanced search form are prefixed with s_, t_, or m_
 * to differentiate between specimen, taxon and multimedia searches. This function
 * creates a new array of input parameters, filtering empty values and stripping
 * the prefix from the input.
 *
 * @param array $post The input as key => value pairs
 * @param string $typeId The input prefix (s_, t_, m_)
 *
 * @return array|void Filtered key => value pairs
 */
function _setSectionParameters (array $terms, $typeId = '') {
    if ($typeId == '') {
        return $terms;
    }
    $d = [];
    foreach ($terms as $k => $v) {
    	if (strpos($k, $typeId) === 0 && is_array($v)) {
    		$d[str_replace($typeId, '', $k)] = array_map('trim', $v);
    	} else if (strpos($k, $typeId) === 0 && (!empty($v) || is_numeric($v))) {
            $d[str_replace($typeId, '', $k)] = trim($v);
        }
    }
    // Append geoShape if entered
    if (isset($terms['geoShape']) && !empty($terms['geoShape']) &&
        in_array($typeId, ['m_', 's_'])) {
        $d['geoShape'] = $terms['geoShape'];
    }
    // Same for gid
    if (isset($terms['gid']) && !empty($terms['gid']) &&
        in_array($typeId, ['m_', 's_'])) {
        $d['gid'] = _setNbaGid($terms['gid']);
    }
    // We have a valid query!
    if (_countSearchParameters($d) >= 1) {
    	// Rewrite andOr to logicalOperator
        $d['logicalOperator'] = $d['andOr'] == 0 ? 'AND' : 'OR';
        $d['from'] = isset($d['from']) ? $d['from'] : 0;
        unset($d['andOr']);
        return $d;
    }
    // If only andOr flag is set, nothing has been entered;
    // return empty array
    return [];
}

/**
 * Calculates the number of search parameters excluding flags (andOr etc)
 *
 * @param array $d Search parameter
 * @return int Number of search items
 */
function _countSearchParameters ($d) {
    foreach ($d as $k => $v) {
        if (in_array($k, _searchFlags())) {
            unset($d[$k]);
        }
    }
    return count($d);
}



/**
 * Checks if multimedia at specific url is mp4 file
 *
 * Visits url and checks headers. Movie files should be treated differently
 * from image files.
 *
 * @param string $url Url to multimedia file
 * @return boolean
 */
function _isMp4 ($url) {
	if ($url) {
	    $headers = get_headers($url);
	    foreach ($headers as $i => $v) {
	        if (strpos($v, 'mp4') !== false) {
	            return true;
	        }
	    }
	}
    return false;
}




/**
 * Determines if prettyPhoto library should be loaded
 *
 * Alternate function for parse_url that preserves periods and other special
 * characters in parameter names
 *
 * @param array $target Output
 * @param string $source Input
 * @return array
 */
function _loadPrettyPhoto ($imageUrl) {
    $maxWidth = $maxHeight = 600;
    $img = getimagesize($imageUrl);
    if ($img && $img[0] > $maxWidth || $img[1] > $maxHeight) {
        $path = drupal_get_path('module', 'ndabioresults');
        drupal_add_css($path . "/css/prettyPhoto.css");
        drupal_add_js($path . "/js/jquery.prettyPhoto.js");
        drupal_add_js(
            'jQuery(document).ready(function($){
                $("a[rel^=\'prettyPhoto\']").prettyPhoto({
                    social_tools: false
                });
            });',
            array('type' => 'inline', 'scope' => 'footer'));
    }
    if (!$img) {
        return array(0, 0);
    }
    if ($img[0] < $maxWidth && $img[1] < $maxHeight) {
        return array($img[0], $img[1]);
    }
    if ($img[0] > $maxWidth && $img[0] >= $img[1]) {
        return array($maxWidth, round($img[1] * $maxWidth / $img[0]));
    }
    if ($img[1] > $maxHeight && $img[1] >= $img[0]) {
        return array(round($img[0] * $maxHeight / $img[1]), $maxHeight);
    }
}



/**
 * Translates NBA fields (usually ABCD/DC) to proper English
 *
 * Uses Drupal nba2text Taxonomy for translation
 *
 * @param string $str Input string
 * @return string Translated string
 */
function _translateNdaField ($str) {
    $machine_name = "nba2text";
    $myvalue = taxonomy_get_term_by_name($str, $machine_name);
    if (is_array($myvalue)) {
        $myvalues = array_shift($myvalue);
        if(!empty($myvalues)) {
            return t($myvalues->description);
        }
    }
    return t($str);
}

/*
function _nba_redirect_old_links ($url) {
	// die($url);
}
*/
