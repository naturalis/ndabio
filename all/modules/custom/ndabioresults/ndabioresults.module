<?php

/**
 * @file
 * Naturalis example module.
 */

/**
 * Defaults.
 */
define('NATURALIS', 'taxonDetail');

/**
* DEFINE CUSTOM PAGES
*/

function gettaxonomyidbysystem($systemname) {
  $sql = "SELECT entity_id FROM {field_data_field_ndasystem} WHERE field_ndasystem_value = '$systemname'";
  return db_query($sql)->fetchField();
}

function gettaxonomybysystem($systemname) {
  //$sql = "SELECT description FROM {taxonomy_term_data} WHERE tid = " . gettaxonomyidbysystem($systemname) . "";
  $sql = "SELECT description FROM {taxonomy_term_data} WHERE name = '$systemname'";
  return t(db_query($sql)->fetchField());
}

/**
 * Implements hook_menu().
 */
function ndabioresults_menu() {
  global $language;

  $items['admin/config/naturalis/ndaresult'] = array(
    'title' => 'NDA result config',
    'description' => 'Configuration for Naturalis module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ndabioresults_config_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['nba/result/%'] = array(
    'page callback' => 'ndabioresults_pass',
    //'page arguments' => array(1), //0 = nda, 1 = pass, 2 = *.
    'load arguments' => array('%map', '%index'),
    'access callback' => TRUE,
  );
  $items['nba/result'] = array(
    'page callback' => 'ndabioresults_pass',
    //'page arguments' => array(1), //0 = nda, 1 = pass, 2 = *.
    'load arguments' => array('%map', '%index'),
    'access callback' => TRUE,
  );

  return $items;
}


function ndabioresults_config_form($form, &$form_state) {
  $form['ndabioresults_config'] = array(
    '#type' => 'fieldset',
    '#title' => t('Naturalis config')
  );

  //NBA Base URL
  $form['ndabioresults_config']['ndabioresults_config_baseurl'] = array(
    '#type' => 'textfield',
    '#title' => t('NBA base URL'),
    '#default_value' => variable_get('ndabioresults_config_baseurl', "http://nba.naturalis.nl/"),
    '#size' => 140,
    '#maxlength' => 200,
    '#description' => t('The base URL of the NBA.'),
    '#required' => TRUE
  );



  return system_settings_form($form);
}

/**
 * Implements hook_block_info().
 */
function ndabioresults_block_info() {
  $blocks['ndabioresults_collected_date'] = array(
    'info' => t('NBA: Search result collected'),
    'visibility' => BLOCK_VISIBILITY_LISTED,
    'pages' => "nba/result\nnba/result*",
    'region' => "sidebar_first",
    'status' => TRUE,
  );
  $blocks['ndabioresults_source'] = array(
    'info' => t('NBA: Search result source'),
    'visibility' => BLOCK_VISIBILITY_LISTED,
    'pages' => "nba/result",
    'region' => "sidebar_first",
    'status' => TRUE,
  );
  $blocks['ndabioresults_category'] = array(
    'info' => t('NBA: Search result category'),
    'visibility' => BLOCK_VISIBILITY_LISTED,
    'pages' => "nba/result\nnba/result*",
    'region' => "sidebar_first",
    'status' => TRUE,
  );
  $blocks['ndabioresults_back'] = array(
    'info' => t('NBA: Search result back button'),
    'visibility' => BLOCK_VISIBILITY_LISTED,
    'pages' => "nba/result\nnba/result*",
    'region' => "sidebar_first",
    'status' => TRUE,
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function ndabioresults_block_view($delta = '') {
  global $base_root, $base_path;
  $block = array();

  $_link_enabled =  array('attributes' => array('class' => 'filter-enabled'));
  $_link_disabled =  array('attributes' => array('class' => 'filter-disabled'));
  $_link_active =  array('attributes' => array('class' => 'filter-active'));

  switch ($delta) {
    case 'ndabioresults_collected_date':
      $block['subject'] = t('Collection date');

      $block['content'] =
        _list_items( array(
          _item(array('All periods','filter-selected')),
          _item(array('After 2010' ,'filter-enabled')),
          _item(array('Before 2010','filter-enabled')),
          _item(array('custom'     ,'filter-enabled','')),
        ));

      break;

    case 'ndabioresults_source':
      $block['subject'] = t('Sources');

      $block['content'] =
        _list_items( array(
          _item(array('Naturalis',          'filter-selected')),
          _item(array('the Netherlands',    'filter-disabled')),
          _item(array('Worldwide & the Web','filter-disabled')),
        ));

      break;

    case 'ndabioresults_category':
      $block['subject'] = t('Categories');

      $block['content'] =
        _list_items( array(
          _item(array('Multimedia'  ,'filter-selected')),
          _item(array('Taxons'      ,'filter-selected')),
          _item(array('Specimen'    ,'filter-selected')),
          _item(array('Observations','filter-disabled')),
        ));

      break;

	case 'ndabioresults_back':
      $block['subject'] = t('Back to search');

      $starturl = $base_root . $base_path;
      if (isset($_SESSION['ndaSearch']['geoShape'])) $starturl .= "geographic-search/";

      $block['content'] = "<a href='" . $starturl . "?searchagain=1'>" . t('Back to search') . "</a>";

      break;
  }
  return $block;
}

function _list_items($arr_items){

  $str_return = "<ul class='no-bullets'>";

  foreach($arr_items as $item){
    $str_return .=
       "<li>"
      ."  <a class='".$item['class']."'>"
      .     $item['data']
      ."  </a>"
      ."</li>";
  }

  $str_return .= "</ul>";

  return $str_return;
}

function _item($arr_item){
  return array(
    'data' => $arr_item[0],
    'class' => $arr_item[1],
    'value' => isset($arr_item[2]) ? $arr_item[2] : null
  );
}




/**
 * Constant: base url of NBA service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function ndaBaseUrl() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'http://10.42.1.163:8080/nl.naturalis.nda.service.rest/api/';
    }
    return $var;
}

/**
 * Constant: search flags
 *
 * @return array
 */
function searchFlags() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array('andOr', 'sort', 'sortDirection', 'maxResults', 'offSet');
    }
    return $var;
}


/**
 * Constant: name of specimen service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function specimenService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'specimen/search';
    }
    return $var;
}

/**
 * Constant: name of specimen name service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function specimenNamesService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'specimen/name-search';
    }
    return $var;
}

/**
 * Constant: name of specimen detail service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function specimenDetailService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'specimen/get-specimen';
    }
    return $var;
}

/**
 * Constant: name of multimedia per specimen service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function specimenMultimediaService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'multimedia/get-multimedia-object-for-specimen-within-result-set';
    }
    return $var;
}

/**
 * Constant: name of taxon service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function taxonService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'taxon/search';
    }
    return $var;
}

/**
 * Constant: name of taxon detail service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function taxonDetailService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'taxon/get-taxon';
    }
    return $var;
}

/**
 * Constant: name of multimedia per taxon service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function taxonMultimediaService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'multimedia/get-multimedia-object-for-taxon-within-result-set';
    }
    return $var;
}

/**
 * Constant: name of multimedia service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function multimediaService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'multimedia/search';
    }
    return $var;
}

/**
 * Constant: order of search results output
 *
 * Determines print order of search result, currently
 * multimedia, taxon, specimen name, specimen.
 *
 * @return array
 */
function resultOrder() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	multimediaService(),
        	taxonService(),
        	specimenNamesService(),
        	specimenService()
        );
    }
    return $var;
}

/**
 * Mapping function: maps service to parse/print functions
 *
 * Each service response is handled by distinct parse and
 * print functions. This function provides the mapping.
 *
 * @return array Names of parse and print function for the service of choice
 */
function serviceToFunctions() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	taxonService() => array(
        		'parse' => 'parseTaxa',
        		'print' => 'printTaxa'
        	),
        	specimenNamesService() => array(
        		'parse' => 'parseSpecimensByTaxon',
        		'print' => 'printSpecimensByTaxon'
        	),
        	multimediaService() => array(
        		'parse' => 'parseMultimedia',
        		'print' => 'printMultimedia'
        	),
        	specimenService() => array(
        		'parse' => 'parseSpecimens',
        		'print' => 'printSpecimens'
        	),
        	specimenDetailService() => array(
        		'parse' => 'parseSpecimenDetail',
        		'print' => 'printSpecimenDetail'
        	),
        	taxonDetailService() => array(
        		'parse' => 'parseTaxonDetail',
        		'print' => 'printTaxonDetail'
        	),
        	taxonMultimediaService() => array(
        		'parse' => 'parseTaxonMediaDetail',
        		'print' => 'printTaxonMediaDetail'
        	),
        	specimenMultimediaService() => array(
        		'parse' => 'parseSpecimenMediaDetail',
        		'print' => 'printSpecimenMediaDetail'
        	)
        );
    }
    return $var;
}

/**
 * Mapping function: distributes parameters to appropriate specimen service
 *
 * Distributes specimens search parameters between specimen and specimen name
 * services. Important: list of parameters hould be complete!
 *
 * @param array $sP Search parameters
 * @param string $type Service type
 *
 * @return array Reduced array of search criteria for the service of choice
 */
function setSpecimenParameters (array $sP, $type) {
    $parameters = array(
        specimenService() => array(
            'collectingStartDate',
            'collectionFieldNumber',
            'gatheringAgent',
            'localityText',
            'phaseOrStage',
            'unitID',
            'sex',
            'taxonomicStatus',
            'typeStatus',
            'geoShape'
        ),
        specimenNamesService() => array(
            'className',
            'family',
            'genusOrMonomial',
            'kingdom',
            'order',
            'phylum',
            'speciesEpithet',
            'subspeciesEpithet',
            'vernacularName',
            'geoShape'
        )
    );
    foreach ($parameters[$type] as $p) {
        if (isset($sP[$p]) && (!empty($sP[$p]) || is_numeric($sP[$p]))) {
            $d[$p] = $sP[$p];
        }
    }
    // If any parameters are found, append andOr and geoShape (if applicable)
    if (isset($d)) {
        $d['_andOr'] = $sP['_andOr'];
        if (!empty($sP['geoShape'])) {
            $d['geoShape'] = $sP['geoShape'];
        }
    }
    return isset($d) ? $d : null;
}

/**
 * Accepts search form data and returns formatted result
 *
 * The main function that actually processes the incoming POST data, stores the
 * POST data in a SESSION, distributes the search to the appropriate channels
 * and returns the formatted output.
 *
 * @todo For the time being it just prints the appropriate NDA request urls on screen
 * plus displays mock data using DUMMYperformNdaRequest(). Adapt performNdaRequest() and
 * delete DUMMY functions.
 *
 * @return string The formatted output
*/
function ndabioresults_pass ($args = "") {
//    echo '<pre>'; print_r($_POST); echo '</pre>';

    // POST data from the search form?
    // If so, add to SESSION or replace existing SESSION data
    if (isset($_POST['form_id']) && $_POST['form_id'] == 'ndabio_advanced_taxonomysearch') {
        $_SESSION['ndaSearch'] = $_POST;
    }
    // GET data from within NDA response?
    // Forward directly to appropriate service
    else if (isset($_GET['nba_request'])) {

        return ndaDirectRequest(urldecode($_GET['nba_request']));
    }
    // If both POST and SESSION are empty we have a problem...
    else {
        // Probably best to redirect gracefully to search page?
        handleError('No POST data received! Form validation should trap this. Redirect to home if this occurs?');
    }
    // Redirect to distinct services
    return empty($_SESSION['ndaSearch']['term']) ? ndaAdvancedSearch() : ndaSimpleSearch();

    // This line returns mock data
    // TODO: Delete this line and DUMMY functions at the bottom once everything runs properly!
    // return DUMMYperformNdaRequest('all');
}

/**
 * Distributes search parameter of the simple search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output
 */
function ndaSimpleSearch () {
    $p = array(
        '_search' => $_SESSION['ndaSearch']['term'],
    );
    // Taxon search does not include geoShape and should not be invoked when coming from geo form!
    if (!isset($_SESSION['ndaSearch']['gid'])) {
        $services[taxonService()] = $p;
    }
    // Other searches do include geoShape if entered
    if (isset($_SESSION['ndaSearch']['geoShape']) && !empty($_SESSION['ndaSearch']['geoShape'])) {
        $p['geoShape'] = $_SESSION['ndaSearch']['geoShape'];
        $p['_andOr'] = 'AND';
    };
    foreach (array(specimenService(), specimenNamesService(), multimediaService()) as $request) {
        $services[$request] = $p;
    }
    return performNdaRequest(setChannels($services));
}

/**
 * Distributes search parameters of the advanced search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output
 */
function ndaAdvancedSearch () {
    $services[multimediaService()] = setSectionParameters($_SESSION['ndaSearch'], 'm_');
    $services[taxonService()] = setSectionParameters($_SESSION['ndaSearch'], 't_');
    // Subdivide specimen parameters for both result types
    $sP = setSectionParameters($_SESSION['ndaSearch'], 's_');
    $services[specimenService()] = setSpecimenParameters($sP, specimenService());
    $services[specimenNamesService()] = setSpecimenParameters($sP, specimenNamesService());
p($services);
    return performNdaRequest(setChannels($services));
}

/**
 * @todo: check base url!!
 * @param unknown $r
 */
function ndaDirectRequest ($r) {
    foreach (serviceToFunctions() as $service => $d) {
        if (strpos($r, $service) !== false) {
            $url = parse_url($r);
            parse_str($url['query'], $q);
            $channels[0]['request'] = $service;
    		$channels[0]['url'] = ndaBaseUrl() . $service;
    		$channels[0]['post'] = 1;
    		$channels[0]['postfields'] = http_build_query($q);
    		return performNdaRequest($channels);
        }
    }
    return array();
}


/**
 * Sets curl channels
 *
 * Sets request and url parameters for curl channels
 *
 * @param array Service array (service name => search parameters)
 *
 * @return void|array Channels for curl
 */
function setChannels (array $services) {
    $i = 0;
	foreach ($services as $s => $p) {
	    if (!empty($p)) {
	        $p = array_filter($p, 'strlen');
    		$channels[$i]['request'] = $s;
    		$channels[$i]['url'] = ndaBaseUrl() . $s;
    		$channels[$i]['post'] = count($p);
    		$channels[$i]['postfields'] =  http_build_query($p);
    		$i++;
	    }
	}
	return isset($channels) ? $channels : array();
}

/**
 * Filters input parameters from advanced search
 *
 * Input parameters in advanced search form are prefixed with s_, t_, or m_
 * to differentiate between specimen, taxon and multimedia searches. This function
 * creates a new array of input parameters, filtering empty values and stripping
 * the prefix from the input.
 *
 * @param array $post The input as key => value pairs
 * @param string $typeId The input prefix (s_, t_, m_)
 *
 * @return void|array Filtered key => value pairs
 */
function setSectionParameters (array $post, $typeId = '') {
    if ($typeId == '') {
        return $post;
    }
    $d = array();
    foreach ($post as $k => $v) {
        if (strpos($k, $typeId) === 0 && (!empty($v) || is_numeric($v))) {
            $d[str_replace($typeId, '', $k)] = $v;
        }
    }
    // Append geoShape if entered
    if (isset($post['geoShape']) && !empty($post['geoShape']) &&
        in_array($typeId, array('m_', 's_'))) {
        $d['geoShape'] = $post['geoShape'];
    }
    if (countSearchParameters($d) >= 1) {
        // Reset andOr parameter to _andOr and values to and/or
        $d['_andOr'] = $d['andOr'] == 0 ? 'AND' : 'OR';
        unset($d['andOr']);
        return $d;
    }
    // If only andOr flag is set, nothing has been entered;
    // return empty array
    return array();
}

/**
 * Calculates the number of search parameters excluding flags (andOr etc)
 *
 * @param array $d Search parameter
 * @return Number of search items
 */
function countSearchParameters ($d) {
    foreach ($d as $k => $v) {
        if (in_array($k, searchFlags())) {
            unset($d[$k]);
        }
    }
    return count($d);
}


/**
 * Performs curl requests and formats results
 *
 * Performs curl queries through multicurl. For each channel, resulting json is
 * parsed to an array by one function and subsequently printed by another.
 *
 * @todo Remove drupal_set_message() that temporarily simply prints the resulting
 * NBA urls
 *
 * @param array $channels Service channels
 * @return void|string
 */
function performNdaRequest (array $channels = array()) {
    // Debug: print queries
    drupal_set_message('<pre>' . print_r($channels, true) . '</pre>');
    //return;

	if (empty($channels)) {
		handleError('Cannot set curl channels');
	}
	// Get json response(s) with curl
	$remoteData = queryNda($channels);
	// Reorder responses in print order if more than one response
	if (count($remoteData) > 1) {
	   $remoteData = sortArrayByArray($remoteData, resultOrder());
	}
	// Map functions to each channel result:
	// parses and prints data
	$output = '';
	$serviceToFunctions = serviceToFunctions();
	foreach ($remoteData as $service => $json) {
		if (!isset($serviceToFunctions[$service]) || empty($json)) {
			continue;
		}
		$parseFunction = $serviceToFunctions[$service]['parse'];
		$printFunction = $serviceToFunctions[$service]['print'];
		$output .= $printFunction($parseFunction($json));
	}
	return $output;
}

/**
 * Performs multicurl queries
 *
 * Core function for multicurl requests
 *
 * @param unknown $channels Service channels
 * @param integer $timeout Optional timeout
 *
 * @return array Results as key => value pairs for each channel
 */
function queryNda ($channels = array(), $timeout = false) {
    $mh = curl_multi_init();
    for ($i = 0; $i < count($channels); $i++) {
        $ch[$i] = curl_init();
        /*
         * POST did not return data, currently switching to GET
         * @todo: check if posting large areas does not break GET
         *
        curl_setopt($ch[$i], CURLOPT_URL, $channels[$i]['url']);
        curl_setopt($ch[$i], CURLOPT_POST, $channels[$i]['post']);
        curl_setopt($ch[$i], CURLOPT_POSTFIELDS, $channels[$i]['postfields']);
        */
        $channels[$i]['url'] .= '/?'  . $channels[$i]['postfields'];

//echo '<pre>'; print_r( $channels[$i]); echo '</pre>';


        curl_setopt($ch[$i], CURLOPT_URL, $channels[$i]['url']);
        curl_setopt($ch[$i], CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch[$i], CURLOPT_HEADER, false);
        if ($timeout) {
       		curl_setopt($ch[$i], CURLOPT_TIMEOUT, $timeout);
        }
        curl_multi_add_handle($mh, $ch[$i]);
    }
    // While we're still active, execute curl
	do {
		$mrc = curl_multi_exec($mh, $active);
	} while ($mrc == CURLM_CALL_MULTI_PERFORM);

    while ($active && $mrc == CURLM_OK) {
        // Wait for activity on any curl-connection
        if (curl_multi_select($mh) == -1) {
            usleep(1);
        }
        // Continue to exec until curl is ready to
        // give us more data
        do {
            $mrc = curl_multi_exec($mh, $active);
        } while ($mrc == CURLM_CALL_MULTI_PERFORM);
    }
    // Place results in results array and close handlers
    for ($i = 0; $i < count($channels); $i++) {
        $remoteData[$channels[$i]['request']] = curl_multi_getcontent($ch[$i]);
        curl_multi_remove_handle($mh, $ch[$i]);
    }
    curl_multi_close($mh);
//echo '<pre>'; print_r($remoteData); echo '</pre>';
    return $remoteData;
}





function parseSpecimenMediaDetail ($json) {
	if (!$json || !validJson($json)) {
		handleError('No or invalid json response');
	}
	$data = json_decode($json);
	$row = $data->searchResults[0];

	$output['source'] = $row->result->specimen->sourceSystem->name;
	$output['navigation'] = getNavigation($data);
	$output['names'] = getSpecimenMediaTaxonNames($row);
	$output['unitID'] = $row->result->specimen->unitID;
	$output['title'] = $row->result->title;
	$output['caption'] = $row->result->caption;
	$output['imgSrc'] = getImageUrl($row);

//echo '<pre>'; print_r($output); echo '</pre>';
	return $output;
}


function getSpecimenMediaTaxonNames ($row) {
	foreach ($row->result->scientificNames as $i => $name) {
		$output[] = array(
			'name' => formatScientificName(
				$name->fullScientificName,
				$name
			),
			'url' => getSpecimenMediaTaxonUrl($row, $i)
		);
	}
	return isset($output) ? $output : false;
}


function getSpecimenMediaTaxonUrl ($row, $i) {
	if (!empty($row->links)) {
		foreach ($row->links as $link) {
			if ($link->rel == "scientificnames[{$i}].fullScientificName") {
				return $link->href;
			}
		}
	}
	return null;
}

include 'printSpecimenMediaDetail.php';


function parseTaxonMediaDetail ($json) {
	if (!$json || !validJson($json)) {
		handleError('No or invalid json response');
	}
	$data = json_decode($json);
	$row = $data->searchResults[0];
	$output['source'] = $row->result->taxon->sourceSystem->name;
	$output['acceptedName'] = formatScientificName(
		$row->result->scientificNames[0]->fullScientificName,
		$row->result->scientificNames[0]
	);
	$output['navigation'] = getNavigation($data);
	$output['title'] = $row->result->title;
	$output['caption'] = $row->result->caption;
	$output['imgSrc'] = getImageUrl($row);
//echo '<pre>'; print_r($output); echo '</pre>';
	return $output;
}


include 'printTaxonMediaDetail.php';


// Parses taxon detail json response into array
function parseTaxonDetail ($json) {
	$skipFields = array(
		'objectPublic'
		// etc
	);
	if (!$json || !validJson($json)) {
		handleError('parseTaxonDetail: no or invalid json response');
	}
	$data = json_decode($json);
p($data);
	$output['acceptedName'] = formatScientificName(
		$data->searchResults[0]->result->acceptedName->fullScientificName,
		$data->searchResults[0]->result->acceptedName
	);
	$output['navigation'] = getNavigation($data);
	foreach ($data->searchResults as $row) {
		$source = $row->result->sourceSystem->name;

		if (!empty($row->result->defaultClassification)) {
			$output['classifications']['default'][$source] =
				$row->result->defaultClassification;
		}
		if (!empty($row->result->systemClassification)) {
			$output['classifications']['system'][$source] =
				$row->result->systemClassification;
		}
		if (!empty($row->result->synonyms)) {
			foreach ($row->result->synonyms as $i => $synonym) {
				$output['synonyms'][$source] = formatScientificName(
					$row->result->synonyms[$i]->fullScientificName,
					$row->result->synonyms[$i]
				);
			}
		}
		if (!empty($row->result->descriptions)) {
			foreach ($row->result->descriptions as $i => $description) {
				$output['descriptions'][$description->language][$source] =
					$description->description;
			}
		}
		if (!empty($row->result->commonNames)) {
			foreach ($row->result->commonNames as $i => $name) {
				$output['commonNames'][$name->language][$source] =
					$name->name;
			}

		}
	}
	return $output;
}

include 'printTaxonDetail.php';


// function printTaxonDetail ($data) {
//   global $language;
//
//   $output .= "<div class='large-7 columns'>";
//
//   $output .= "<h2>" . $data['acceptedName'] . " <span class='populair-name'>" .
//     (isset($data['commonNames'][$language->language]) ?
//       implode(', ', $data['commonNames'][$language->language]) : '') .
//     "</span></h2>";
//
//   $output .=
//      printCommonNames($data)
//     .printDescriptions($data)
//     .printClassifications($data);
//
//   $output .= "</div>";
//
//   $output .= "<div class='large-3 columns'>";
//   $output .=    printNavigation($data) .
//   $output .= "</div>";
//
//   return $output;
// }

include 'printCommonNames.php';

include 'printDescriptions.php';

include 'printClassifications.php';


// Parses specimen detail json response into array
function parseSpecimenDetail ($json) {
	$skipFields = array(
		'objectPublic'
		// etc
	);
	if (!$json || !validJson($json)) {
		handleError('parseSpecimenDetail : no or invalid json response');
	}
	$data = json_decode($json);
	foreach ($data->searchResults[0]->result as $field => $value) {
		if (!is_array($value) && !is_object($value) &&
			!in_array($field, $skipFields) && $value != '') {
			$output[t(translateNdaField($field))] = $value;
		}
	}
	$output['source'] = isset($data->searchResults[0]->result->sourceSystem) ?
	   $data->searchResults[0]->result->sourceSystem->name : '';
	$output['names'] = getSpecimenTaxonNames($data->searchResults[0]);
	$output['gatheringEvent'] = getGatheringEventSpecimens($data);
	$output['otherSpecimens'] = getOtherSpecimens($data);
	$output['navigation'] = getNavigation($data);
//p($output);
    return $output;
}


// Return previous/next links from result set
function getNavigation ($data) {
	if (isset($data->links) && !empty($data->links)) {
		foreach ($data->links as $link) {
			if ($link->rel == 'prev' || $link->rel == 'next') {
				$output[$link->rel] = $link->href;
			}
		}
	}
	return isset($output) ? $output : null;
}

include 'printSpecimenDetail.php';

include 'printNavigation.php';

include 'printNamesWithLinks.php';

// Return other specimens for detail page
function getOtherSpecimens ($row) {
	if (!empty($row->searchResults[0]->result->otherSpecimensInSet)) {
		foreach ($row->searchResults[0]->result->otherSpecimensInSet as $i => $specimen) {
			$s = array();
			$s['unitID'] = $specimen->unitID;
			$s['collectionType'] = $specimen->collectionType;
			$s['url'] = getSpecimenInCollectionUrl($row, $i);
			$c[] = $s;
		}
	}
	return isset($c) ? $c : null;
}

// Return gathering event data for detail page
function getGatheringEventSpecimens ($row) {
	if (!empty($row->searchResults[0]->result->gatheringEvent)) {
        $event = $row->searchResults[0]->result->gatheringEvent;
		foreach ($event as $k => $v) {
		    if (!is_array($v) && !is_object($k) && $v != '') {
                $d[$k] = $v;
		    }
		}
		if (!empty($event->gatheringAgents)) {
		    foreach ($event->gatheringAgents as $a) {
                $agent[] = $a->fullName . (!empty($a->organization) ?
                    ' (' . $a->organization . ')' : '');
		    }
		    $d['gatheringAgents'] = $agent;
		}
		if (!empty($event->siteCoordinates)) {
		    foreach ($event->siteCoordinates as $c) {
                if ($c->longitudeDecimal != 0 && $c->latitudeDecimal != 0) {
                    $coordinates['lat'] = $c->latitudeDecimal;
                    $coordinates['lon'] = $c->longitudeDecimal;
                }
		    }
		    $d['siteCoordinates'] = isset($coordinates) ?
		        $coordinates : null;
		}
	}
	return isset($d) ? $d : null;
}


include 'printTableRow.php';



// Parses multimedia json response into array
function parseMultimedia ($json) {
	if (!$json || !validJson($json)) {
		handleError('parseMultimedia: no or invalid json response');
	}
	$data = json_decode($json);
//echo '<pre>'; print_r($data); echo '</pre>';
	$output['searchTerms'] = getSearchTerms($data);
	if (!$output['searchTerms']) {
		handleError('parseMultimedia: invalid json response');
	}
	$output['total'] = getTotalRows($data);
	foreach ($data->searchResults as $row) {
		$type = !empty($row->result->associatedTaxon) ? 'associatedTaxon' :
            'associatedSpecimen';
		$d['title'] = $row->result->title;
		$d['caption'] = $row->result->caption;
		$d['score'] = $row->score;
		$d['url'] = getMultimediaDetailLink($row);
		$d['source'] = !empty($row->result->{$type}->sourceSystem) ?
            $row->result->{$type}->sourceSystem->name : '';
		$d['imgSrc'] = getImageUrl($row);
		$d['hits'] = getHits($row);
		$output['results'][] = $d;
	}
//echo '<pre>'; print_r($output); echo '</pre>';
	return isset($output) ? $output : false;
}


function getMultimediaDetailLink ($row) {
    foreach ($row->links as $link) {
        if ($link->rel == '_multimedia') {
            return $link->href;
        }
    }
}

include 'printMultimedia.php';
include 'printMatches.php';

// Returns specimens searched for other fields but taxon
function parseSpecimens ($json) {
	if (!$json || !validJson($json)) {
		handleError('parseSpecimens: no or invalid json response');
	}
	$data = json_decode($json);
//p($data);
	$output['searchTerms'] = getSearchTerms($data);
	$output['total'] = getTotalRows($data);
	if (!$output['searchTerms']) {
		handleError('parseSpecimens: invalid json response');
	}
	if ($output['total'] == 0) {
	    $output['results'] = array();
        return $output;
	}
	foreach ($data->searchResults as $row) {
		$d = array();
		$d['unitID'] = $row->result->unitID;
		$d['url'] = $row->links[0]->href;
		$d['hits'] = getHits($row);
		$d['source'] = $row->result->sourceSystem->name;
		$d['score'] = $row->score;
		$d['names'] = getSpecimenTaxonNames($row);
		$output['results'][] = $d;
	}
	return isset($output) ? $output : false;
}

include 'printSpecimens.php';

include 'printHits.php';

include 'printSpecimenTaxa.php';


// Returns taxon names for specimens plus their url found by other fields but name
// (for specimens found by taxon name only a single name is returned!)
function getSpecimenTaxonNames ($row) {
    if (!isset($row->result->identifications) || empty($row->result->identifications)) {
        return array();
    }
	foreach ($row->result->identifications as $i => $id) {
		$output[] = array(
			'name' => formatScientificName(
				$id->scientificName->fullScientificName,
				$id->scientificName
			),
			'url' => getSpecimenTaxonUrl($row, $i)
		);
	}
	return isset($output) ? $output : false;
}


// Returns url for a taxon associated with the specimen
function getSpecimenTaxonUrl ($row, $i) {
	if (!empty($row->links)) {
		foreach ($row->links as $link) {
			if ($link->rel == "identifications[{$i}].scientificName.fullScientificName") {
				return $link->href;
			}
		}
	}
	return null;
}



// Parses specimen json response into array; searched by taxon
function parseSpecimensByTaxon ($json) {
	if (!$json || !validJson($json)) {
		handleError('parseSpecimensByTaxon: no or invalid json response');
	}
	$data = json_decode($json);
//p($data);
	$output['searchTerms'] = getSearchTerms($data);
	$output['total'] = getTotalRows($data);
	if (!$output['searchTerms']) {
		handleError('parseSpecimensByTaxon: invalid json response');
	}
	if ($output['total'] == 0) {
	    $output['results'] = array();
        return $output;
	}
	foreach ($data->resultGroups as $row) {
		$d = array();
		$d['name'] = formatScientificName(
			$row->sharedValue,
		    // @todo
			//$row->searchResults[0]->result->identifications[getResultOffset($row)]->scientificName,
			$row->searchResults[0]->result->identifications[0]->scientificName,
		    $output['searchTerms']
		);
		$d['url'] = isset($row->links[0]->href) ? $row->links[0]->href : null;
		$d['count'] = count($row->searchResults);
		$d['sources'] = getSources($row);
		$d['score'] = $row->searchResults[0]->score;
		foreach ($row->searchResults as $i => $sp) {
    		$assemblageID = $sp->result->assemblageID;
    		$s['unitID'] = $sp->result->unitID;
    		$s['collectionType'] = $sp->result->collectionType;
    		$s['url'] = $sp->links[0]->href;
            empty($assemblageID) ? $d['specimens'] = $s : $d['sets'][$assemblageID][] = $s;
		}
		$output['results'][] = $d;
	}
	return isset($output) ? $output : false;
}



// Returns image properties
function getImageUrl ($row) {
	$key = key(get_object_vars($row->result->serviceAccessPoints));
	return $row->result->serviceAccessPoints->{$key}->accessUri;
}


// Return the field containing the hit
function getHits ($row) {
	foreach ($row->matchInfo as $info) {
		$e = explode('.', $info->path);
		$hits[end($e)] = $info->valueHighlighted;
	}
	return isset($hits) ? $hits : array();
}

include 'printSpecimensByTaxon.php';

include 'printSpecimenCollection.php';



// Shorthand function to pad "filler" tds
function padTds ($i) {
	if ((int)$i > 0) {
		return str_repeat("<td></td>", $i);
	}
}

// Return url for specimens in "collection"/set
function getSpecimenInCollectionUrl ($row, $i) {
	if (!empty($row->searchResults[0]->links)) {
		foreach ($row->searchResults[0]->links as $link) {
			if ($link->rel == 'specimen-detail.otherSpecimensInSet.' . $i) {
				return $link->href;
			}
		}
	}
	return null;
}

include 'printHeaders.php';


// Parses taxon/species json response into array
function parseTaxa ($json) {
	if (!$json || !validJson($json)) {
		handleError('parseTaxon: no or invalid json response');
	}
	$data = json_decode($json);

	$output['total'] = getTotalRows($data);
	$output['searchTerms'] = getSearchTerms($data);
	if (!$output['searchTerms']) {
		handleError('parseTaxon: invalid json response');
	}
	foreach ($data->resultGroups as $row) {
		$d = array();
		// Accepted scientific name, synonym, or common name
		$d['type'] = getResultType($row);
		if ($d['type'] == 'accepted') {
			$d['name'] = formatScientificName(
				$row->searchResults[0]->matchInfo[0]->value,
				$row->searchResults[0]->result->acceptedName,
				$output['searchTerms']
			);
		} else if ($d['type'] == 'synonym') {
			$d['name'] = formatScientificName(
				$row->searchResults[0]->matchInfo[0]->value,
				$row->searchResults[0]->result->synonyms[getResultOffset($row)]->scientificName,
				$output['searchTerms']
			);
		} else if ($d['type'] == 'common') {
			$d['name'] = highlightSearchTerms(
				$row->searchResults[0]->matchInfo[0]->value,
				$output['searchTerms']
			);
		}
		$d['acceptedName'] = (
			$d['type'] == 'accepted' ?
			$d['name'] :
			formatScientificName(
				$row->searchResults[0]->result->acceptedName->fullScientificName,
				$row->searchResults[0]->result->acceptedName
			)
		);
		$d['rank'] = $row->searchResults[0]->result->taxonRank;
		$d['url'] = url_decode($row->links[0]->href);
		$d['sources'] = getSources($row);
		$d['commonNames'] = ($d['type'] != 'common' ? getCommonNames($row) : array());
		$d['score'] = $row->searchResults[0]->score;
		$output['results'][] = $d;
	}
echo 'Taxon object has to be changed in order to parse...<pre>'; print_r($data); echo '</pre>';
die();
	return isset($output) ? $output : false;
}


include 'printTaxa.php';


// Validates json string
function validJson ($string) {
	return is_object(json_decode($string));
}

// Returns type of result:
// acceptedName.fullScientificName
// acceptedName.synonyms[0].scientificName.fullScientificName
// acceptedName.commonNames[0].name
function getResultType ($row) {
	$path = $row->searchResults[0]->matchInfo[0]->path;
	return strpos($path, 'synonym') !== false ? 'synonym' :
		(strpos($path, 'commonName') !== false ? 'common' : 'accepted');
}

// Returns offset of result; used only for synonyms and common names
// to determine the array key containing the hit
// Used for taxon/specimenByTaxon
function getResultOffset ($row) {
	preg_match('/\[(.*?)\]/', $row->searchResults[0]->matchInfo[0]->path, $m);
	return $m[1];
}

// Returns total number of results
function getTotalRows ($data) {
	if (isset($data->totalSize)) {
		return (int)$data->totalSize;
	}
	return false;
}

// Returns total number of results
function getSearchTerms ($data) {
	if (isset($data->queryParameters)) {
		return (array)$data->queryParameters;
	}
	return false;
}

// Results formatted accepted name with proper use of italics
function formatScientificName ($scientificname, $nameObject, $searchTerms = false) {
	$output = $scientificname;
	$elements = getScientificNameElements($nameObject);
	foreach ($elements as $e) {
		if (!empty($e)) {
			$output = str_replace($e, '<span class="scientific">' . $e . '</span>', $output);
		}
	}
	// Highlight the formatted output
	return $searchTerms ? highlightSearchTerms($output, $searchTerms) : $output;
}

function highlightSearchTerms ($output, $searchTerms) {
    foreach ($searchTerms as $field => $value) {
        if (!in_array(str_replace('_', '', $field), searchFlags())) {
            $output = highlightMatch($output, $value);
        }
    }
    return $output;
}

// Returns scientific name elements from name object
// Store as keys and flip to avoid duplicates (as in Larus fuscus fuscus)
function getScientificNameElements ($name) {
	$elements = array(
		$name->genusOrMonomial => 0,
		$name->subgenus => 1,
		$name->specificEpithet => 2,
		$name->infraspecificEpithet => 3
	);
	return array_flip($elements);
}

// Returns all sources for taxon/specimen
function getSources ($row) {
	foreach ($row->searchResults as $i => $obj) {
		$output[$obj->result->sourceSystem->name] = $i;
	}
	return isset($output) ? array_flip($output) : false;
}

// Returns common names for the current interface language;
// format is array(name => language), so duplicates will be avoided
function getCommonNames ($row, $languageCheck = false) {
	global $language;
	foreach ($row->searchResults as $i => $taxon) {
		if (isset($taxon->result->commonNames)) {
			foreach ($taxon->result->commonNames as $name) {
				// If language is set, only store when language of
				// common name matches that of interface...
				if ($languageCheck) {
					if ($name->language == $language->language) {
						$output[$name->name] = $name->language;
					}
				// ... else always return all names
				} else {
					$output[$name->name] = $name->language;
				}
			}
		}
	}
	return isset($output) ? $output : false;
}


// Decorate description in taxon result table
function decorateDescription ($row) {
	return ($row['type'] != 'accepted' ?
		t(ucfirst($row['type'])) . ($row['type'] == 'common' ? ' ' . t('name') : '') .
		' ' . t('for') . ' ' :  '') . ($row['type'] == 'accepted' ? t(ucfirst($row['rank'])) :
		t($row['rank'])) . ' ' . $row['acceptedName'];
}

// Decorate score in result table
function decorateScore ($score) {
	$score = round($score * 100);
	$roundScore = round( $score / 20 );
  $result = "<span class='score' title='$score %'>";

  for ( $i=1; $i<=5; $i++ ){
    if ( $i <= $roundScore ){
      $result.= "<span class='square-filled'>&FilledSmallSquare;</span>";
    } else {
      $result.= "<span class='square-empty'>&EmptySmallSquare;</span>";
    }
  }

  $result .= "</span>";
  return $result;

  //return "<span class='score'><span class='score-bar' style='width: $score%'></span><span class='score-text'>$score%</span></span>";
}

// Highlight match
function highlightMatch($haystack, $needles) {
	foreach ($needles as $needle) {
		if (!is_string($needle) || stripos(strip_tags($haystack), $needle)===false || is_null($needle)) {
			continue;
		}
		$q = str_split($needle);
		$x = ')(\<[^<]*\>)*(';
		$q = str_replace('( )','(\s*)','('.implode($x, $q).')');
		$haystack = preg_replace_callback('/'.$q.'/i','_fsub1', $haystack);
	}
	return $haystack;
}

function _fsub1($m) {
	return "<span class='result-query'>".preg_replace_callback('(<(.*?)>)','_fsub2',$m[0])."</span>";
}

function _fsub2($m) {
	return '</span>'.$m[0]."<span class='result-query'>";
}

function sortArrayByArray ($array, $orderArray) {
    $ordered = array();
    foreach ($orderArray as $key) {
        if (array_key_exists($key,$array)) {
            $ordered[$key] = $array[$key];
            unset($array[$key]);
        }
    }
    return $ordered + $array;
}


// Wrapper for Drupal error handler
function handleError ($message) {
    die($message);
}


// Should be replaced with a function that translates NDS field labels to proper English
function translateNdaField ($str) {
	return $str;
}

// Create Drupal specific link
function printDrupalLink ($url) {
    global $base_root, $base_path;
    return $base_root . $base_path . 'nba/result?nba_request=' . urlencode($url);
}

function _markUp($string){
  $result = $string;
  $result = preg_replace('/^\s+|\n|\r|\s+$/m', '', $result);

  $result = str_replace(
    array("    <h2",  "<table",        "<thead",      "<tbody",      "<tr",        "<td",        "<th ",   "<a class='polaroid'"),
    array("\n\n<h2","\n\n<table","\n\n\t<thead","\n\n\t<tbody","\n\t\t<tr","\n\t\t\t<td","\n\t\t\t<th ", "\n<a class='polaroid' "),
    $result
  );

  $result = str_replace(
    array(  "</table",    "</thead",    "</tbody",     "</tr",        "</td",        "</th>"),
    array("\n</table","\n\t</thead","\n\t</tbody","\n\t\t</tr","\n\t\t\t</td","\n\t\t\t</th>"),
    $result
  );

  return $result;
}






/*
 * DUMMY functions to print mock data on screen. Please keep this at the bottom of this document
 * so these can removed easily once markup has been completed and NDA services run properly
 */
function DUMMYmapNdaRequests() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	'all' => 'group-taxa-by-name.json|groupSpecimenBySpecificName.json|getSpecimensForOtherSearchTerms.json|getMediaObjects.json',
        	'taxa' => 'group-taxa-by-name.json',
        	'specimensByTaxon' => 'groupSpecimenBySpecificName.json',
        	'specimens' => 'groupSpecimenBySpecificName.json',
        	'multimedia' => 'getMediaObjects.json',
        	'taxonDetail' => 'taxon-detail.json',
        	'specimenDetail' => 'specimen-detail.json',
        	'taxonMediaDetail' => 'taxon-media-detail.json',
        	'specimenMediaDetail' => 'specimen-media-detail.json'
        );
    }
    return $var;
}

function DUMMYresultOrder() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	'getMediaObjects.json',
        	'group-taxa-by-name.json',
        	'groupSpecimenBySpecificName.json',
        	'getSpecimensForOtherSearchTerms.json'
        );
    }
    return $var;
}

function DUMMYserviceToFunctions() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	'group-taxa-by-name.json' => array(
        		'parse' => 'parseTaxa',
        		'print' => 'printTaxa'
        	),
        	'groupSpecimenBySpecificName.json' => array(
        		'parse' => 'parseSpecimensByTaxon',
        		'print' => 'printSpecimensByTaxon'
        	),
        	'getMediaObjects.json' => array(
        		'parse' => 'parseMultimedia',
        		'print' => 'printMultimedia'
        	),
        	'getSpecimensForOtherSearchTerms.json' => array(
        		'parse' => 'parseSpecimens',
        		'print' => 'printSpecimens'
        	),
        	'specimen-detail.json' => array(
        		'parse' => 'parseSpecimenDetail',
        		'print' => 'printSpecimenDetail'
        	),
        	'taxon-detail.json' => array(
        		'parse' => 'parseTaxonDetail',
        		'print' => 'printTaxonDetail'
        	),
        	'taxon-media-detail.json' => array(
        		'parse' => 'parseTaxonMediaDetail',
        		'print' => 'printTaxonMediaDetail'
        	),
        	'specimen-media-detail.json' => array(
        		'parse' => 'parseSpecimenMediaDetail',
        		'print' => 'printSpecimenMediaDetail'
        	)
        );
    }
    return $var;
}

function DUMMYperformNdaRequest ($request = false) {
    $serviceToFunctions = DUMMYserviceToFunctions();
	// Translate request url to curl channels
	$channels = DUMMYsetChannels($request);
	if (empty($channels)) {
		handleError('Cannot set curl channels');
	}
	// Get json response(s) with curl
	$remoteData = DUMMYqueryNda($channels);
	// Reorder responses in print order if more than one response
	if (count($remoteData) > 1) {
	   $remoteData = sortArrayByArray($remoteData, DUMMYresultOrder());
	}
	// Map functions to each channel result:
	// parses and prints data
	$output = '';
	foreach ($remoteData as $service => $json) {
		if (!isset($serviceToFunctions[$service]) || empty($json)) {
			continue;
		}
		$parseFunction = $serviceToFunctions[$service]['parse'];
		$printFunction = $serviceToFunctions[$service]['print'];
		$output .= $printFunction($parseFunction($json));
	}
	return $output;
}


function DUMMYsetChannels ($request = false) {
	$mapNdaRequests = DUMMYmapNdaRequests();
	if (!$request || !isset($mapNdaRequests[$request])) {
		return false;
	}
	$t = explode('|', $mapNdaRequests[$request]);
	foreach ($t as $i => $url) {
		$channels[$i]['request'] = $url;
		$channels[$i]['url'] = 'http://dev2.etibioinformatics.nl/nda/' . $url;
	}
	return $channels;
}

function DUMMYqueryNda ($channels = array(), $timeout = false) {
    $mh = curl_multi_init();
    for ($i = 0; $i < count($channels); $i++) {
        $ch[$i] = curl_init();

$url = $channels[$i]['url'] . '/?'  . $channels[$i]['postfields'];
echo $url . "<br>";

        curl_setopt($ch[$i], CURLOPT_URL, $url);
        curl_setopt($ch[$i], CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch[$i], CURLOPT_HEADER, false);
        if ($timeout) {
       		curl_setopt($ch[$i], CURLOPT_TIMEOUT, $timeout);
        }
        curl_multi_add_handle($mh, $ch[$i]);
    }
    // While we're still active, execute curl
	do {
		$mrc = curl_multi_exec($mh, $active);
	} while ($mrc == CURLM_CALL_MULTI_PERFORM);

    while ($active && $mrc == CURLM_OK) {
        // Wait for activity on any curl-connection
        if (curl_multi_select($mh) == -1) {
            usleep(1);
        }
        // Continue to exec until curl is ready to
        // give us more data
        do {
            $mrc = curl_multi_exec($mh, $active);
        } while ($mrc == CURLM_CALL_MULTI_PERFORM);
    }
    // Place results in results array and close handlers
    for ($i = 0; $i < count($channels); $i++) {
        $remoteData[$channels[$i]['request']] = curl_multi_getcontent($ch[$i]);
        curl_multi_remove_handle($mh, $ch[$i]);
    }
    curl_multi_close($mh);

 print_r($remoteData); die();

    return $remoteData;
}

function p ($a) {
    echo '<pre>'; print_r($a); echo '</pre>';
}
