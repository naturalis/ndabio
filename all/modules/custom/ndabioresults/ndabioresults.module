<?php

/**
 * @file
 * Naturalis example module.
 */

/**
 * Defaults.
 */
define('NATURALIS', 'taxonDetail');

/**
* DEFINE CUSTOM PAGES
*/

function gettaxonomyidbysystem($systemname) {
  $sql = "SELECT entity_id FROM {field_data_field_ndasystem} WHERE field_ndasystem_value = '$systemname'";
  return db_query($sql)->fetchField();
}

function gettaxonomybysystem($systemname) {
  //$sql = "SELECT description FROM {taxonomy_term_data} WHERE tid = " . gettaxonomyidbysystem($systemname) . "";
  $sql = "SELECT description FROM {taxonomy_term_data} WHERE name = '$systemname'";
  return t(db_query($sql)->fetchField());
}

include("blockDefinitions.php");

/**
 * Implements hook_menu().
 */
function ndabioresults_menu() {
  global $language;

  $items['admin/config/naturalis/ndaresult'] = array(
    'title' => 'NDA result config',
    'description' => 'Configuration for Naturalis module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ndabioresults_config_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['nba/result/%'] = array(
    'page callback' => 'ndabioresults_pass',
    //'page arguments' => array(1), //0 = nda, 1 = pass, 2 = *.
    'load arguments' => array('%map', '%index'),
    'access callback' => TRUE,
  );
  $items['nba/result'] = array(
    'page callback' => 'ndabioresults_pass',
    //'page arguments' => array(1), //0 = nda, 1 = pass, 2 = *.
    'load arguments' => array('%map', '%index'),
    'access callback' => TRUE,
  );

  return $items;
}

/**
 * Implements template_preprocess_html().
 *
 * Add an extra class to the body to trigger CSS styles
 *
 */
function ndabioresults_preprocess_html(&$vars){
  if ( $_SESSION['ndaRequestType'] !== 'form'){
    $vars['classes_array'][] = "nba-result-detail";
  }
}

include 'adrie.php';

/**
 * Mapping function: distributes parameters to appropriate specimen service
 *
 * Distributes specimens search parameters between specimen and specimen name
 * services. Important: list of parameters hould be complete!
 *
 * @param array $sP Search parameters
 * @param string $type Service type
 *
 * @return array Reduced array of search criteria for the service of choice
 */
function setSpecimenParameters (array $sP, $type) {
    $parameters = array(
        specimenService() => array(
            'collectingStartDate',
            'collectionFieldNumber',
            'gatheringAgent',
            'localityText',
            'phaseOrStage',
            'unitID',
            'sex',
            'taxonomicStatus',
            'typeStatus',
            '_geoShape'
        ),
        specimenNamesService() => array(
            'className',
            'family',
            'genusOrMonomial',
            'kingdom',
            'order',
            'phylum',
            'speciesEpithet',
            'subspeciesEpithet',
            'vernacularName',
            '_geoShape'
        )
    );
    foreach ($parameters[$type] as $p) {
        if (isset($sP[$p]) && (!empty($sP[$p]) || is_numeric($sP[$p]))) {
            $d[$p] = $sP[$p];
        }
    }
    // If any parameters are found, append andOr and geoShape (if applicable)
    if (isset($d)) {
        $d['_andOr'] = $sP['_andOr'];
        if (!empty($sP['geoShape'])) {
            $d['_geoShape'] = $sP['geoShape'];
        }
    }
    return isset($d) ? $d : null;
}

/**
 * Accepts search form data and returns formatted result
 *
 * The main function that actually processes the incoming POST data, stores the
 * POST data in a SESSION, distributes the search to the appropriate channels
 * and returns the formatted output.
 *
 * @return string The formatted output
*/
function ndabioresults_pass ($args = "") {
    // POST data from the search form?
    // If so, add to SESSION or replace existing SESSION data
    if (isset($_POST['form_id']) && $_POST['form_id'] == 'ndabio_advanced_taxonomysearch') {
        $_SESSION['ndaSearch'] = $_POST;
    }
    // GET data from within NDA response?
    // Forward directly to appropriate service
    else if (isset($_GET['nba_request'])) {
        return ndaDirectRequest(urldecode($_GET['nba_request']));
    }
    // If both POST and SESSION are empty we have a problem...
    else {
        // Probably best to redirect gracefully to search page?
        handleError('No POST data received! Form validation should trap this. Redirect to home if this occurs?');
    }
    // Redirect to distinct services
    return empty($_SESSION['ndaSearch']['term']) ? ndaAdvancedSearch() : ndaSimpleSearch();
}

/**
 * Distributes search parameter of the simple search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output
 */
function ndaSimpleSearch () {
    $pageHeader = _wrap(t('Search results'),"H1");

    $p = array(
        '_search' => $_SESSION['ndaSearch']['term']
    );

    // Taxon search does not include geoShape and should not be invoked when coming from geo form!
    if (!isset($_SESSION['ndaSearch']['gid'])) {
        $services[taxonService()] = $p;
    }

    // Other searches do include geoShape if entered
    if (isset($_SESSION['ndaSearch']['geoShape']) && !empty($_SESSION['ndaSearch']['geoShape'])) {
        $p['_geoShape'] = $_SESSION['ndaSearch']['geoShape'];
        $p['_andOr'] = 'AND';

        $pageHeader .= t("Showing only results in") ." ". $_SESSION['ndaSearch']['location'] .
            "<div data-alert class='alert-box secondary'> $geo </div>";
    };

    foreach (array(specimenService(), specimenNamesService(), multimediaService()) as $request) {
        $services[$request] = $p;
    }

    // Set session with NBA query type;
    // used to determine if show all should be printed
    $_SESSION['ndaRequestType'] = 'form';
    $_SESSION['ndaPageDetail'] = 'result from simple form';

    $pageBody = performNdaRequest(setChannels($services));

    return $pageHeader . (!empty($pageBody) ? $pageBody : '<p>' . t('No results') . '</p>');
}

/**
 * Distributes search parameters of the advanced search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output
 */
function ndaAdvancedSearch () {
    $pageHeader = _wrap(t('Search results'),"H1");

    $services[multimediaService()] = setSectionParameters($_SESSION['ndaSearch'], 'm_');
    $services[taxonService()] = setSectionParameters($_SESSION['ndaSearch'], 't_');

    // Subdivide specimen parameters for both result types
    $sP = setSectionParameters($_SESSION['ndaSearch'], 's_');
    $services[specimenService()] = setSpecimenParameters($sP, specimenService());
    $services[specimenNamesService()] = setSpecimenParameters($sP, specimenNamesService());
//p($services);

    // Set session with NBA query type;
    // used to determine if show all should be printed
    $_SESSION['ndaRequestType'] = 'form';
    $_SESSION['ndaPageDetail'] = 'result from advanced form';

    $pageBody = performNdaRequest(setChannels($services));

    return $pageHeader . (!empty($pageBody) ? $pageBody : '<p>' . t('No results') . '</p>');
}

/**ndabioresults_config_form
 * @todo: check base url!!
 * @param unknown $r
 */
function ndaDirectRequest ($r) {
    foreach (serviceToFunctions() as $service => $d) {
        if (strpos($r, $service) !== false) {
            $url = parse_url($r);
            parse_str($url['query'], $q);

            // Add/reset maxResults to default
            $q['_maxResults'] = maxResults();

            // Set geoShape from SESSION if geoShape is part of the request
            if (isset($q['_geoShape']) && $q['_geoShape'] == '[session]' &&
                isset($_SESSION['ndaStoredGeoShape'])) {
                $q['_geoShape'] = $_SESSION['ndaStoredGeoShape'];
            }

            $channels[0]['request'] = $service;
    		$channels[0]['url'] = ndaBaseUrl() . $service;
    		$channels[0]['post'] = 1;
    		$channels[0]['postfields'] = http_build_query($q);
    		// Set session variable with last used service;
            // used to determine current detail page
            $_SESSION['ndaCurrentService'] = $service;
            // Set session with NBA query type;
            // used to determine if show all should be printed
            $_SESSION['ndaRequestType'] = 'url';
            // Set session with info about current page;
            // used to set appropriate blocks
            $_SESSION['ndaPageDetail'] = $d['info'];

            return performNdaRequest($channels);
        }
    }
    return array();
}


/**
 * Sets curl channels
 *
 * Sets request and url parameters for curl channels
 *
 * @param array Service array (service name => search parameters)
 *
 * @return void|array Channels for curl
 */
function setChannels (array $services) {
    $i = 0;
	foreach ($services as $s => $p) {
	    if (!empty($p)) {
	        $p = array_filter($p, 'strlen');

	        // Append default search parameters for form
	        $p['_maxResults'] = maxResultsInitial();
	        $p['_sort'] = defaultSort();
	        $p['_sortDirection'] = defaultSortDirection();

	        $channels[$i]['request'] = $s;
    		$channels[$i]['url'] = ndaBaseUrl() . $s;
    		$channels[$i]['post'] = count($p);
    		$channels[$i]['postfields'] =  http_build_query($p);
    		$i++;
	    }
	}
	return isset($channels) ? $channels : array();
}

/**
 * Filters input parameters from advanced search
 *
 * Input parameters in advanced search form are prefixed with s_, t_, or m_
 * to differentiate between specimen, taxon and multimedia searches. This function
 * creates a new array of input parameters, filtering empty values and stripping
 * the prefix from the input.
 *
 * @param array $post The input as key => value pairs
 * @param string $typeId The input prefix (s_, t_, m_)
 *
 * @return void|array Filtered key => value pairs
 */
function setSectionParameters (array $post, $typeId = '') {
    if ($typeId == '') {
        return $post;
    }
    $d = array();
    foreach ($post as $k => $v) {
        if (strpos($k, $typeId) === 0 && (!empty($v) || is_numeric($v))) {
            $d[str_replace($typeId, '', $k)] = $v;
        }
    }
    // Append geoShape if entered
    if (isset($post['geoShape']) && !empty($post['geoShape']) &&
        in_array($typeId, array('m_', 's_'))) {
        $d['_geoShape'] = $post['geoShape'];
    }
    if (countSearchParameters($d) >= 1) {
        // Reset andOr parameter to _andOr and values to and/or
        $d['_andOr'] = $d['andOr'] == 0 ? 'AND' : 'OR';
        unset($d['andOr']);
        return $d;
    }
    // If only andOr flag is set, nothing has been entered;
    // return empty array
    return array();
}

/**
 * Calculates the number of search parameters excluding flags (andOr etc)
 *
 * @param array $d Search parameter
 * @return Number of search items
 */
function countSearchParameters ($d) {
    foreach ($d as $k => $v) {
        if (in_array($k, searchFlags())) {
            unset($d[$k]);
        }
    }
    return count($d);
}


/**
 * Performs curl requests and formats results
 *
 * Performs curl queries through multicurl. For each channel, resulting json is
 * parsed to an array by one function and subsequently printed by another.
 *
 * @todo Remove drupal_set_message() that temporarily simply prints the resulting
 * NBA urls
 *
 * @param array $channels Service channels
 * @return void|string
 */
function performNdaRequest (array $channels = array()) {
	if (empty($channels)) {
		handleError('Cannot set curl channels');
	}
	// Get json response(s) with curl
	$remoteData = queryNda($channels);
	// Reorder responses in print order if more than one response
	if (count($remoteData) > 1) {
	   $remoteData = sortArrayByArray($remoteData, resultOrder());
	}
	// Map functions to each channel result:
	// parses and prints data
	$output = '';
	$serviceToFunctions = serviceToFunctions();
	foreach ($remoteData as $service => $json) {
		if (!isset($serviceToFunctions[$service]) || empty($json)) {
			continue;
		}
		$parseFunction = isset($serviceToFunctions[$service]['parse']) ?
		    $serviceToFunctions[$service]['parse'] : false;
		$printFunction = isset($serviceToFunctions[$service]['print']) ?
		    $serviceToFunctions[$service]['print'] : false;
		if (!empty($parseFunction) && !empty($printFunction)) {
		    $output .= $printFunction($parseFunction($json));
		}
	}

    // Debug: print queries
	 kpr($channels);

	 return $output;
}

/**
 * Performs multicurl queries
 *
 * Core function for multicurl requests
 *
 * @param unknown $channels Service channels
 * @param integer $timeout Optional timeout
 *
 * @return array Results as key => value pairs for each channel
 */
function queryNda ($channels = array(), $timeout = false) {
    $mh = curl_multi_init();
    for ($i = 0; $i < count($channels); $i++) {
        $ch[$i] = curl_init();
        /*
         * POST did not return data, currently switching to GET
         * @todo: check if posting large areas does not break GET
         *
        curl_setopt($ch[$i], CURLOPT_URL, $channels[$i]['url']);
        curl_setopt($ch[$i], CURLOPT_POST, true;
        curl_setopt($ch[$i], CURLOPT_POSTFIELDS, $channels[$i]['postfields']);
        */
        $channels[$i]['url'] .= '/?'  . $channels[$i]['postfields'];
        curl_setopt($ch[$i], CURLOPT_URL, $channels[$i]['url']);
        curl_setopt($ch[$i], CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch[$i], CURLOPT_HEADER, false);
        if ($timeout) {
       		curl_setopt($ch[$i], CURLOPT_TIMEOUT, $timeout);
        }
        curl_multi_add_handle($mh, $ch[$i]);
    }
    // While we're still active, execute curl
	do {
		$mrc = curl_multi_exec($mh, $active);
	} while ($mrc == CURLM_CALL_MULTI_PERFORM);

    while ($active && $mrc == CURLM_OK) {
        // Wait for activity on any curl-connection
        if (curl_multi_select($mh) == -1) {
            usleep(1);
        }
        // Continue to exec until curl is ready to
        // give us more data
        do {
            $mrc = curl_multi_exec($mh, $active);
        } while ($mrc == CURLM_CALL_MULTI_PERFORM);
    }
    // Place results in results array and close handlers
    for ($i = 0; $i < count($channels); $i++) {
        $remoteData[$channels[$i]['request']] = curl_multi_getcontent($ch[$i]);
        curl_multi_remove_handle($mh, $ch[$i]);
    }
    curl_multi_close($mh);
    return $remoteData;
}





function parseSpecimenMediaDetail ($json) {
	if (!$json || !validJson($json)) {
		handleError('parseSpecimenMediaDetail: no or invalid json response');
	}
	$data = json_decode($json);
	$row = $data->searchResults[0];

	$output['source'] = $row->result->associatedSpecimen->sourceSystem->name;
	$output['navigation'] = getNavigation($data);
	$output['names'] = getSpecimenMediaTaxonNames($row);
	$output['unitID'] = $row->result->associatedSpecimen->unitID;
	$output['title'] = $row->result->title;
	$output['caption'] = $row->result->caption;
	$output['imgSrc'] = getImageUrl($row);

//p($output);
	return $output;
}


function getSpecimenMediaTaxonNames ($row) {
	foreach ($row->result->associatedSpecimen->identifications as $i => $name) {
		$output[] = array(
			'name' => formatScientificName(
				$name->scientificName->fullScientificName,
				$name->scientificName
			),
			'url' => getSpecimenMediaTaxonUrl($row, $i)
		);
	}
	return isset($output) ? $output : false;
}


function getSpecimenMediaTaxonUrl ($row, $i) {
	if (!empty($row->links)) {
		foreach ($row->links as $link) {
			if ($link->rel == "scientificnames[{$i}].fullScientificName") {
				return $link->href;
			}
		}
	}
	return null;
}

include 'printSpecimenMediaDetail.php';


function parseTaxonMediaDetail ($json) {
	if (!$json || !validJson($json)) {
		handleError('parseTaxonMediaDetail: no or invalid json response');
	}
	$data = json_decode($json);
	$row = $data->searchResults[0];
	$output['source'] = $row->result->associatedTaxon->sourceSystem->name;
	$output['acceptedName'] = formatScientificName(
		$row->result->associatedTaxon->acceptedName->fullScientificName,
		$row->result->associatedTaxon->acceptedName
	);
	$output['navigation'] = getNavigation($data);
	$output['title'] = $row->result->title;
	$output['caption'] = $row->result->caption;
	$output['imgSrc'] = getImageUrl($row);
	return $output;
}


include 'printTaxonMediaDetail.php';


// Parses taxon detail json response into array
function parseTaxonDetail ($json) {
	$skipFields = array(
		'objectPublic'
		// etc
	);
	if (!$json || !validJson($json)) {
		handleError('parseTaxonDetail: no or invalid json response');
	}
	$data = json_decode($json);
//p($data);
	$output['acceptedName'] = formatScientificName(
		$data->searchResults[0]->result->acceptedName->fullScientificName,
		$data->searchResults[0]->result->acceptedName
	);
	$output['navigation'] = getNavigation($data);
	foreach ($data->searchResults as $row) {
		$source = $row->result->sourceSystem->name;

		if (!empty($row->result->defaultClassification)) {
			$output['classifications']['default'][$source] =
				parseClassification($row->result->defaultClassification);
		}
		if (!empty($row->result->synonyms)) {
			foreach ($row->result->synonyms as $i => $synonym) {
				$output['synonyms'][$source] = formatScientificName(
					$row->result->synonyms[$i]->fullScientificName,
					$row->result->synonyms[$i]
				);
			}
		}
		if (!empty($row->result->descriptions)) {
		    // @todo: hard coded for NSR, as this is the only source for descriptions
		    foreach ($row->result->descriptions as $i => $description) {
		        if (strtolower($description->category) == 'algemeen') {
                    $output['descriptions']['Dutch'][$source] =
					   $description->description;
		        }
		    	if (strtolower($description->category) == 'summary') {
                    $output['descriptions']['English'][$source] =
					   $description->description;
		        }
		    }
		}
		if (!empty($row->result->vernacularNames)) {
			foreach ($row->result->vernacularNames as $i => $name) {
				$output['commonNames'][$name->language][$source] =
					$name->name;
			}

		}
	}
	return $output;
}


function parseClassification ($classification) {
    if (empty($classification) || empty($type)) {
        return $classification;
    }
    if ($type == 'system') {
        foreach ($classification as $rank) {
            $c[$rank->rank] = $rank->name;
        }
    }
    return isset($c) ? $c : $classification;
}


include 'printTaxonDetail.php';


// function printTaxonDetail ($data) {
//   global $language;
//
//   $output .= "<div class='large-7 columns'>";
//
//   $output .= "<h2>" . $data['acceptedName'] . " <span class='populair-name'>" .
//     (isset($data['commonNames'][$language->language]) ?
//       implode(', ', $data['commonNames'][$language->language]) : '') .
//     "</span></h2>";
//
//   $output .=
//      printCommonNames($data)
//     .printDescriptions($data)
//     .printClassifications($data);
//
//   $output .= "</div>";
//
//   $output .= "<div class='large-3 columns'>";
//   $output .=    printNavigation($data) .
//   $output .= "</div>";
//
//   return $output;
// }

include 'printCommonNames.php';

include 'printDescriptions.php';

include 'printClassifications.php';


// Parses specimen detail json response into array
function parseSpecimenDetail ($json) {
	$skipFields = array(
		'objectPublic'
		// etc
	);
	if (!$json || !validJson($json)) {
		handleError('parseSpecimenDetail : no or invalid json response');
	}
	$data = json_decode($json);
	foreach ($data->searchResults[0]->result as $field => $value) {
		if (!is_array($value) && !is_object($value) &&
			!in_array($field, $skipFields) && $value != '') {
			$output[t(translateNdaField($field))] = $value;
		}
	}
	$output['source'] = isset($data->searchResults[0]->result->sourceSystem) ?
	   $data->searchResults[0]->result->sourceSystem->name : '';
	$output['names'] = getSpecimenTaxonNames($data->searchResults[0]);
	$output['gatheringEvent'] = getGatheringEventSpecimens($data);
	$output['otherSpecimens'] = getOtherSpecimens($data);
	$output['navigation'] = getNavigation($data);
//p($output);
    return $output;
}


// Return previous/next links from result set
function getNavigation ($data) {
	if (isset($data->links) && !empty($data->links)) {
		foreach ($data->links as $link) {
			if ($link->rel == 'prev' || $link->rel == 'next') {
				$output[$link->rel] = $link->href;
			}
		}
	}
	return isset($output) ? $output : null;
}

include 'printSpecimenDetail.php';

include 'printNavigation.php';

include 'printNamesWithLinks.php';

// Return other specimens for detail page
function getOtherSpecimens ($row) {
	if (!empty($row->searchResults[0]->result->otherSpecimensInSet)) {
		foreach ($row->searchResults[0]->result->otherSpecimensInSet as $i => $specimen) {
			$s = array();
			$s['unitID'] = $specimen->unitID;
			$s['collectionType'] = $specimen->collectionType;
			$s['url'] = getSpecimenInCollectionUrl($row, $i);
			$c[] = $s;
		}
	}
	return isset($c) ? $c : null;
}

// Return gathering event data for detail page
function getGatheringEventSpecimens ($row) {
	if (!empty($row->searchResults[0]->result->gatheringEvent)) {
        $event = $row->searchResults[0]->result->gatheringEvent;
		foreach ($event as $k => $v) {
		    if (!is_array($v) && !is_object($k) && $v != '') {
                $d[$k] = $v;
		    }
		}
		if (!empty($event->gatheringAgents)) {
		    foreach ($event->gatheringAgents as $a) {
                $agent[] = $a->fullName . (!empty($a->organization) ?
                    ' (' . $a->organization . ')' : '');
		    }
		    $d['gatheringAgents'] = $agent;
		}
		if (!empty($event->siteCoordinates)) {
		    foreach ($event->siteCoordinates as $c) {
                if ($c->longitudeDecimal != 0 && $c->latitudeDecimal != 0) {
                    $coordinates['lat'] = $c->latitudeDecimal;
                    $coordinates['lon'] = $c->longitudeDecimal;
                }
		    }
		    $d['siteCoordinates'] = isset($coordinates) ?
		        $coordinates : null;
		}
	}
	return isset($d) ? $d : null;
}


include 'printTableRow.php';



// Parses multimedia json response into array
function parseMultimedia ($json) {
	if (!$json || !validJson($json)) {
		handleError('parseMultimedia: no or invalid json response');
	}
	$data = json_decode($json);
	$output['searchTerms'] = getSearchTerms($data);
	$output['total'] = getTotalRows($data);
	if (!$output['searchTerms']) {
		handleError('parseMultimedia: invalid json response');
	}
	if ($output['total'] == 0) {
	    $output['results'] = array();
        return $output;
	}
	foreach ($data->searchResults as $row) {
		$type = !empty($row->result->associatedTaxon) ? 'associatedTaxon' :
            'associatedSpecimen';
		$d['title'] = $row->result->title;
		$d['caption'] = $row->result->caption;
		$d['score'] = $row->percentage;
		$d['url'] = getMultimediaDetailLink($row);
		$d['source'] = !empty($row->result->{$type}->sourceSystem) ?
            $row->result->{$type}->sourceSystem->name : '';
		$d['imgSrc'] = getImageUrl($row);
		$d['hits'] = getHits($row);
		$output['results'][] = $d;
	}

	$output['self'] = getSelfLink($data);
	$output['showAll'] = getShowAll($data);
	$output['paginator'] = getPaginator($data);
//p($data);
	return isset($output) ? $output : false;
}


function getMultimediaDetailLink ($row) {
    foreach ($row->links as $link) {
        if ($link->rel == '_multimedia') {
            return $link->href;
        }
    }
}

include 'printMultimedia.php';
include 'printMatches.php';

// Returns specimens searched for other fields but taxon
function parseSpecimens ($json) {
	if (!$json || !validJson($json)) {
		handleError('parseSpecimens: no or invalid json response');
	}
	$data = json_decode($json);
//p($data);
	$output['searchTerms'] = getSearchTerms($data);
	$output['total'] = getTotalRows($data);
	if (!$output['searchTerms']) {
		handleError('parseSpecimens: invalid json response');
	}
	if ($output['total'] == 0) {
	    $output['results'] = array();
        return $output;
	}
	foreach ($data->searchResults as $row) {
		$d = array();
		$d['unitID'] = $row->result->unitID;
		$d['url'] = $row->links[0]->href;
		$d['hits'] = getHits($row);
		$d['source'] = $row->result->sourceSystem->name;
		$d['score'] = $row->percentage;
		$d['names'] = getSpecimenTaxonNames($row);
		$output['results'][] = $d;
	}

	$output['self'] = getSelfLink($data);
	$output['showAll'] = getShowAll($data);
	$output['paginator'] = getPaginator($data);

	return isset($output) ? $output : false;
}

include 'printSpecimens.php';

include 'printHits.php';

include 'printSpecimenTaxa.php';


// Returns taxon names for specimens plus their url found by other fields but name
// (for specimens found by taxon name only a single name is returned!)
function getSpecimenTaxonNames ($row) {
    if (!isset($row->result->identifications) || empty($row->result->identifications)) {
        return array();
    }
	foreach ($row->result->identifications as $i => $id) {
		$output[] = array(
			'name' => formatScientificName(
				$id->scientificName->fullScientificName,
				$id->scientificName
			),
			'url' => getSpecimenTaxonUrl($row, $i)
		);
	}
	return isset($output) ? $output : false;
}


// Returns url for a taxon associated with the specimen
function getSpecimenTaxonUrl ($row, $i) {
	if (!empty($row->links)) {
		foreach ($row->links as $link) {
			if ($link->rel == "identifications[{$i}].scientificName.fullScientificName") {
				return $link->href;
			}
		}
	}
	return null;
}



// Parses specimen json response into array; searched by taxon
function parseSpecimensByTaxon ($json) {
	if (!$json || !validJson($json)) {
		handleError('parseSpecimensByTaxon: no or invalid json response');
	}
	$data = json_decode($json);
//p($data);
	$output['searchTerms'] = getSearchTerms($data);
	$output['total'] = getTotalRows($data);
	if (!$output['searchTerms']) {
		handleError('parseSpecimensByTaxon: invalid json response');
	}
	if ($output['total'] == 0) {
	    $output['results'] = array();
        return $output;
	}
	foreach ($data->resultGroups as $row) {
		$d = array();
		$d['name'] = formatScientificName(
			$row->sharedValue,
		    // @todo
			//$row->searchResults[0]->result->identifications[getResultOffset($row)]->scientificName,
			$row->searchResults[0]->result->identifications[0]->scientificName,
		    $output['searchTerms']
		);
		$d['url'] = isset($row->links[0]->href) ? $row->links[0]->href : null;
		$d['count'] = count($row->searchResults);
		$d['sources'] = getSources($row);
		$d['score'] = $row->searchResults[0]->percentage;
		foreach ($row->searchResults as $i => $sp) {
    		$assemblageID = $sp->result->assemblageID;
    		$s['unitID'] = $sp->result->unitID;
    		$s['collectionType'] = $sp->result->collectionType;
    		$s['url'] = $sp->links[0]->href;
            empty($assemblageID) ? $d['specimens'][] = $s : $d['sets'][$assemblageID][] = $s;
		}
		$output['results'][] = $d;
	}

	$output['self'] = getSelfLink($data);
	$output['showAll'] = getShowAll($data);
	$output['paginator'] = getPaginator($data);
// p($data);
	return isset($output) ? $output : false;
}


function getShowAll ($data) {
	if (isset($_SESSION['ndaRequestType']) && $_SESSION['ndaRequestType'] == 'form' &&
	    getTotalRows($data) > maxResultsInitial()) {
	    $self = getSelfLink($data);
	    if (!empty($self)) {
	       return setUrlPars(geoShapeToSession($self, true), array('_maxResults' => maxResults()), true);
	    }
	}
	return null;
}

function getSort ($self) {
    if (!empty($self)) {
        $value = getUrlParValue(urldecode($self), '_sort');
        if (!empty($value)) {
            return $value;
        }
    }
    return defaultSort();
}

function getSortDirection ($self) {
    if (!empty($self)) {
        $value = getUrlParValue(urldecode($self), '_sortDirection');
        if (!empty($value)) {
            return $value;
        }
    }
    return defaultSortDirection();
}

function setSortUrl ($column, $dir, $self) {
    // Column currently selected; only switch sort direction
    if ($column == getSort($self)) {
        return setUrlPars(
            $self,
            array(
                '_sortDirection' => getSortDirection($self) == 'DESC' ? 'ASC' : 'DESC',
                '_offset' => 0
            ),
            true
        );
    }
    // Other column is currently selected; set to current column in default direction
    return setUrlPars(
        $self,
        array(
            '_sort' => $column,
            '_sortDirection' => $dir,
            '_offset' => 0
        ),
        true
    );
}

include 'Paginator.php';

function getPaginator ($data) {
    if (isset($_SESSION['ndaRequestType']) && $_SESSION['ndaRequestType'] != 'form') {
        $paginator = new Paginator(
            getTotalRows($data),
            maxResults(),
            getOffset($data) / maxResults() + 1,
            setPaginatorUrl($data)
        );
        return $paginator->toHtml();
    }
    return null;
}

function setPaginatorUrl ($data) {
    return printDrupalLink(
        stripOffsetFromUrl(geoShapeToSession(urldecode(getSelfLink($data)))) . '&_offset='
    ) . '(:num)';
}

function setUrlPars ($url, array $newValues, $decodeEncode = false) {
    if ($decodeEncode) {
        $url = urldecode($url);
    }
    $parts = parse_url($url);
    parse_str($parts['query'], $q);
    foreach ($newValues as $p => $v) {
        $q[$p] = $v;
    }
    $parts['query'] = http_build_query($q);
    $url = reverse_parse_url($parts);
    return $decodeEncode ? urlencode($url) : $url;
}

/**
 *  Replaces the value of the _geoShape parameter from any NBA-created url with [session].
 *  Stores the value in a session parameter, which should be retrieved when creating the NBA request.
 *
 * @param string $url
 * @return string, session parameter
 */
function geoShapeToSession ($url, $decodeEncode = false) {
    if ($decodeEncode) {
        $url = urldecode($url);
    }
    $parts = parse_url($url);
    parse_str($parts['query'], $q);
    if (isset($q['_geoShape'])) {
        $_SESSION['ndaStoredGeoShape'] = $q['_geoShape'];
        $q['_geoShape'] = '[session]';

        $parts['query'] = http_build_query($q);
        $url = reverse_parse_url($parts);
    }
    return $decodeEncode ? urlencode($url) : $url;
}

function stripOffsetFromUrl ($url, $decodeEncode = false) {
    if ($decodeEncode) {
        $url = urldecode($url);
    }
    $parts = parse_url($url);
    parse_str($parts['query'], $q);
    if (isset($q['_offset'])) {
        unset($q['_offset']);
    }
    $parts['query'] = http_build_query($q);
    $url = reverse_parse_url($parts);
    return $decodeEncode ? urlencode($url) : $url;
}

function getUrlParValue ($url, $par) {
    if ($url != '' && $par != '') {
        $parts = parse_url($url);
        if (!empty($parts)) {
            parse_str($parts['query'], $q);
            foreach ($q as $p => $v) {
                if ($p == $par) {
                    return $v;
                }
            }
        }
    }
    return false;
}



function getSelfLink ($data) {
    if (isset($data->links) && !empty($data->links)) {
        foreach ($data->links as $link) {
            if ($link->rel == '_self') {
                return $link->href;
            }
        }
    }
    return false;
}

/**
 * Function from php.net to reverse parse_url. Cannot use http_buil_url() because it requires PECL
 */
function reverse_parse_url ($parsed_url) {
    $scheme = isset($parsed_url['scheme']) ? $parsed_url['scheme'] . '://' : '';
    $host = isset($parsed_url['host']) ? $parsed_url['host'] : '';
    $port = isset($parsed_url['port']) ? ':' . $parsed_url['port'] : '';
    $user = isset($parsed_url['user']) ? $parsed_url['user'] : '';
    $pass = isset($parsed_url['pass']) ? ':' . $parsed_url['pass']  : '';
    $pass = ($user || $pass) ? "$pass@" : '';
    $path = isset($parsed_url['path']) ? $parsed_url['path'] : '';
    $query = isset($parsed_url['query']) ? '?' . $parsed_url['query'] : '';
    $fragment = isset($parsed_url['fragment']) ? '#' . $parsed_url['fragment'] : '';
    return "$scheme$user$pass$host$port$path$query$fragment";
}

function getOffset ($data) {
    if (isset($data->queryParameters->_offset[0])) {
        return $data->queryParameters->_offset[0];
    }
    return 0;
}

// Returns image properties
function getImageUrl ($row) {
    if (!empty($row->result->serviceAccessPoints)) {
    	$key = key(get_object_vars($row->result->serviceAccessPoints));
    	return $row->result->serviceAccessPoints->{$key}->accessUri;
    }
    return null;
}


// Return the field containing the hit
function getHits ($row) {
	foreach ($row->matchInfo as $info) {
		$e = explode('.', $info->path);
		$hits[end($e)] = $info->valueHighlighted;
	}
	return isset($hits) ? $hits : array();
}

include 'printSpecimensByTaxon.php';

include 'printSpecimenCollection.php';



// Shorthand function to pad "filler" tds
function padTds ($i) {
	if ((int)$i > 0) {
		return str_repeat("<td></td>", $i);
	}
}

// Return url for specimens in "collection"/set
function getSpecimenInCollectionUrl ($row, $i) {
	if (!empty($row->searchResults[0]->links)) {
		foreach ($row->searchResults[0]->links as $link) {
			if ($link->rel == 'specimen-detail.otherSpecimensInSet.' . $i) {
				return $link->href;
			}
		}
	}
	return null;
}

include 'printHeaders.php';


// Parses taxon/species json response into array
function parseTaxa ($json) {
    global $language;
	if (!$json || !validJson($json)) {
		handleError('parseTaxon: no or invalid json response');
	}
	$data = json_decode($json);

	$output['total'] = getTotalRows($data);
	$output['searchTerms'] = getSearchTerms($data);
	if (!$output['searchTerms']) {
		handleError('parseTaxon: invalid json response');
	}
	if ($output['total'] == 0 || empty($data->resultGroups)) {
	    $output['results'] = array();
        return $output;
	}
	foreach ($data->resultGroups as $row) {
		$d = array();
		// Accepted scientific name, synonym, or common name
		$d['type'] = getResultType($row);
		$d['rank'] = $row->searchResults[0]->result->taxonRank;
		if ($d['type'] == 'accepted') {
			$d['name'] = formatScientificName(
				strip_tags($row->searchResults[0]->result->acceptedName->fullScientificName),
				$row->searchResults[0]->result->acceptedName,
				$output['searchTerms']
			);
			$d['description'] = t(ucfirst($d['rank']));
		} else if ($d['type'] == 'synonym') {
            $offset = getTaxonSynonymOffset($row);
			$d['name'] = formatScientificName(
				strip_tags($row->searchResults[0]->result->synonyms[$offset]->fullScientificName),
				$row->searchResults[0]->result->synonyms[$offset],
				$output['searchTerms']
			);
			$d['description'] = t('Synonym for') . ' ' .
    			formatScientificName(
    				$row->searchResults[0]->result->acceptedName->fullScientificName,
    				$row->searchResults[0]->result->acceptedName
    			);
		} else if ($d['type'] == 'common') {
			$d['name'] = highlightSearchTerms(
				strip_tags($row->searchResults[0]->matchInfo[0]->valueHighlighted),
				$output['searchTerms']
			);
			$d['description'] = t('Vernacular name for') . ' ' .
			     formatScientificName(
    				$row->searchResults[0]->result->acceptedName->fullScientificName,
    				$row->searchResults[0]->result->acceptedName
    			);
		}
		$d['url'] = urldecode($row->searchResults[0]->links[0]->href);
		$d['sources'] = getSources($row);
		$d['commonNames'] = ($d['type'] != 'common' ? getCommonNames($row, true) : array());
		$d['score'] = $row->searchResults[0]->percentage;
		$output['results'][] = $d;
	}

	$output['self'] = getSelfLink($data);
	$output['showAll'] = getShowAll($data);
	$output['paginator'] = getPaginator($data);

	return isset($output) ? $output : false;
}


function getTaxonSynonymOffset ($row) {
    $path = $row->searchResults[0]->matchInfo[0]->path;
    $field = str_replace('synonyms.', '', $path);
    foreach ($row->searchResults[0]->result->synonyms as $i => $synonyms) {
        if ($synonyms->$field ==
            strip_tags($row->searchResults[0]->matchInfo[0]->valueHighlighted)) {
            return $i;
        }
    }
}



include 'printTaxa.php';


// Validates json string
function validJson ($string) {
	return is_object(json_decode($string));
}

// Returns type of result:
// acceptedName.fullScientificName
// acceptedName.synonyms[0].scientificName.fullScientificName
// acceptedName.commonNames[0].name
function getResultType ($row) {
	$path = $row->searchResults[0]->matchInfo[0]->path;
	return strpos($path, 'synonym') !== false ? 'synonym' :
		(strpos($path, 'vernacularNames') !== false ? 'common' : 'accepted');
}

// Returns offset of result; used only for synonyms and common names
// to determine the array key containing the hit
// Used for taxon/specimenByTaxon
function getResultOffset ($row) {
	preg_match('/\[(.*?)\]/', $row->searchResults[0]->matchInfo[0]->path, $m);
	return $m[1];
}

// Returns total number of results
function getTotalRows ($data) {
	if (isset($data->totalSize)) {
		return (int)$data->totalSize;
	}
	return false;
}

// Returns total number of results
function getSearchTerms ($data) {
	if (isset($data->queryParameters)) {
		return (array)$data->queryParameters;
	}
	return false;
}

// Results formatted accepted name with proper use of italics
function formatScientificName ($scientificname, $nameObject, $searchTerms = false) {
	$output = $scientificname;
	$elements = getScientificNameElements($nameObject);
	foreach ($elements as $e) {
		if (!empty($e)) {
			$output = str_replace($e, '<span class="scientific">' . $e . '</span>', $output);
		}
	}
	// Highlight the formatted output
	return $searchTerms ? highlightSearchTerms($output, $searchTerms) : $output;
}

function highlightSearchTerms ($output, $searchTerms) {
    foreach ($searchTerms as $field => $value) {
        if (!in_array(str_replace('_', '', $field), searchFlags())) {
            $terms[$value[0]] = '';
        }
    }
    // Intermediate step required to remove any duplicates
    if (isset($terms)) {
        $output = highlightMatch($output, array_flip($terms));
    }
    return $output;
}

// Returns scientific name elements from name object
// Store as keys and flip to avoid duplicates (as in Larus fuscus fuscus)
function getScientificNameElements ($name) {
	$elements = array(
		$name->genusOrMonomial => 0,
		$name->subgenus => 1,
		$name->specificEpithet => 2,
		$name->infraspecificEpithet => 3
	);
	return array_flip($elements);
}

// Returns all sources for taxon/specimen
function getSources ($row) {
	foreach ($row->searchResults as $i => $obj) {
		$output[$obj->result->sourceSystem->name] = $i;
	}
	return isset($output) ? array_flip($output) : false;
}

// Returns common names for the current interface language;
// format is array(name => language), so duplicates will be avoided
function getCommonNames ($row, $languageCheck = false) {
	global $language;
	foreach ($row->searchResults as $i => $taxon) {
		if (isset($taxon->result->vernacularNames)) {
			foreach ($taxon->result->vernacularNames as $name) {
				// If language is set, only store when language of
				// common name matches that of interface...
				if ($languageCheck) {
					if ($name->language == $language->name) {
						$output[$name->name] = $name->language;
					}
				// ... else always return all names
				} else {
					$output[$name->name] = $name->language;
				}
			}
		}
	}
	return isset($output) ? $output : false;
}


// Decorate description in taxon result table
function decorateDescription ($row) {
	return ($row['type'] != 'accepted' ?
		t(ucfirst($row['type'])) . ($row['type'] == 'common' ? ' ' . t('name') : '') .
		' ' . t('for') . ' ' :  '') . ($row['type'] == 'accepted' ? t(ucfirst($row['rank'])) :
		t($row['rank']));
}

// Decorate score in result table
function decorateScore ($score) {
	$score = round($score * 100);
	$roundScore = round( $score / 20 );
  $result = "<span class='score' title='$score %'>";

  for ( $i=1; $i<=5; $i++ ){
    if ( $i <= $roundScore ){
      $result.= "<span class='square-filled'>&FilledSmallSquare;</span>";
    } else {
      $result.= "<span class='square-empty'>&EmptySmallSquare;</span>";
    }
  }

  $result .= "</span>";
  return $result;

  //return "<span class='score'><span class='score-bar' style='width: $score%'></span><span class='score-text'>$score%</span></span>";
}

// Highlight match
function highlightMatch($haystack, $needles) {
	foreach ($needles as $needle) {
		if (!is_string($needle) || stripos(strip_tags($haystack), $needle)===false || is_null($needle)) {
			continue;
		}
		$q = str_split($needle);
		$x = ')(\<[^<]*\>)*(';
		$q = str_replace('( )','(\s*)','('.implode($x, $q).')');
		$haystack = preg_replace_callback('/'.$q.'/i','_fsub1', $haystack);
	}
	return $haystack;
}

function _fsub1($m) {
	return "<span class='result-query'>".preg_replace_callback('(<(.*?)>)','_fsub2',$m[0])."</span>";
}

function _fsub2($m) {
	return '</span>'.$m[0]."<span class='result-query'>";
}

function sortArrayByArray ($array, $orderArray) {
    $ordered = array();
    foreach ($orderArray as $key) {
        if (array_key_exists($key,$array)) {
            $ordered[$key] = $array[$key];
            unset($array[$key]);
        }
    }
    return $ordered + $array;
}


// Wrapper for Drupal error handler
function handleError ($message) {
    die($message);
}


// Should be replaced with a function that translates NDS field labels to proper English
function translateNdaField ($str) {
	return $str;
}

// Create Drupal specific link
function printDrupalLink ($url) {
    global $base_root, $base_path;
    return $base_root . $base_path . 'nba/result?nba_request=' . urlencode($url);
}

function _markUp($string){
  $result = $string;
  $result = preg_replace('/^\s+|\n|\r|\s+$/m', '', $result);

  $result = str_replace(
    array("    <h2",  "<table",        "<thead",      "<tbody",      "<tr",        "<td",        "<th ",   "<a class='polaroid'"),
    array("\n\n<h2","\n\n<table","\n\n\t<thead","\n\n\t<tbody","\n\t\t<tr","\n\t\t\t<td","\n\t\t\t<th ", "\n<a class='polaroid' "),
    $result
  );

  $result = str_replace(
    array(  "</table",    "</thead",    "</tbody",     "</tr",        "</td",        "</th>"),
    array("\n</table","\n\t</thead","\n\t</tbody","\n\t\t</tr","\n\t\t\t</td","\n\t\t\t</th>"),
    $result
  );

  return $result;
}

function p ($a) {
    echo '<pre>'; print_r($a); echo '</pre>';
}

function _wrap($input, $tag = "div", $class = ""){
  $class = ($class == "" ? "": " class='$class'" );
  return "<$tag$class>$input</$tag>";
}

function printDL($field, $value){
  return "<dl><dt>$field</dt><dd>$value</dd></dl>";
}
