<?php

/**
 * @file
 * Naturalis example module.
 */

/**
 * Defaults.
 */
define('NATURALIS', 'taxonDetail');

/**
* DEFINE CUSTOM PAGES
*/

function gettaxonomyidbysystem($systemname) {
  $sql = "SELECT entity_id FROM {field_data_field_ndasystem} WHERE field_ndasystem_value = '$systemname'";
  return db_query($sql)->fetchField();
}

function gettaxonomybysystem($systemname) {
  //$sql = "SELECT description FROM {taxonomy_term_data} WHERE tid = " . gettaxonomyidbysystem($systemname) . "";
  $sql = "SELECT description FROM {taxonomy_term_data} WHERE name = '$systemname'";
  return t(db_query($sql)->fetchField());
}

function ndabioresults_menu() {
  global $language;

  $items['admin/config/naturalis/ndaresult'] = array(
    'title' => 'NDA result config',
    'description' => 'Configuration for Naturalis module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ndabioresults_config_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['nda/page'] = array(
    'page callback' => 'ndabioresults_page_callback',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['nba/result/%'] = array(
    'page callback' => 'ndabioresults_pass',
    //'page arguments' => array(1), //0 = nda, 1 = pass, 2 = *.
    'load arguments' => array('%map', '%index'),
    'access callback' => TRUE,
  );
  $items['nba/result'] = array(
    'page callback' => 'ndabioresults_pass',
    //'page arguments' => array(1), //0 = nda, 1 = pass, 2 = *.
    'load arguments' => array('%map', '%index'),
    'access callback' => TRUE,
  );

  return $items;
}

function ndabioresults_page_callback() {
  global $base_root, $base_path;
  return t('Copyright') . ' ' . date("Y") . ' <a href="' . variable_get('ndabioresults_copyright_url', $base_root . $base_path) . '">Naturalis</a>';
}

function ndabioresults_config_form($form, &$form_state) {
  $form['ndabioresults_config'] = array(
    '#type' => 'fieldset',
    '#title' => t('Naturalis config')
  );
  return system_settings_form($form);
}


/**
 * Constant: base url of NBA service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function ndaBaseUrl() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'http://nba.naturalis.nl/';
    }
    return $var;
}

/**
 * Constant: name of specimen service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function specimenService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'specimen-search';
    }
    return $var;
}

/**
 * Constant: name of specimen name service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function specimenNamesService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'specimen-name-search';
    }
    return $var;
}

/**
 * Constant: name of specimen detail service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function specimenDetailService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'get-specimen-detail';
    }
    return $var;
}

/**
 * Constant: name of multimedia per specimen service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function specimenMultimediaService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'get-specimen-multimedia-object-detail-within-result-set';
    }
    return $var;
}

/**
 * Constant: name of taxon service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function taxonService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'taxon-search';
    }
    return $var;
}

/**
 * Constant: name of taxon detail service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function taxonDetailService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'get-taxon-detail';
    }
    return $var;
}

/**
 * Constant: name of multimedia per taxon service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function taxonMultimediaService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'get-taxon-multimedia-object-detail-within-result-set';
    }
    return $var;
}

/**
 * Constant: name of multimedia service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function multimediaService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'multimedia-object-search';
    }
    return $var;
}

/**
 * Constant: order of search results output
 *
 * Determines print order of search result, currently
 * multimedia, taxon, specimen name, specimen.
 *
 * @return array
 */
function resultOrder() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	multimediaService(),
        	taxonService(),
        	specimenNamesService(),
        	specimenService()
        );
    }
    return $var;
}

/**
 * Mapping function: maps service to parse/print functions
 *
 * Each service response is handled by distinct parse and
 * print functions. This function provides the mapping.
 *
 * @return array Names of parse and print function for the service of choice
 */
function serviceToFunctions() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	taxonService() => array(
        		'parse' => 'parseTaxa',
        		'print' => 'printTaxa'
        	),
        	specimenNamesService() => array(
        		'parse' => 'parseSpecimensByTaxon',
        		'print' => 'printSpecimensByTaxon'
        	),
        	multimediaService() => array(
        		'parse' => 'parseMultimedia',
        		'print' => 'printMultimedia'
        	),
        	specimenService() => array(
        		'parse' => 'parseSpecimens',
        		'print' => 'printSpecimens'
        	),
        	specimenDetailService() => array(
        		'parse' => 'parseSpecimenDetail',
        		'print' => 'printSpecimenDetail'
        	),
        	taxonDetailService() => array(
        		'parse' => 'parseTaxonDetail',
        		'print' => 'printTaxonDetail'
        	),
        	taxonMultimediaService() => array(
        		'parse' => 'parseTaxonMediaDetail',
        		'print' => 'printTaxonMediaDetail'
        	),
        	specimenMultimediaService() => array(
        		'parse' => 'parseSpecimenMediaDetail',
        		'print' => 'printSpecimenMediaDetail'
        	)
        );
    }
    return $var;
}

/**
 * Mapping function: distributes parameters to appropriate specimen service
 *
 * Distributes specimens search parameters between specimen and specimen name
 * services. Important: list of parameters hould be complete!
 *
 * @param array $sP Search parameters
 * @param string $type Service type
 *
 * @return array Reduced array of search criteria for the service of choice
 */
function setSpecimenParameters (array $sP, $type) {
    $parameters = array(
        specimenService() => array(
            'collectingStartDate',
            'collectionFieldNumber',
            'gatheringAgent',
            'localityText',
            'phaseOrStage',
            'unitID',
            'sex',
            'taxonomicStatus',
            'typeStatus',

        ),
        specimenNamesService() => array(
            'className',
            'family',
            'genusOrMonomial',
            'kingdom',
            'order',
            'phylum',
            'speciesEpithet',
            'subspeciesEpithet',
            'vernacularName'
        )
    );
    foreach ($parameters[$type] as $p) {
        if (isset($sP[$p]) && (!empty($sP[$p]) || is_numeric($sP[$p]))) {
            $d[$p] = $sP[$p];
        }
    }
    if (isset($d)) {
        $d['_andOr'] = $sP['_andOr'];
    }
    return isset($d) ? $d : null;
}

/**
 * Accepts search form data and returns formatted result
 *
 * The main function that actually processes the incoming POST data, stores the
 * POST data in a SESSION, distributes the search to the appropriate channels
 * and returns the formatted output.
 *
 * @todo For the time being it just prints the appropriate NDA request urls on screen
 * plus displays mock data using DUMMYperformNdaRequest(). Adapt performNdaRequest() and
 * delete DUMMY functions.
 *
 * @return string The formatted output
*/
function ndabioresults_pass ($args = "") {

//print_r($_POST); die();
    // Do we have POST data? If so, add to SESSION or replace existing SESSION data
    if (isset($_POST['form_id']) && $_POST['form_id'] == 'ndabio_advanced_taxonomysearch') {
        $_SESSION['ndaSearch'] = $_POST;
    }
    // If both POST and SESSION are empty we have a problem...
    if (!isset($_SESSION['ndaSearch']) || empty($_SESSION['ndaSearch'])) {
        // Probably best to redirect gracefully to search page?
        handleError('No POST data received! Form validation should trap this. Redirect to home if this occurs?');
    }
    // Redirect to distinct services
    empty($_SESSION['ndaSearch']['term']) ? ndaAdvancedSearch() : ndaSimpleSearch();

    // This line returns mock data
    // TODO: Delete this line and DUMMY functions at the bottom once everything runs properly!
    return DUMMYperformNdaRequest('all');
}

/**
 * Distributes search parameters of the advanced search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output
 */
function ndaAdvancedSearch () {
    $services[multimediaService()] = setSectionParameters($_SESSION['ndaSearch'], 'm_');
    $services[taxonService()] = setSectionParameters($_SESSION['ndaSearch'], 't_');
    // Subdivide specimen parameters for both result types
    $sP = setSectionParameters($_SESSION['ndaSearch'], 's_');
    $services[specimenService()] = setSpecimenParameters($sP, specimenService());
    $services[specimenNamesService()] = setSpecimenParameters($sP, specimenNamesService());
    return performNdaRequest(setChannels($services));
}

/**
 * Distributes search parameter of the simple search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output
 */
function ndaSimpleSearch () {
    $p = array(
        '_search' => $_SESSION['ndaSearch']['term']
    );
    $services = array(
        specimenService() => $p,
        specimenNamesService() => $p,
        taxonService() => $p,
        multimediaService() => $p
    );
    return performNdaRequest(setChannels($services));
}

/**
 * Sets curl channels
 *
 * Sets request and url parameters for curl channels
 *
 * @param array Service array (service name => search parameters)
 *
 * @return void|array Channels for curl
 */
function setChannels (array $services) {
    $i = 0;
	foreach ($services as $s => $p) {
	    if (!empty($p)) {
    		$channels[$i]['request'] = $s;
    		$channels[$i]['url'] = ndaBaseUrl() . $s . setParameters($p);
		    $i++;
	    }
	}
	return isset($channels) ? $channels : array();
}

/**
 * Creates string of GET parameters
 *
 * @param array Array with key => value pairs
 *
 * @return string Formatted string
 */
function setParameters ($p) {
    $url = '';
    foreach (array_filter($p, 'strlen') as $k => $v) {
        $url .= $k . '=' . urlencode($v) . '&';
    }
    return '?' . rtrim($url, '&');
}

/**
 * Filters input parameters from advanced search
 *
 * Input parameters in advanced search form are prefixed with _s, _t, or _m
 * to differentiate between specimen, taxon and multimedia searches. This function
 * creates a new array of input parameters, filtering empty values and stripping
 * the prefix from the input.
 *
 * @param array $post The input as key => value pairs
 * @param string $typeId The input prefix (_s, _t, _m)
 *
 * @return void|array Filtered key => value pairs
 */
function setSectionParameters (array $post, $typeId = '') {
    if ($typeId == '') {
        return $post;
    }
    $d = array();
    foreach ($post as $k => $v) {
        if (strpos($k, $typeId) === 0 && (!empty($v) || is_numeric($v))) {
            $d[str_replace($typeId, '', $k)] = $v;
        }
    }
    // Reset andOr parameter to _andOr and values to and/or
    if (count($d) > 1) {
         $d['_andOr'] = $d['andOr'] == 0 ? 'and' : 'or';
         unset($d['andOr']);
         return $d;
    }
    // If only andOr flag is set, nothing has been entered;
    // return empty array
    return array();
}


/**
 * Performs curl requests and formats results
 *
 * Performs curl queries through multicurl. For each channel, resulting json is
 * parsed to an array by one function and subsequently printed by another.
 *
 * @todo Remove drupal_set_message() that temporarily simply prints the resulting
 * NBA urls
 *
 * @param array $channels Service channels
 * @return void|string
 */
function performNdaRequest (array $channels = array()) {
    // As long as the NDA services are inoperable, just return the channels
    drupal_set_message('<pre>' . print_r($channels, true) . '</pre>');
    return;

	if (empty($channels)) {
		handleError('Cannot set curl channels');
	}
	// Get json response(s) with curl
	$remoteData = queryNda($channels);
	// Reorder responses in print order if more than one response
	if (count($remoteData) > 1) {
	   $remoteData = sortArrayByArray($remoteData, resultOrder());
	}
	// Map functions to each channel result:
	// parses and prints data
	$output = '';
    $serviceToFunctions = serviceToFunctions();
	foreach ($remoteData as $service => $json) {
		if (!isset($serviceToFunctions[$service]) || empty($json)) {
			continue;
		}
		$parseFunction = $serviceToFunctions[$service]['parse'];
		$printFunction = $serviceToFunctions[$service]['print'];
		$output .= $printFunction($parseFunction($json));
	}
	return $output;
}

/**
 * Performs multicurl queries
 *
 * Core function for multicurl requests
 *
 * @param unknown $channels Service channels
 * @param integer $timeout Optional timeout
 *
 * @return array Results as key => value pairs for each channel
 */
function queryNda ($channels = array(), $timeout = false) {
    $mh = curl_multi_init();
    for ($i = 0; $i < count($channels); $i++) {
        $ch[$i] = curl_init();
        curl_setopt($ch[$i], CURLOPT_URL, $channels[$i]['url']);
        curl_setopt($ch[$i], CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch[$i], CURLOPT_HEADER, false);
        if ($timeout) {
       		curl_setopt($ch[$i], CURLOPT_TIMEOUT, $timeout);
        }
        curl_multi_add_handle($mh, $ch[$i]);
    }
    // While we're still active, execute curl
	do {
		$mrc = curl_multi_exec($mh, $active);
	} while ($mrc == CURLM_CALL_MULTI_PERFORM);

    while ($active && $mrc == CURLM_OK) {
        // Wait for activity on any curl-connection
        if (curl_multi_select($mh) == -1) {
            usleep(1);
        }
        // Continue to exec until curl is ready to
        // give us more data
        do {
            $mrc = curl_multi_exec($mh, $active);
        } while ($mrc == CURLM_CALL_MULTI_PERFORM);
    }
    // Place results in results array and close handlers
    for ($i = 0; $i < count($channels); $i++) {
        $remoteData[$channels[$i]['request']] = curl_multi_getcontent($ch[$i]);
        curl_multi_remove_handle($mh, $ch[$i]);
    }
    curl_multi_close($mh);
    return $remoteData;
}





function parseSpecimenMediaDetail ($json) {
	if (!$json || !validJson($json)) {
		handleError('No or invalid json response');
	}
	$data = json_decode($json);
	$row = $data->searchResults[0];

	$output['source'] = $row->result->specimen->sourceSystem->name;
	$output['navigation'] = getNavigation($data);
	$output['names'] = getSpecimenMediaTaxonNames($row);
	$output['unitGUID'] = $row->result->specimen->unitGUID;
	$output['title'] = $row->result->title;
	$output['caption'] = $row->result->caption;
	$output['imgSrc'] = getImageUrl($row);

//echo '<pre>'; print_r($output); echo '</pre>';
	return $output;
}


function getSpecimenMediaTaxonNames ($row) {
	foreach ($row->result->scientificNames as $i => $name) {
		$output[] = array(
			'name' => formatScientificName(
				$name->fullScientificName,
				$name
			),
			'url' => getSpecimenMediaTaxonUrl($row, $i)
		);
	}
	return isset($output) ? $output : false;
}


function getSpecimenMediaTaxonUrl ($row, $i) {
	if (!empty($row->links)) {
		foreach ($row->links as $link) {
			if ($link->rel == "scientificnames[{$i}].fullScientificName") {
				return $link->href;
			}
		}
	}
	return null;
}


function printSpecimenMediaDetail ($data) {
	$output = "<h2>" . $data['title'] . "</h2>\n";
	$output .= printNavigation($data);
	$output .="<img scr='" . $data['imgSrc'] . "' alt='" . $data['title'] .
		"' title=''" . $data['title'] . ">\n";
	$output .= "<table class='table-property-list'>\n<tbody>\n";
	$fields = array('source', 'title', 'caption');
	if (isset($data['acceptedName'])) {
		array_unshift($fields, 'acceptedName');
	} else if (isset($data['names'])) {
		$output .= printNamesWithLinks($data['names'], 'species');
	}
	foreach ($fields as $field) {
		if ($data[$field] != '') {
			$output .= printTableRow($field, $data[$field]);
		}
	}
	return $output . "</tbody>\n</table>\n";
}

function parseTaxonMediaDetail ($json) {
	if (!$json || !validJson($json)) {
		handleError('No or invalid json response');
	}
	$data = json_decode($json);
	$row = $data->searchResults[0];
	$output['source'] = $row->result->taxon->sourceSystem->name;
	$output['acceptedName'] = formatScientificName(
		$row->result->scientificNames[0]->fullScientificName,
		$row->result->scientificNames[0]
	);
	$output['navigation'] = getNavigation($data);
	$output['title'] = $row->result->title;
	$output['caption'] = $row->result->caption;
	$output['imgSrc'] = getImageUrl($row);
//echo '<pre>'; print_r($output); echo '</pre>';
	return $output;
}



function printTaxonMediaDetail ($data) {

  $output = "<h2>" . $data['title'] . "</h2>";
	$output .= printNavigation($data);
	$output .="<img scr='" . $data['imgSrc'] . "' alt='" . $data['title'] .
		"' title=''" . $data['title'] . ">";
	$output .= "<table class='table-property-list'><tbody>";

  foreach (array('acceptedName', 'source', 'title', 'caption') as $field) {
		$output .= printTableRow($field, $data[$field]);
	}

	return $output . "</tbody></table>";
}


// Parses taxon detail json response into array
function parseTaxonDetail ($json) {
	$skipFields = array(
		'objectPublic'
		// etc
	);
	if (!$json || !validJson($json)) {
		handleError('No or invalid json response');
	}
	$data = json_decode($json);
//print_r($data);
	$output['acceptedName'] = formatScientificName(
		$data->searchResults[0]->result->acceptedName->fullScientificName,
		$data->searchResults[0]->result->acceptedName
	);
	$output['navigation'] = getNavigation($data);
	foreach ($data->searchResults as $row) {
		$source = $row->result->sourceSystem->name;

		if (!empty($row->result->defaultClassification)) {
			$output['classifications']['default'][$source] =
				$row->result->defaultClassification;
		}
		if (!empty($row->result->systemClassification)) {
			$output['classifications']['system'][$source] =
				$row->result->systemClassification;
		}
		if (!empty($row->result->synonyms)) {
			foreach ($row->result->synonyms as $i => $synonym) {
				$output['synonyms'][$source] = formatScientificName(
					$row->result->synonyms[$i]->scientificName->fullScientificName,
					$row->result->synonyms[$i]->scientificName
				);
			}
		}
		if (!empty($row->result->descriptions)) {
			foreach ($row->result->descriptions as $i => $description) {
				$output['descriptions'][$description->language][$source] =
					$description->description;
			}
		}
		if (!empty($row->result->commonNames)) {
			foreach ($row->result->commonNames as $i => $name) {
				$output['commonNames'][$name->language][$source] =
					$name->name;
			}

		}
	}
	return $output;
}


function printTaxonDetail ($data) {
	global $language;

  $output  = "<div class='large-2 columns'><a href='#'><i class='icon-arrow-left'></i>zoekresultaten</a></div>";

  $output .= "<div class='large-7 columns'>";

  $output .=   "<h2>";
  $output .=   "  <span class='scientific-name'>";
  $output .=        $data['acceptedName'];
  $output .=   "  </span>";

  if ( isset($data['commonNames'][$language->language]) ){
    $output .= "  <span class='vernacular-name'>";
    $output .= implode(', ', $data['commonNames'][$language->language]);
    $output .= "  </span>";
  }

  $output .=
		printCommonNames($data) .
		printDescriptions($data) .
		printClassifications($data);

  $output .= "</div>";
  $output .= "<div class='large-3 columns'>";
  $output .= printNavigation($data);
  $output .= "</div>";


  return $output;
}

// function printTaxonDetail ($data) {
//   global $language;
//
//   $output .= "<div class='large-7 columns'>";
//
//   $output .= "<h2>" . $data['acceptedName'] . " <span class='populair-name'>" .
//     (isset($data['commonNames'][$language->language]) ?
//       implode(', ', $data['commonNames'][$language->language]) : '') .
//     "</span></h2>";
//
//   $output .=
//      printCommonNames($data)
//     .printDescriptions($data)
//     .printClassifications($data);
//
//   $output .= "</div>";
//
//   $output .= "<div class='large-3 columns'>";
//   $output .=    printNavigation($data) .
//   $output .= "</div>";
//
//   return $output;
// }


// Transposes common names array and prints common names
function printCommonNames ($data) {
	$output = '';
	$header = "<h3>" . t('Common names') . "</h3>";
	if (isset($data['commonNames']) && !empty($data['commonNames'])) {
		// Transpose first
		foreach ($data['commonNames'] as $lan => $name) {
			$source = key($name);
			$names[$source][$name[$source]] = $lan;
		}
		foreach ($names as $source => $t) {
			$output .= "<h4 class='source'>$source</h4>" .
				"<table class='property-list'><tbody>";
			foreach ($t as $name => $lan) {
				$output .= "<tr><td>" . t($lan) . "</td><td>$name</td></tr>";
			}
			$output .= "</tbody></table>";
		}
	}
	return $header . (!empty($output) ? $output : t('No common names available'));
}

function printDescriptions ($data) {
	global $language;
	$output = '';
	$header = "<h3>" . t('Descriptions') . "</h3>";
	if (isset($data['descriptions']) && !empty($data['descriptions'])) {
		// Transpose first
		foreach ($data['descriptions'] as $lan => $description) {
			$source = key($description);
			$descriptions[$source][$description[$source]] = $lan;
		}
		foreach ($descriptions as $source => $t) {
			foreach ($t as $description => $lan) {
				if ($lan == $language->language) {
					$output .= "<p>$description</p>";
				}
			}
		}
	}
	return $header . (!empty($output) ? $output : t('No descriptions available'));
}

function printClassifications ($data) {
	global $language;
	$output = '';
	$header = "<h3>" . t('Classifications') . "</h3>";
	$printClassifications = array();
	// First merge two separate classification arrays
	foreach ($data['classifications']['default'] as $source => $classification) {
		$classifications[] =array(
			'source' => $source,
			'classification' => $classification
		);
	}
	foreach ($data['classifications']['system'] as $source => $classification) {
		$classifications[] = array(
			'source' => $source,
			'classification' => $classification
		);
	}
	// Check for duplicates; change key if necessary
	foreach ($classifications as $classification) {
		// Classification does not exist yet; add it
		if (!in_array(serialize($classification['classification']), $printClassifications)) {
			$printClassifications[$classification['source']] = serialize($classification['classification']);
		// Classification does exist; adapt its key
		} else {
			$printSource = array_search(serialize($classification['classification']), $printClassifications);
			$newSource = $printSource . ', ' . $classification['source'];
			$printClassifications[$newSource] = serialize($classification['classification']);
			unset($printClassifications[$printSource]);
		}
	}
	// Finally we can print the lot...
	foreach ($printClassifications as $source => $sClassification) {
		$output .= "<h4 class='source'>$source</h4>" .
			"<table class='property-list'><tbody>";
		$classification = unserialize($sClassification);
		foreach ($classification as $rank => $name) {
			$output .= "<tr><td>" . t($rank) . "</td><td>$name</td></tr>";
		}
		$output .= "</tbody></table>";
	}
	return $header . (!empty($output) ? $output : t('No classifications available'));
}

// Parses specimen detail json response into array
function parseSpecimenDetail ($json) {
	$skipFields = array(
		'objectPublic'
		// etc
	);
	if (!$json || !validJson($json)) {
		handleError('No or invalid json response');
	}
	$data = json_decode($json);
//print_r($data);
	foreach ($data->searchResults[0]->result as $field => $value) {
		if (!is_array($value) && !is_object($value) &&
			!in_array($field, $skipFields) && $value != '') {
			$output[t(translateNdaField($field))] = $value;
		}
	}
	$output['source'] = $data->searchResults[0]->result->sourceSystem->name;
	$output['names'] = getSpecimenTaxonNames($data->searchResults[0]);
	$output['otherSpecimens'] = getOtherSpecimens($data);
	$output['navigation'] = getNavigation($data);
//print_r($output);
	return $output;
}


// Return previous/next links from result set
function  getNavigation ($data) {
	if (isset($data->links) && !empty($data->links)) {
		foreach ($data->links as $link) {
			if ($link->rel == 'prev' || $link->rel == 'next') {
				$output[$link->rel] = $link->href;
			}
		}
	}
	return isset($output) ? $output : null;
}


// Print specimen detail on screen
function printSpecimenDetail ($data) {
	// Determines order to print field/value;
	// fields not in array are printed at the bottom.
	$fieldOrder = array(
		'unitGUID',
		'names'
		// etc
	);
	// Reorder input array
	$data = array_merge(array_flip($fieldOrder), $data);
	$output = "<h3>" . t('Specimen details') . "</h3>" .
		"<h5 class='source'>" . $data['source'] . "</h5>";
	// Navigation
	$output .= printNavigation($data);
	$output .= "<table class='table-property-list'><tbody>";
	foreach ($data as $field => $value) {
		if (is_array($value)) {
			// Taxon name
			if ($field == 'names') {
				$output .= printNamesWithLinks($value, 'species');
			}
		} else {
			$output .= printTableRow($field, $value);
		}
	}
	// Other specimens in collection/set are printed in different table
	if (isset($data['otherSpecimens']) && !empty($data['otherSpecimens'])) {
		$output .= "</tbody></table>" .
			"<table class='table-property-list'><tbody>";
		$output .= printNamesWithLinks($data['otherSpecimens'], 'other');
	}
	return $output . "</tbody></table>";
}

// Prints navigation on details page
function printNavigation ($data) {
	$output = "<div class='navigation'>";
	if (isset($data['navigation']) && !empty($data['navigation'])) {
		$links = array_merge(array_flip(array('prev', 'next')), $data['navigation']);
		foreach ($links as $direction => $url) {
			$t = "<div class='$direction";
			$t .= !empty($url) ?
				"'><a href='" . printDrupalLink($url) . "'>" . $direction . "</a></div>" :
				"-disabled'></div>";
			$output .= $t;
		}
	}
	return $output . "</div>";
}

// Prints taxon identifications for specimen (used only for non-name search)
function printNamesWithLinks ($details, $fieldLabel) {
	$output = '';
	foreach ($details as $i => $detail) {
		$name = isset($detail['unitGUID']) ? $detail['unitGUID'] : $detail['name'];
		$t = !empty($detail['url']) ?
			'<a href="' . printDrupalLink($detail['url']) . '">$name</a>' : $name;
		$output .= printTableRow(($i == 0 ? t($fieldLabel) : ''), $t);
	}
	return !empty($output) ? $output : null;
}

// Return other specimens for detail page
function getOtherSpecimens ($row) {
	if (!empty($row->searchResults[0]->result->otherSpecimensInSet)) {
		foreach ($row->searchResults[0]->result->otherSpecimensInSet as $i => $specimen) {
			$s = array();
			$s['unitGUID'] = $specimen->unitGUID;
			$s['collectionType'] = $specimen->collectionType;
			$s['url'] = getSpecimenInCollectionUrl($row, $i);
			$c[] = $s;
		}
	}
	return isset($c) ? $c : null;
}

function printTableRow ($field, $value) {
	return "<tr><td>" . ($field != '' ? t(translateNdaField($field)) : '') . "</td><td>" .
		($value != '' ? $value : '') . "</td></tr>";
}


// Parses multimedia json response into array
function parseMultimedia ($json) {
	if (!$json || !validJson($json)) {
		handleError('No or invalid json response');
	}
	$data = json_decode($json);
//print_r($data);
	$output['searchTerms'] = getSearchTerms($data);
	$output['total'] = getTotalRows($data);
	if (!$output['searchTerms'] || !$output['total']) {
		handleError('Invalid json response');
	}
	foreach ($data->searchResults as $row) {
		$type = isset($row->result->taxon) ? 'taxon' : 'specimen';
		$d['title'] = $row->result->title;
		$d['caption'] = $row->result->caption;
		$d['score'] = $row->score;
		$d['url'] = $row->links[0]->href;
		$d['source'] = $row->result->{$type}->sourceSystem->name;
		$d['imgSrc'] = getImageUrl($row);
		$d['hits'] = getHits($row);
		$output['results'][] = $d;
	}
	return isset($output) ? $output : false;
}


// Prints multimedia on screen
function printMultimedia ($data) {

  // $output = '<h2>' . t('Your search for') . ' ' . printMatches($data) .
	// 	' ' . t('returned') . ' ' . $data['total'] . ' ' . t('images') . ".</h2>\n" .
	// 	"<h3 class='results-set-header'>" . t('Multimedia') . "</h3>\n" .
	// 	"<div class='col-results-set'>\n";

  $output  = sprintf('<h2>%s <span class="count">(%d)</span></h2>', t('Multimedia'), $data['total'] );
  $output  .= "<div class='multimedia-wrapper'>";


  foreach ($data['results'] as $i => $row) {
		$w = "240";
    $h = 100 + $i * 50;

    $row['imgSrc'] = "http://lorempixel.com/$w/$h/nature";

    $output .=
      "<a class='polaroid' href='" . printDrupalLink($row['url']). "' title='" . $row['title'] . "'>" .
      "  <div class='polaroid-image' style='background-image: url(" . $row['imgSrc']. ");' alt='" . $row['title'] . "'></div>" .
      "  <div class='polaroid-caption'>".
      "    <div class='image-title'>" . $row['caption'] . "</div>" .
			"    <div class='image-hits'>" . printHits($row) . "</div>" .
			// "    <div class='image-source'>" . $row['source'] . "</div>".
      "  </div>".
      "</a>";
	}

  $output .=  "</div>";

  return _markUp($output);
}


// Prints matches on screen
function printMatches ($data) {
	$output = '';
	if (isset($data['searchTerms']) && !empty($data['searchTerms'])) {
		foreach ($data['searchTerms'] as $term) {
			$output .= '<span class="result-query">' . $term . '</span>, ';
		}
	}
	return substr($output, 0, -2);
}

// Returns specimens searched for other fields but taxon
function parseSpecimens ($json) {
	if (!$json || !validJson($json)) {
		handleError('No or invalid json response');
	}
	$data = json_decode($json);
	$output['searchTerms'] = getSearchTerms($data);
	$output['total'] = getTotalRows($data);
	if (!$output['searchTerms'] || !$output['total']) {
		handleError('Invalid json response');
	}
	foreach ($data->searchResults as $row) {
		$d = array();
		$d['unitGUID'] = $row->result->unitGUID;
		$d['url'] = $row->links[0]->href;
		$d['names'] = getSpecimenTaxonNames($row);
		$d['hits'] = getHits($row);
		$d['source'] = $row->result->sourceSystem->name;
		$d['score'] = $row->score;
		$output['results'][] = $d;
	}
	return isset($output) ? $output : false;
}



// Prints specimen result set on screen.
function printSpecimens ($data, $p = array('sortColumn' => 0, 'sortDirection' => 'asc')) {
	$headers = array(
		array(
			'label' => t('Specimen'),
			'sort' => 1,
			'icon' => 'icon-sort-by-alphabet',
			'url' => '#'
		),
		array(
			'label' => t('Species'),
			'sort' => 1,
			'icon' => 'icon-sort-by-alphabet',
			'url' => '#'
		),
		array(
			'label' => t('Found in'),
			'sort' => 0
		),
		array(
			'label' => t('Match'),
			'sort' => 1,
			'icon' => 'icon-sort-by-attributes',
			'url' => '#'
		)
	);

  $output  = sprintf('<h2>%s <span class="count">(%d)</span></h2>', t('Specimens'), $data['total'] );
  $output .= sprintf('<table><thead>%s</thead><tbody>', printHeaders($headers, $p) );

  foreach ($data['results'] as $i => $row) {
		$output .= "<tr>";
		// Registration number plus hits
		$output .= "<td><a href='" . printDrupalLink($row['url']) . "'>" . $row['unitGUID'] . "</a>" .
			(!empty($row['hits']) ? '</br>' . printHits($row) : '') .
			"</td>";
		// Species
		$output .= "<td>" . printSpecimenTaxa($row['names']) . "</td>";
		// Source(s)
		$output .= "<td>" . $row['source'] . "</td>";
		// Match
		$output .= "<td>" . decorateScore($row['score']) . "</td>";
		$output .= "</tr>";
	}
	return $output . "</tbody></table>";
}


// Prints hits as field: hits;
// replaces default <span> with <span class="result-query">
function printHits ($row) {
	$output = '';
	if (isset($row['hits']) && !empty($row['hits'])) {
		foreach ($row['hits'] as $field => $hit) {
			$output .= t(translateNdaField($field)) . ': ' .
				str_replace('<span>', '<span class="result-query">', $hit) . '</br>';
		}
	}
	return !empty($output) ? substr($output, 0, -5) : null;
}


// Prints taxon identifications for specimen (used only for non-name search)
function printSpecimenTaxa ($names) {
	$output = '';
	foreach ($names as $name) {
		$t = $name['name'];
		$t = !empty($name['url']) ?
			'<a href="' . printDrupalLink($name['url']) . '">' . $name['name'] . '</a>, ' :
			$t . ', ';
		$output .= $t;
	}
	return !empty($output) ? substr($output, 0, -2) : null;
}


// Returns taxon names for specimens plus their url found by other fields but name
// (for specimens found by taxon name only a single name is returned!)
function getSpecimenTaxonNames ($row) {
	foreach ($row->result->identifications as $i => $id) {
		$output[] = array(
			'name' => formatScientificName(
				$id->scientificName->fullScientificName,
				$id->scientificName
			),
			'url' => getSpecimenTaxonUrl($row, $i)
		);
	}
	return isset($output) ? $output : false;
}


// Returns url for a taxon associated with the specimen
function getSpecimenTaxonUrl ($row, $i) {
	if (!empty($row->links)) {
		foreach ($row->links as $link) {
			if ($link->rel == "identifications[{$i}].scientificName.fullScientificName") {
				return $link->href;
			}
		}
	}
	return null;
}



// Parses specimen json response into array; searched by taxon
function parseSpecimensByTaxon ($json) {
	if (!$json || !validJson($json)) {
		handleError('No or invalid json response');
	}
	$data = json_decode($json);
//print_r($data);
	$output['searchTerms'] = getSearchTerms($data);
	$output['total'] = getTotalRows($data);
	if (!$output['searchTerms'] || !$output['total']) {
		handleError('Invalid json response');
	}
	foreach ($data->resultGroups as $row) {
		$d = array();
		$d['name'] = formatScientificName(
			$row->searchResults[0]->matchInfo[0]->value,
			$row->searchResults[0]->result->identifications[getResultOffset($row)]->scientificName,
			$output['searchTerms']
		);
		$d['url'] = $row->links[0]->href;
		$d['count'] = count($row->searchResults);
		$d['sources'] = getSources($row);
		$d['score'] = $row->searchResults[0]->score;

		// Specimens are stored in a subarray. Brahms may feature "specimen collections"
		// (or, in other words, a set),  which are virtual entities collecting different parts of the same individual,
		// e.g. leaves, fruits and flowers of the same plant. If the "collection" contains just
		// one specimen (as in CRS), there's only a single specimen in the "collection".
		$c = $s = array();
		// Collection/set
		$c['setId'] = $row->searchResults[0]->result->setID;
		// Specimen(s)
		$s['unitGUID'] = $row->searchResults[0]->result->unitGUID;
		$s['collectionType'] = $row->searchResults[0]->result->collectionType;
		$s['url'] = $row->searchResults[0]->links[0]->href;
		$otherSpecimens = getOtherSpecimens($row);
		$c['specimens'] = !empty($otherSpecimens) ? array_merge(array($s), $otherSpecimens) : array($s);
		$d['set'] = $c;
		$output['results'][] = $d;
	}
	return isset($output) ? $output : false;
}



// Returns image properties
function getImageUrl ($row) {
	$key = key(get_object_vars($row->result->serviceAccessPoints));
	return $row->result->serviceAccessPoints->{$key}->accessUri;
}


// Return the field containing the hit
function getHits ($row) {
	foreach ($row->matchInfo as $info) {
		$e = explode('.', $info->path);
		$hits[end($e)] = $info->valueHighlighted;
	}
	return isset($hits) ? $hits : array();
}


// Prints specimen result set on screen.
function printSpecimensByTaxon ($data, $p = array('sortColumn' => 0, 'sortDirection' => 'asc')) {
	$headers = array(
		array(
			'label' => t('Name'),
			'sort' => 1,
			'icon' => 'icon-sort-by-alphabet',
			'url' => '#'
		),
		array(
			'label' => t('Number'),
			'sort' => 1,
			'icon' => 'icon-sort-by-attributes',
			'url' => '#'
		),
		array(
			'label' => t('Found in'),
			'sort' => 0
		),
		array(
			'label' => t('Match'),
			'sort' => 1,
			'icon' => 'icon-sort-by-attributes',
			'url' => '#'
		)
	);

  // $output = '<h2>' . t('Your search for') . ' ' . printMatches($data) .
	// 	' ' . t('returned') . ' ' . $data['total'] . ' ' . t('specimens') . ".</h2>\n" .
	// 	"<h3 class='results-set-header'>" . t('Species with specimens') . "</h3>\n" .
	// 	"<table class='table'><thead>" . printHeaders($headers, $p) .
	// 	"</thead><tbody>";

  $output  = sprintf('<h2>%s %s %s <span class="count">(%d)</span></h2>', t('Specimens with'), printMatches($data), t(' occuring in the species&apos; name.'),$data['total'] );

  $output .= sprintf('<table id="specimensByTaxon"><thead>%s</thead>', printHeaders($headers, $p) );

  foreach ($data['results'] as $i => $row) {
		$output .= "<tr class='indent-0' id='taxon-$i'>";
		// Name
		$output .= "<td><a href='" . printDrupalLink($row['url']) . "'>" . $row['name'] . "</a>" .
			(!empty($row['commonNames']) ? '</br>' . implode(', ', array_keys($row['commonNames'])) : '') .
			"</td>";
		// Number (and collection type)
		$output .= "<td>" . $row['count'] . ' ' . ($row['count'] > 1 ? t('specimens') : t('specimen')) . "</td>";
		// Source(s)
		$output .= "<td>" . implode('</br>', $row['sources']) . "</td>";
		// Match
		$output .= "<td>" . decorateScore($row['score']) . "</td>";
		$output .= "</tr>";
		$output .= printSpecimenCollection($row, $i);
	}

  $output .= "</table>";
  return _markUp($output);
}




// Returns collection/set of specimens or just a specimen if a collection contains a single entry
function printSpecimenCollection ($row, $i) {
	// Single specimen

  if (empty($row['set']['setId'])) {
		return "<tr class='indent-1' id='taxon-$i-specimen-0' data-parent='taxon-$i'><td><a href='" .
		    printDrupalLink($row['set']['specimens'][0]['url']) . "'>" .
			$row['set']['specimens'][0]['unitGUID'] . "</a></td>" . padTds(3) . "</tr>";
	}

  // Specimen collection/set
	$output = "<tr class='indent-1' id='taxon-$i-collection' data-parent='taxon-$i'><td>Brahms " .
	   $row['set']['setId'] . "</td>" . padTds(3) . "</tr>";
	foreach ($row['set']['specimens'] as $j => $specimen) {
		$output .= "<tr class='indent-2' id='taxon-$i-specimen-$j' data-parent='taxon-$i-collection'>"
      . "<td><a href='" . printDrupalLink($specimen['url']) . "'>"
      .$specimen['unitGUID'] . "</a></td>" . padTds(1) . "<td>" .
			t(translateNdaField($specimen['collectionType'])) . "</td>" . padTds(1) . "</tr>";
	}
	return $output;
}

// Shorthand function to pad "filler" tds
function padTds ($i) {
	if ((int)$i > 0) {
		return str_repeat("<td></td>", $i);
	}
}

// Return url for specimens in "collection"/set
function getSpecimenInCollectionUrl ($row, $i) {
	if (!empty($row->searchResults[0]->links)) {
		foreach ($row->searchResults[0]->links as $link) {
			if ($link->rel == 'specimen-detail.otherSpecimensInSet.' . $i) {
				return $link->href;
			}
		}
	}
	return null;
}

// Prints headers of result table on screen
function printHeaders ($headers, $p) {
	$output = "<tr>";

  foreach ($headers as $i => $header) {
		$class = "";

    if ( $i == 0)                    { $class="column-first"; }
    if ( $header['label'] == "Match"){ $class="column-match"; }

    $output .= "<th class='$class'>";

    if ($header['sort'] == 1) {
			// Selected header
			if ($i == $p['sortColumn']) {
				$header['url'] .= ($p['sortDirection'] == 'asc' ? '&desc' : '&asc');
				$output .= "<a href='" . printDrupalLink($header['url']) . "'>" .
					$header['label'] . "</a>" .
					"<a href='" . printDrupalLink($header['url']) . "'>" .
					"<span class='sortable glyphicon " . $header['icon'] .
					($p['sortDirection'] == 'desc' ? "-alt" : "") . "'></span></a>";
			// Other headers
			} else {
				$header['url'] .= '&desc';
				$output .= "<a href='" . printDrupalLink($header['url']) . "'>" .
					$header['label'] . "</a>" .
					"<a href='" . printDrupalLink($header['url']) . "'>" .
					"<span class='sortable glyphicon icon-sort'></span></a>";
			}
		} else {
			$output .= $header['label'];
		}
		$output .= "</th>";
	}
	return $output . "</tr>";
}

// Parses taxon/species json response into array
function parseTaxa ($json) {
	if (!$json || !validJson($json)) {
		handleError('No or invalid json response');
	}
	$data = json_decode($json);

	$output['total'] = getTotalRows($data);
	$output['searchTerms'] = getSearchTerms($data);
	if (!$output['searchTerms'] || !$output['total']) {
		handleError('Invalid json response');
	}
	foreach ($data->resultGroups as $row) {
		$d = array();
		// Accepted scientific name, synonym, or common name
		$d['type'] = getResultType($row);
		if ($d['type'] == 'accepted') {
			$d['name'] = formatScientificName(
				$row->searchResults[0]->matchInfo[0]->value,
				$row->searchResults[0]->result->acceptedName,
				$output['searchTerms']
			);
		} else if ($d['type'] == 'synonym') {
			$d['name'] = formatScientificName(
				$row->searchResults[0]->matchInfo[0]->value,
				$row->searchResults[0]->result->synonyms[getResultOffset($row)]->scientificName,
				$output['searchTerms']
			);
		} else if ($d['type'] == 'common') {
			$d['name'] = highlightMatch(
				$row->searchResults[0]->matchInfo[0]->value,
				$output['searchTerms']
			);
		}
		$d['acceptedName'] = (
			$d['type'] == 'accepted' ?
			$d['name'] :
			formatScientificName(
				$row->searchResults[0]->result->acceptedName->fullScientificName,
				$row->searchResults[0]->result->acceptedName
			)
		);
		$d['rank'] = $row->searchResults[0]->result->taxonRank;
		$d['url'] = $row->links[0]->href;
		$d['sources'] = getSources($row);
		$d['commonNames'] = ($d['type'] != 'common' ? getCommonNames($row) : array());
		$d['score'] = $row->searchResults[0]->score;
		$output['results'][] = $d;
	}
	return isset($output) ? $output : false;
}




/* Prints taxon result set on screen. Parameters $p should contain:
   'sortColumn', 'sortDirection'

   TODO:
   1. Set truncated (for overview)/non-truncated
   2. Pass $p['total'] dynamically

*/
function printTaxa ($data, $p = array('sortColumn' => 0, 'sortDirection' => 'asc')) {
	$headers = array(
		array(
			'label' => t('Name'),
			'sort' => 1,
			'icon' => 'icon-sort-by-alphabet',
			'url' => '#'
		),
		array(
			'label' => t('Description'),
			'sort' => 0
		),
		array(
			'label' => t('Found in'),
			'sort' => 0
		),
		array(
			'label' => t('Match'),
			'sort' => 1,
			'icon' => 'icon-sort-by-attributes',
			'url' => '#'
		)
	);

  $output  = sprintf('<h2>%s <span class="count">(%d)</span></h2>', t('Species names'), $data['total'] );
  $output .= sprintf('<table><thead>%s</thead><tbody>', printHeaders($headers, $p) );

  foreach ($data['results'] as $i => $row) {
		$output .= "<tr>";

    // Name
		$output .= "<td>";
    $output .= "<a href='" . printDrupalLink($row['url']) . "'>" . $row['name'] . "</a>";
		$output .= (!empty($row['commonNames']) ? '</br>' . implode(', ', array_keys($row['commonNames'])) : '');
		$output .=	"</td>";

    // Description
    $output .= "<td>" . decorateDescription($row) . "</td>";

    // Source(s)
    $output .= "<td>" . implode('</br>', $row['sources']) . "</td>";

    // Match
		$output .= "<td>" . decorateScore($row['score']) . "</td>";

    $output .= "</tr>";
	}

  $output .= "</tbody></table>";
  $output = _markUp($output);

	return $output;
}

// Validates json string
function validJson ($string) {
	return is_object(json_decode($string));
}

// Returns type of result:
// acceptedName.fullScientificName
// acceptedName.synonyms[0].scientificName.fullScientificName
// acceptedName.commonNames[0].name
function getResultType ($row) {
	$path = $row->searchResults[0]->matchInfo[0]->path;
	return strpos($path, 'synonym') !== false ? 'synonym' :
		(strpos($path, 'commonName') !== false ? 'common' : 'accepted');
}

// Returns offset of result; used only for synonyms and common names
// to determine the array key containing the hit
// Used for taxon/specimenByTaxon
function getResultOffset ($row) {
	preg_match('/\[(.*?)\]/', $row->searchResults[0]->matchInfo[0]->path, $m);
	return $m[1];
}

// Returns total number of results
function getTotalRows ($data) {
	if (isset($data->totalSize)) {
		return (int)$data->totalSize;
	}
	return false;
}

// Returns total number of results
function getSearchTerms ($data) {
	if (isset($data->searchTerms)) {
		return (array)$data->searchTerms;
	}
	return false;
}

// Results formatted accepted name with proper use of italics
function formatScientificName ($scientificname, $nameObject, $searchTerm = false) {
	$output = $scientificname;
	$elements = getScientificNameElements($nameObject);
	foreach ($elements as $e) {
		if (!empty($e)) {
			$output = str_replace($e, '<span class="scientific">' . $e . '</span>', $output);
		}
	}
	// Highlight the formatted output
	return $searchTerm ? highlightMatch($output, $searchTerm) : $output;
}

// Returns scientific name elements from name object
// Store as keys and flip to avoid duplicates (as in Larus fuscus fuscus)
function getScientificNameElements ($name) {
	$elements = array(
		$name->genusOrMonomial => 0,
		$name->subgenus => 1,
		$name->specificEpithet => 2,
		$name->infraspecificEpithet => 3
	);
	return array_flip($elements);
}

// Returns all sources for taxon/specimen
function getSources ($row) {
	foreach ($row->searchResults as $i => $obj) {
		$output[$obj->result->sourceSystem->name] = $i;
	}
	return isset($output) ? array_flip($output) : false;
}

// Returns common names for the current interface language;
// format is array(name => language), so duplicates will be avoided
function getCommonNames ($row, $languageCheck = false) {
	global $language;
	foreach ($row->searchResults as $i => $taxon) {
		if (isset($taxon->result->commonNames)) {
			foreach ($taxon->result->commonNames as $name) {
				// If language is set, only store when language of
				// common name matches that of interface...
				if ($languageCheck) {
					if ($name->language == $language->language) {
						$output[$name->name] = $name->language;
					}
				// ... else always return all names
				} else {
					$output[$name->name] = $name->language;
				}
			}
		}
	}
	return isset($output) ? $output : false;
}


// Decorate description in taxon result table
function decorateDescription ($row) {
	return ($row['type'] != 'accepted' ?
		t(ucfirst($row['type'])) . ($row['type'] == 'common' ? ' ' . t('name') : '') .
		' ' . t('for') . ' ' :  '') . ($row['type'] == 'accepted' ? t(ucfirst($row['rank'])) :
		t($row['rank'])) . ' ' . $row['acceptedName'];
}

// Decorate score in result table
function decorateScore ($score) {
	$score = round($score * 100);
	$roundScore = round( $score / 20 );
  $result = "<span class='score' title='$score %'>";

  for ( $i=1; $i<=5; $i++ ){
    if ( $i <= $roundScore ){
      $result.= "<span class='square-filled'>&FilledSmallSquare;</span>";
    } else {
      $result.= "<span class='square-empty'>&EmptySmallSquare;</span>";
    }
  }

  $result .= "</span>";
  return $result;

  //return "<span class='score'><span class='score-bar' style='width: $score%'></span><span class='score-text'>$score%</span></span>";
}

// Highlight match
function highlightMatch($haystack, $needles) {
	foreach ($needles as $needle) {
		if (stripos(strip_tags($haystack), $needle)===false || is_null($needle)) {
			continue;
		}
		$q = str_split($needle);
		$x = ')(\<[^<]*\>)*(';
		$q = str_replace('( )','(\s*)','('.implode($x, $q).')');
		$haystack = preg_replace_callback('/'.$q.'/i','_fsub1', $haystack);
	}
	return $haystack;
}

function _fsub1($m) {
	return "<span class='result-query'>".preg_replace_callback('(<(.*?)>)','_fsub2',$m[0])."</span>";
}

function _fsub2($m) {
	return '</span>'.$m[0]."<span class='result-query'>";
}

function sortArrayByArray ($array, $orderArray) {
    $ordered = array();
    foreach ($orderArray as $key) {
        if (array_key_exists($key,$array)) {
            $ordered[$key] = $array[$key];
            unset($array[$key]);
        }
    }
    return $ordered + $array;
}


// Wrapper for Drupal error handler
function handleError ($message) {
	die($message);
}


// Should be replaced with a function that translates NDS field labels to proper English
function translateNdaField ($str) {
	return $str;
}

// Create Drupal specific link
function printDrupalLink ($url) {
	return "http://drupal/?nda_request=" . urlencode($url);
}

function _markUp($string){
  $result = $string;
  $result = preg_replace('/^\s+|\n|\r|\s+$/m', '', $result);

  $result = str_replace(
    array("    <h2",  "<table",        "<thead",      "<tbody",      "<tr",        "<td",        "<th ",   "<a class='polaroid'"),
    array("\n\n<h2","\n\n<table","\n\n\t<thead","\n\n\t<tbody","\n\t\t<tr","\n\t\t\t<td","\n\t\t\t<th ", "\n<a class='polaroid' "),
    $result
  );

  $result = str_replace(
    array(  "</table",    "</thead",    "</tbody",     "</tr",        "</td",        "</th>"),
    array("\n</table","\n\t</thead","\n\t</tbody","\n\t\t</tr","\n\t\t\t</td","\n\t\t\t</th>"),
    $result
  );

  return $result;
}






/*
 * DUMMY functions to print mock data on screen. Please keep this at the bottom of this document
 * so these can removed easily once markup has been completed and NDA services run properly
 */
function DUMMYmapNdaRequests() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	'all' => 'group-taxa-by-name.json|groupSpecimenBySpecificName.json|getSpecimensForOtherSearchTerms.json|getMediaObjects.json',
        	'taxa' => 'group-taxa-by-name.json',
        	'specimensByTaxon' => 'groupSpecimenBySpecificName.json',
        	'specimens' => 'groupSpecimenBySpecificName.json',
        	'multimedia' => 'getMediaObjects.json',
        	'taxonDetail' => 'taxon-detail.json',
        	'specimenDetail' => 'specimen-detail.json',
        	'taxonMediaDetail' => 'taxon-media-detail.json',
        	'specimenMediaDetail' => 'specimen-media-detail.json'
        );
    }
    return $var;
}

function DUMMYresultOrder() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	'getMediaObjects.json',
        	'group-taxa-by-name.json',
        	'groupSpecimenBySpecificName.json',
        	'getSpecimensForOtherSearchTerms.json'
        );
    }
    return $var;
}

function DUMMYserviceToFunctions() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	'group-taxa-by-name.json' => array(
        		'parse' => 'parseTaxa',
        		'print' => 'printTaxa'
        	),
        	'groupSpecimenBySpecificName.json' => array(
        		'parse' => 'parseSpecimensByTaxon',
        		'print' => 'printSpecimensByTaxon'
        	),
        	'getMediaObjects.json' => array(
        		'parse' => 'parseMultimedia',
        		'print' => 'printMultimedia'
        	),
        	'getSpecimensForOtherSearchTerms.json' => array(
        		'parse' => 'parseSpecimens',
        		'print' => 'printSpecimens'
        	),
        	'specimen-detail.json' => array(
        		'parse' => 'parseSpecimenDetail',
        		'print' => 'printSpecimenDetail'
        	),
        	'taxon-detail.json' => array(
        		'parse' => 'parseTaxonDetail',
        		'print' => 'printTaxonDetail'
        	),
        	'taxon-media-detail.json' => array(
        		'parse' => 'parseTaxonMediaDetail',
        		'print' => 'printTaxonMediaDetail'
        	),
        	'specimen-media-detail.json' => array(
        		'parse' => 'parseSpecimenMediaDetail',
        		'print' => 'printSpecimenMediaDetail'
        	)
        );
    }
    return $var;
}

function DUMMYperformNdaRequest ($request = false) {
    $serviceToFunctions = DUMMYserviceToFunctions();
	// Translate request url to curl channels
	$channels = DUMMYsetChannels($request);
	if (empty($channels)) {
		handleError('Cannot set curl channels');
	}
	// Get json response(s) with curl
	$remoteData = DUMMYqueryNda($channels);
	// Reorder responses in print order if more than one response
	if (count($remoteData) > 1) {
	   $remoteData = sortArrayByArray($remoteData, DUMMYresultOrder());
	}
	// Map functions to each channel result:
	// parses and prints data
	$output = '';
	foreach ($remoteData as $service => $json) {
		if (!isset($serviceToFunctions[$service]) || empty($json)) {
			continue;
		}
		$parseFunction = $serviceToFunctions[$service]['parse'];
		$printFunction = $serviceToFunctions[$service]['print'];
		$output .= $printFunction($parseFunction($json));
	}
	return $output;
}


function DUMMYsetChannels ($request = false) {
	$mapNdaRequests = DUMMYmapNdaRequests();
	if (!$request || !isset($mapNdaRequests[$request])) {
		return false;
	}
	$t = explode('|', $mapNdaRequests[$request]);
	foreach ($t as $i => $url) {
		$channels[$i]['request'] = $url;
		$channels[$i]['url'] = 'http://dev2.etibioinformatics.nl/nda/' . $url;
	}
	return $channels;
}

function DUMMYqueryNda ($channels = array(), $timeout = false) {
    $mh = curl_multi_init();
    for ($i = 0; $i < count($channels); $i++) {
        $ch[$i] = curl_init();
        curl_setopt($ch[$i], CURLOPT_URL, $channels[$i]['url']);
        curl_setopt($ch[$i], CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch[$i], CURLOPT_HEADER, false);
        if ($timeout) {
       		curl_setopt($ch[$i], CURLOPT_TIMEOUT, $timeout);
        }
        curl_multi_add_handle($mh, $ch[$i]);
    }
    // While we're still active, execute curl
	do {
		$mrc = curl_multi_exec($mh, $active);
	} while ($mrc == CURLM_CALL_MULTI_PERFORM);

    while ($active && $mrc == CURLM_OK) {
        // Wait for activity on any curl-connection
        if (curl_multi_select($mh) == -1) {
            usleep(1);
        }
        // Continue to exec until curl is ready to
        // give us more data
        do {
            $mrc = curl_multi_exec($mh, $active);
        } while ($mrc == CURLM_CALL_MULTI_PERFORM);
    }
    // Place results in results array and close handlers
    for ($i = 0; $i < count($channels); $i++) {
        $remoteData[$channels[$i]['request']] = curl_multi_getcontent($ch[$i]);
        curl_multi_remove_handle($mh, $ch[$i]);
    }
    curl_multi_close($mh);
    return $remoteData;
}
