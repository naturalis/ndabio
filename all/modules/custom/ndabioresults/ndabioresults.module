<?php

/**
 * @file
 * Naturalis example module.
 */

/**
 * Defaults.
 */
define('NATURALIS', 'taxonDetail');

/**
* DEFINE CUSTOM PAGES
*/

function gettaxonomyidbysystem($systemname) {
  $sql = "SELECT entity_id FROM {field_data_field_ndasystem} WHERE field_ndasystem_value = '$systemname'";
  return db_query($sql)->fetchField();
}

function gettaxonomybysystem($systemname) {
  //$sql = "SELECT description FROM {taxonomy_term_data} WHERE tid = " . gettaxonomyidbysystem($systemname) . "";
  $sql = "SELECT description FROM {taxonomy_term_data} WHERE name = '$systemname'";
  return t(db_query($sql)->fetchField());
}

/**
 * Implements hook_menu().
 */
function ndabioresults_menu() {
  global $language;

  $items['admin/config/naturalis/ndaresult'] = array(
    'title' => 'NDA result config',
    'description' => 'Configuration for Naturalis module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ndabioresults_config_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['nba/result/%'] = array(
    'page callback' => 'ndabioresults_pass',
    //'page arguments' => array(1), //0 = nda, 1 = pass, 2 = *.
    'load arguments' => array('%map', '%index'),
    'access callback' => TRUE,
  );
  $items['nba/result'] = array(
    'page callback' => 'ndabioresults_pass',
    //'page arguments' => array(1), //0 = nda, 1 = pass, 2 = *.
    'load arguments' => array('%map', '%index'),
    'access callback' => TRUE,
  );

  return $items;
}


function ndabioresults_config_form($form, &$form_state) {
  $form['ndabioresults_config'] = array(
    '#type' => 'fieldset',
    '#title' => t('Naturalis config')
  );

  //NBA Base URL
  $form['ndabioresults_config']['ndabioresults_config_baseurl'] = array(
    '#type' => 'textfield',
    '#title' => t('NBA base URL'),
    '#default_value' => variable_get('ndabioresults_config_baseurl', "http://nba.naturalis.nl/"),
    '#size' => 140,
    '#maxlength' => 200,
    '#description' => t('The base URL of the NBA.'),
    '#required' => TRUE
  );



  return system_settings_form($form);
}

/**
 * Implements hook_block_info().
 */
function ndabioresults_block_info() {
  $blocks['ndabioresults_collected_date'] = array(
    'info' => t('NBA: Search result collected'),
    'visibility' => BLOCK_VISIBILITY_LISTED,
    'pages' => "nba/result\nnba/result*",
    'region' => "sidebar_first",
    'status' => TRUE,
  );
  $blocks['ndabioresults_source'] = array(
    'info' => t('NBA: Search result source'),
    'visibility' => BLOCK_VISIBILITY_LISTED,
    'pages' => "nba/result",
    'region' => "sidebar_first",
    'status' => TRUE,
  );
  $blocks['ndabioresults_category'] = array(
    'info' => t('NBA: Search result category'),
    'visibility' => BLOCK_VISIBILITY_LISTED,
    'pages' => "nba/result\nnba/result*",
    'region' => "sidebar_first",
    'status' => TRUE,
  );
  $blocks['ndabioresults_back'] = array(
    'info' => t('NBA: Search result back button'),
    'visibility' => BLOCK_VISIBILITY_LISTED,
    'pages' => "nba/result\nnba/result*",
    'region' => "sidebar_first",
    'status' => TRUE,
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function ndabioresults_block_view($delta = '') {
  global $base_root, $base_path;
  $block = array();

  $_link_enabled =  array('attributes' => array('class' => 'filter-enabled'));
  $_link_disabled =  array('attributes' => array('class' => 'filter-disabled'));
  $_link_active =  array('attributes' => array('class' => 'filter-active'));

  switch ($delta) {
    case 'ndabioresults_collected_date':
      $block['subject'] = t('Collection date');

      $block['content'] =
        _list_items( array(
          _item(array('All periods','filter-selected')),
          _item(array('After 2010' ,'filter-enabled')),
          _item(array('Before 2010','filter-enabled')),
          _item(array('custom'     ,'filter-enabled','')),
        ));

      break;

    case 'ndabioresults_source':
      $block['subject'] = t('Sources');

      $block['content'] =
        _list_items( array(
          _item(array('Naturalis',          'filter-selected')),
          _item(array('the Netherlands',    'filter-disabled')),
          _item(array('Worldwide & the Web','filter-disabled')),
        ));

      break;

    case 'ndabioresults_category':
      $block['subject'] = t('Categories');

      $block['content'] =
        _list_items( array(
          _item(array('Multimedia'  ,'filter-selected')),
          _item(array('Taxons'      ,'filter-selected')),
          _item(array('Specimen'    ,'filter-selected')),
          _item(array('Observations','filter-disabled')),
        ));

      break;

	case 'ndabioresults_back':
      $block['subject'] = t('Back to search');

      $starturl = $base_root . $base_path;
      if (isset($_SESSION['ndaSearch']['geoShape'])) $starturl .= "geographic-search/";
      
      $block['content'] = "<a href='" . $starturl . "?searchagain=1'>" . t('Back to search') . "</a>";

      break;
  }
  return $block;
}

function _list_items($arr_items){

  $str_return = "<ul class='no-bullets'>";

  foreach($arr_items as $item){
    $str_return .=
       "<li>"
      ."  <a class='".$item['class']."'>"
      .     $item['data']
      ."  </a>"
      ."</li>";
  }

  $str_return .= "</ul>";

  return $str_return;
}

function _item($arr_item){
  return array(
    'data' => $arr_item[0],
    'class' => $arr_item[1],
    'value' => isset($arr_item[2]) ? $arr_item[2] : null
  );
}




/**
 * Constant: base url of NBA service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function ndaBaseUrl() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'http://10.42.1.163:8080/nl.naturalis.nda.service.rest/api/';
    }
    return $var;
}

/**
 * Constant: name of specimen service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function specimenService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'specimen/search';
    }
    return $var;
}

/**
 * Constant: name of specimen name service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function specimenNamesService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'specimen/name-search';
    }
    return $var;
}

/**
 * Constant: name of specimen detail service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function specimenDetailService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'specimen/get-specimen';
    }
    return $var;
}

/**
 * Constant: name of multimedia per specimen service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function specimenMultimediaService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'multimedia/get-multimedia-object-for-specimen-within-result-set';
    }
    return $var;
}

/**
 * Constant: name of taxon service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function taxonService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'taxon/search';
    }
    return $var;
}

/**
 * Constant: name of taxon detail service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function taxonDetailService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'taxon/get-taxon';
    }
    return $var;
}

/**
 * Constant: name of multimedia per taxon service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function taxonMultimediaService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'multimedia/get-multimedia-object-for-taxon-within-result-set';
    }
    return $var;
}

/**
 * Constant: name of multimedia service
 *
 * @todo Config option in module?
 *
 * @return string
 */
function multimediaService() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = 'multimedia/search';
    }
    return $var;
}

/**
 * Constant: order of search results output
 *
 * Determines print order of search result, currently
 * multimedia, taxon, specimen name, specimen.
 *
 * @return array
 */
function resultOrder() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	multimediaService(),
        	taxonService(),
        	specimenNamesService(),
        	specimenService()
        );
    }
    return $var;
}

/**
 * Mapping function: maps service to parse/print functions
 *
 * Each service response is handled by distinct parse and
 * print functions. This function provides the mapping.
 *
 * @return array Names of parse and print function for the service of choice
 */
function serviceToFunctions() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	taxonService() => array(
        		'parse' => 'parseTaxa',
        		'print' => 'printTaxa'
        	),
        	specimenNamesService() => array(
        		'parse' => 'parseSpecimensByTaxon',
        		'print' => 'printSpecimensByTaxon'
        	),
        	multimediaService() => array(
        		'parse' => 'parseMultimedia',
        		'print' => 'printMultimedia'
        	),
        	specimenService() => array(
        		'parse' => 'parseSpecimens',
        		'print' => 'printSpecimens'
        	),
        	specimenDetailService() => array(
        		'parse' => 'parseSpecimenDetail',
        		'print' => 'printSpecimenDetail'
        	),
        	taxonDetailService() => array(
        		'parse' => 'parseTaxonDetail',
        		'print' => 'printTaxonDetail'
        	),
        	taxonMultimediaService() => array(
        		'parse' => 'parseTaxonMediaDetail',
        		'print' => 'printTaxonMediaDetail'
        	),
        	specimenMultimediaService() => array(
        		'parse' => 'parseSpecimenMediaDetail',
        		'print' => 'printSpecimenMediaDetail'
        	)
        );
    }
    return $var;
}

/**
 * Mapping function: distributes parameters to appropriate specimen service
 *
 * Distributes specimens search parameters between specimen and specimen name
 * services. Important: list of parameters hould be complete!
 *
 * @param array $sP Search parameters
 * @param string $type Service type
 *
 * @return array Reduced array of search criteria for the service of choice
 */
function setSpecimenParameters (array $sP, $type) {
    $parameters = array(
        specimenService() => array(
            'collectingStartDate',
            'collectionFieldNumber',
            'gatheringAgent',
            'localityText',
            'phaseOrStage',
            'unitID',
            'sex',
            'taxonomicStatus',
            'typeStatus'
        ),
        specimenNamesService() => array(
            'className',
            'family',
            'genusOrMonomial',
            'kingdom',
            'order',
            'phylum',
            'speciesEpithet',
            'subspeciesEpithet',
            'vernacularName'
        )
    );
    foreach ($parameters[$type] as $p) {
        if (isset($sP[$p]) && (!empty($sP[$p]) || is_numeric($sP[$p]))) {
            $d[$p] = $sP[$p];
        }
    }
    // If any parameters are found, append andOr and geoShape (if applicable)
    if (isset($d)) {
        $d['_andOr'] = $sP['_andOr'];
        if (!empty($sP['geoShape'])) {
            $d['geoShape'] = $sP['geoShape'];
        }
    }
    return isset($d) ? $d : null;
}

/**
 * Accepts search form data and returns formatted result
 *
 * The main function that actually processes the incoming POST data, stores the
 * POST data in a SESSION, distributes the search to the appropriate channels
 * and returns the formatted output.
 *
 * @todo For the time being it just prints the appropriate NDA request urls on screen
 * plus displays mock data using DUMMYperformNdaRequest(). Adapt performNdaRequest() and
 * delete DUMMY functions.
 *
 * @return string The formatted output
*/
function ndabioresults_pass ($args = "") {
//    echo '<pre>'; print_r($_POST); echo '</pre>';

    // POST data from the search form?
    // If so, add to SESSION or replace existing SESSION data
    if (isset($_POST['form_id']) && $_POST['form_id'] == 'ndabio_advanced_taxonomysearch') {
        $_SESSION['ndaSearch'] = $_POST;
    }
    // GET data from within NDA response?
    // Forward directly to appropriate service
    else if (isset($_GET['nba_request'])) {

        return ndaDirectRequest(urldecode($_GET['nba_request']));
    }
    // If both POST and SESSION are empty we have a problem...
    else {
        // Probably best to redirect gracefully to search page?
        handleError('No POST data received! Form validation should trap this. Redirect to home if this occurs?');
    }
    // Redirect to distinct services
    return empty($_SESSION['ndaSearch']['term']) ? ndaAdvancedSearch() : ndaSimpleSearch();

    // This line returns mock data
    // TODO: Delete this line and DUMMY functions at the bottom once everything runs properly!
    // return DUMMYperformNdaRequest('all');
}

/**
 * Distributes search parameter of the simple search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output
 */
function ndaSimpleSearch () {
    $p = array(
        '_search' => $_SESSION['ndaSearch']['term'],
    );
    // Taxon search does not include geoShape
    $services[taxonService()] = $p;
    // Other searches do include geoShape if entered
    if (isset($_SESSION['ndaSearch']['geoShape']) && !empty($_SESSION['ndaSearch']['geoShape'])) {
        $p['geoShape'] = $_SESSION['ndaSearch']['geoShape'];
    };
    foreach (array(specimenService(), specimenNamesService(), multimediaService()) as $request) {
        $services[$request] = $p;
    }
    return performNdaRequest(setChannels($services));
}

/**
 * Distributes search parameters of the advanced search to appropiate services and returns
 * formatted output
 *
 * Retrieves search parameters from SESSION set by ndabioresults_pass, set to
 * the appropriate channels and returns formatted result
 *
 * @return string Formatted output
 */
function ndaAdvancedSearch () {
    $services[multimediaService()] = setSectionParameters($_SESSION['ndaSearch'], 'm_');
    $services[taxonService()] = setSectionParameters($_SESSION['ndaSearch'], 't_');
    // Subdivide specimen parameters for both result types
    $sP = setSectionParameters($_SESSION['ndaSearch'], 's_');
    $services[specimenService()] = setSpecimenParameters($sP, specimenService());
    $services[specimenNamesService()] = setSpecimenParameters($sP, specimenNamesService());
//p($services);
    return performNdaRequest(setChannels($services));
}

/**
 * @todo: check base url!!
 * @param unknown $r
 */
function ndaDirectRequest ($r) {
    foreach (serviceToFunctions() as $service => $d) {
        if (strpos($r, $service) !== false) {
            $url = parse_url($r);
            parse_str($url['query'], $q);
            $channels[0]['request'] = $service;
    		$channels[0]['url'] = ndaBaseUrl() . $service;
    		$channels[0]['post'] = 1;
    		$channels[0]['postfields'] = http_build_query($q);
    		return performNdaRequest($channels);
        }
    }
    return array();
}


/**
 * Sets curl channels
 *
 * Sets request and url parameters for curl channels
 *
 * @param array Service array (service name => search parameters)
 *
 * @return void|array Channels for curl
 */
function setChannels (array $services) {
    $i = 0;
	foreach ($services as $s => $p) {
	    if (!empty($p)) {
	        $p = array_filter($p, 'strlen');
    		$channels[$i]['request'] = $s;
    		$channels[$i]['url'] = ndaBaseUrl() . $s;
    		$channels[$i]['post'] = count($p);
    		$channels[$i]['postfields'] =  http_build_query($p);
    		$i++;
	    }
	}
	return isset($channels) ? $channels : array();
}

/**
 * Filters input parameters from advanced search
 *
 * Input parameters in advanced search form are prefixed with s_, t_, or m_
 * to differentiate between specimen, taxon and multimedia searches. This function
 * creates a new array of input parameters, filtering empty values and stripping
 * the prefix from the input.
 *
 * @param array $post The input as key => value pairs
 * @param string $typeId The input prefix (s_, t_, m_)
 *
 * @return void|array Filtered key => value pairs
 */
function setSectionParameters (array $post, $typeId = '') {
    if ($typeId == '') {
        return $post;
    }
    $d = array();
    foreach ($post as $k => $v) {
        if (strpos($k, $typeId) === 0 && (!empty($v) || is_numeric($v))) {
            $d[str_replace($typeId, '', $k)] = $v;
        }
    }
    if (countSearchParamaters($d) >= 1) {
        // Reset andOr parameter to _andOr and values to and/or
        $d['_andOr'] = $d['andOr'] == 0 ? 'AND' : 'OR';
        unset($d['andOr']);
        // Append geoShape if entered
        if (isset($post['geoShape']) && !empty($post['geoShape']) &&
            in_array($typeId, array('m_', 's_'))) {
            $d['geoShape'] = $post['geoShape'];
        }
        return $d;
    }
    // If only andOr flag is set, nothing has been entered;
    // return empty array
    return array();
}

/**
 * Calculates the number of search parameters excluding flags (andOr etc)
 *
 * @param array $d Search parameter
 * @return Number of search items
 */
function countSearchParamaters ($d) {
    $flags = array('andOr', 'sort', 'sortDirection', 'maxResults');
    foreach ($d as $k => $v) {
        if (in_array($k, $flags)) {
            unset($d[$k]);
        }
    }
    return count($d);
}


/**
 * Performs curl requests and formats results
 *
 * Performs curl queries through multicurl. For each channel, resulting json is
 * parsed to an array by one function and subsequently printed by another.
 *
 * @todo Remove drupal_set_message() that temporarily simply prints the resulting
 * NBA urls
 *
 * @param array $channels Service channels
 * @return void|string
 */
function performNdaRequest (array $channels = array()) {
    // Debug: print queries
    drupal_set_message('<pre>' . print_r($channels, true) . '</pre>');
    //return;

	if (empty($channels)) {
		handleError('Cannot set curl channels');
	}
	// Get json response(s) with curl
	$remoteData = queryNda($channels);
	// Reorder responses in print order if more than one response
	if (count($remoteData) > 1) {
	   $remoteData = sortArrayByArray($remoteData, resultOrder());
	}
	// Map functions to each channel result:
	// parses and prints data
	$output = '';
	$serviceToFunctions = serviceToFunctions();
	foreach ($remoteData as $service => $json) {
		if (!isset($serviceToFunctions[$service]) || empty($json)) {
			continue;
		}
		$parseFunction = $serviceToFunctions[$service]['parse'];
		$printFunction = $serviceToFunctions[$service]['print'];
		$output .= $printFunction($parseFunction($json));
	}
	return $output;
}

/**
 * Performs multicurl queries
 *
 * Core function for multicurl requests
 *
 * @param unknown $channels Service channels
 * @param integer $timeout Optional timeout
 *
 * @return array Results as key => value pairs for each channel
 */
function queryNda ($channels = array(), $timeout = false) {
    $mh = curl_multi_init();
    for ($i = 0; $i < count($channels); $i++) {
        $ch[$i] = curl_init();
        /*
         * POST did not return data, currently switching to GET
         * @todo: check if posting large areas does not break GET
         *
        curl_setopt($ch[$i], CURLOPT_URL, $channels[$i]['url']);
        curl_setopt($ch[$i], CURLOPT_POST, $channels[$i]['post']);
        curl_setopt($ch[$i], CURLOPT_POSTFIELDS, $channels[$i]['postfields']);
        */
        $channels[$i]['url'] .= '/?'  . $channels[$i]['postfields'];

//echo '<pre>'; print_r( $channels[$i]); echo '</pre>';


        curl_setopt($ch[$i], CURLOPT_URL, $channels[$i]['url']);
        curl_setopt($ch[$i], CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch[$i], CURLOPT_HEADER, false);
        if ($timeout) {
       		curl_setopt($ch[$i], CURLOPT_TIMEOUT, $timeout);
        }
        curl_multi_add_handle($mh, $ch[$i]);
    }
    // While we're still active, execute curl
	do {
		$mrc = curl_multi_exec($mh, $active);
	} while ($mrc == CURLM_CALL_MULTI_PERFORM);

    while ($active && $mrc == CURLM_OK) {
        // Wait for activity on any curl-connection
        if (curl_multi_select($mh) == -1) {
            usleep(1);
        }
        // Continue to exec until curl is ready to
        // give us more data
        do {
            $mrc = curl_multi_exec($mh, $active);
        } while ($mrc == CURLM_CALL_MULTI_PERFORM);
    }
    // Place results in results array and close handlers
    for ($i = 0; $i < count($channels); $i++) {
        $remoteData[$channels[$i]['request']] = curl_multi_getcontent($ch[$i]);
        curl_multi_remove_handle($mh, $ch[$i]);
    }
    curl_multi_close($mh);
//echo '<pre>'; print_r($remoteData); echo '</pre>';
    return $remoteData;
}





function parseSpecimenMediaDetail ($json) {
	if (!$json || !validJson($json)) {
		handleError('No or invalid json response');
	}
	$data = json_decode($json);
	$row = $data->searchResults[0];

	$output['source'] = $row->result->specimen->sourceSystem->name;
	$output['navigation'] = getNavigation($data);
	$output['names'] = getSpecimenMediaTaxonNames($row);
	$output['unitID'] = $row->result->specimen->unitID;
	$output['title'] = $row->result->title;
	$output['caption'] = $row->result->caption;
	$output['imgSrc'] = getImageUrl($row);

//echo '<pre>'; print_r($output); echo '</pre>';
	return $output;
}


function getSpecimenMediaTaxonNames ($row) {
	foreach ($row->result->scientificNames as $i => $name) {
		$output[] = array(
			'name' => formatScientificName(
				$name->fullScientificName,
				$name
			),
			'url' => getSpecimenMediaTaxonUrl($row, $i)
		);
	}
	return isset($output) ? $output : false;
}


function getSpecimenMediaTaxonUrl ($row, $i) {
	if (!empty($row->links)) {
		foreach ($row->links as $link) {
			if ($link->rel == "scientificnames[{$i}].fullScientificName") {
				return $link->href;
			}
		}
	}
	return null;
}


function printSpecimenMediaDetail ($data) {
	$output = "<h2>" . $data['title'] . "</h2>\n";
	$output .= printNavigation($data);
	$output .="<img scr='" . $data['imgSrc'] . "' alt='" . $data['title'] .
		"' title=''" . $data['title'] . ">\n";
	$output .= "<table class='table-property-list'>\n<tbody>\n";
	$fields = array('source', 'title', 'caption');
	if (isset($data['acceptedName'])) {
		array_unshift($fields, 'acceptedName');
	} else if (isset($data['names'])) {
		$output .= printNamesWithLinks($data['names'], 'species');
	}
	foreach ($fields as $field) {
		if ($data[$field] != '') {
			$output .= printTableRow($field, $data[$field]);
		}
	}
	return $output . "</tbody>\n</table>\n";
}

function parseTaxonMediaDetail ($json) {
	if (!$json || !validJson($json)) {
		handleError('No or invalid json response');
	}
	$data = json_decode($json);
	$row = $data->searchResults[0];
	$output['source'] = $row->result->taxon->sourceSystem->name;
	$output['acceptedName'] = formatScientificName(
		$row->result->scientificNames[0]->fullScientificName,
		$row->result->scientificNames[0]
	);
	$output['navigation'] = getNavigation($data);
	$output['title'] = $row->result->title;
	$output['caption'] = $row->result->caption;
	$output['imgSrc'] = getImageUrl($row);
//echo '<pre>'; print_r($output); echo '</pre>';
	return $output;
}



function printTaxonMediaDetail ($data) {

  $output = "<h2>" . $data['title'] . "</h2>";
	$output .= printNavigation($data);
	$output .="<img scr='" . $data['imgSrc'] . "' alt='" . $data['title'] .
		"' title=''" . $data['title'] . ">";
	$output .= "<table class='table-property-list'><tbody>";

  foreach (array('acceptedName', 'source', 'title', 'caption') as $field) {
		$output .= printTableRow($field, $data[$field]);
	}

	return $output . "</tbody></table>";
}


// Parses taxon detail json response into array
function parseTaxonDetail ($json) {
	$skipFields = array(
		'objectPublic'
		// etc
	);
	if (!$json || !validJson($json)) {
		handleError('parseTaxonDetail: no or invalid json response');
	}
	$data = json_decode($json);
p($data);
	$output['acceptedName'] = formatScientificName(
		$data->searchResults[0]->result->acceptedName->fullScientificName,
		$data->searchResults[0]->result->acceptedName
	);
	$output['navigation'] = getNavigation($data);
	foreach ($data->searchResults as $row) {
		$source = $row->result->sourceSystem->name;

		if (!empty($row->result->defaultClassification)) {
			$output['classifications']['default'][$source] =
				$row->result->defaultClassification;
		}
		if (!empty($row->result->systemClassification)) {
			$output['classifications']['system'][$source] =
				$row->result->systemClassification;
		}
		if (!empty($row->result->synonyms)) {
			foreach ($row->result->synonyms as $i => $synonym) {
				$output['synonyms'][$source] = formatScientificName(
					$row->result->synonyms[$i]->fullScientificName,
					$row->result->synonyms[$i]
				);
			}
		}
		if (!empty($row->result->descriptions)) {
			foreach ($row->result->descriptions as $i => $description) {
				$output['descriptions'][$description->language][$source] =
					$description->description;
			}
		}
		if (!empty($row->result->commonNames)) {
			foreach ($row->result->commonNames as $i => $name) {
				$output['commonNames'][$name->language][$source] =
					$name->name;
			}

		}
	}
	return $output;
}


function printTaxonDetail ($data) {
  global $language;

  p($data);

  $output  = "<div class='large-2 columns'><a href='#'><i class='icon-arrow-left'></i>" . t("zoekresultaten") . "</a></div>";
  $output .= "<div class='large-7 columns'>";

  $output .=   "<h2>";
  $output .=   "  <span class='scientific-name'>";
  $output .=        $data['acceptedName'];
  $output .=   "  </span>";

  if ( isset($data['commonNames'][$language->language]) ){
    $output .= "  <span class='vernacular-name'>";
    $output .= implode(', ', $data['commonNames'][$language->language]);
    $output .= "  </span>";
  }

  $output .=
		printCommonNames($data) .
		printDescriptions($data) .
		printClassifications($data);

  $output .= "</div>";
  $output .= "<div class='large-3 columns'>";
  $output .= printNavigation($data);
  $output .= "</div>";


  return $output;
}

// function printTaxonDetail ($data) {
//   global $language;
//
//   $output .= "<div class='large-7 columns'>";
//
//   $output .= "<h2>" . $data['acceptedName'] . " <span class='populair-name'>" .
//     (isset($data['commonNames'][$language->language]) ?
//       implode(', ', $data['commonNames'][$language->language]) : '') .
//     "</span></h2>";
//
//   $output .=
//      printCommonNames($data)
//     .printDescriptions($data)
//     .printClassifications($data);
//
//   $output .= "</div>";
//
//   $output .= "<div class='large-3 columns'>";
//   $output .=    printNavigation($data) .
//   $output .= "</div>";
//
//   return $output;
// }


// Transposes common names array and prints common names
function printCommonNames ($data) {
	$output = '';
	$header = "<h3>" . t('Common names') . "</h3>";
	if (isset($data['commonNames']) && !empty($data['commonNames'])) {
		// Transpose first
		foreach ($data['commonNames'] as $lan => $name) {
			$source = key($name);
			$names[$source][$name[$source]] = $lan;
		}
		foreach ($names as $source => $t) {
			$output .= "<h4 class='source'>$source</h4>" .
				"<table class='property-list'><tbody>";
			foreach ($t as $name => $lan) {
				$output .= "<tr><td>" . t($lan) . "</td><td>$name</td></tr>";
			}
			$output .= "</tbody></table>";
		}
	}
	return $header . (!empty($output) ? $output : t('No common names available'));
}

function printDescriptions ($data) {
	global $language;
	$output = '';
	$header = "<h3>" . t('Descriptions') . "</h3>";
	if (isset($data['descriptions']) && !empty($data['descriptions'])) {
		// Transpose first
		foreach ($data['descriptions'] as $lan => $description) {
			$source = key($description);
			$descriptions[$source][$description[$source]] = $lan;
		}
		foreach ($descriptions as $source => $t) {
			foreach ($t as $description => $lan) {
				if ($lan == $language->language) {
					$output .= "<p>$description</p>";
				}
			}
		}
	}
	return $header . (!empty($output) ? $output : t('No descriptions available'));
}

function printClassifications ($data) {
	global $language;
	$output = '';
	$header = "<h3>" . t('Classifications') . "</h3>";
	$printClassifications = array();
	// First merge two separate classification arrays
	foreach ($data['classifications']['default'] as $source => $classification) {
		$classifications[] =array(
			'source' => $source,
			'classification' => $classification
		);
	}
	foreach ($data['classifications']['system'] as $source => $classification) {
		$classifications[] = array(
			'source' => $source,
			'classification' => $classification
		);
	}
	// Check for duplicates; change key if necessary
	foreach ($classifications as $classification) {
		// Classification does not exist yet; add it
		if (!in_array(serialize($classification['classification']), $printClassifications)) {
			$printClassifications[$classification['source']] = serialize($classification['classification']);
		// Classification does exist; adapt its key
		} else {
			$printSource = array_search(serialize($classification['classification']), $printClassifications);
			$newSource = $printSource . ', ' . $classification['source'];
			$printClassifications[$newSource] = serialize($classification['classification']);
			unset($printClassifications[$printSource]);
		}
	}
	// Finally we can print the lot...
	foreach ($printClassifications as $source => $sClassification) {
		$output .= "<h4 class='source'>$source</h4>" .
			"<table class='property-list'><tbody>";
		$classification = unserialize($sClassification);
		foreach ($classification as $rank => $name) {
			$output .= "<tr><td>" . t($rank) . "</td><td>$name</td></tr>";
		}
		$output .= "</tbody></table>";
	}
	return $header . (!empty($output) ? $output : t('No classifications available'));
}

// Parses specimen detail json response into array
function parseSpecimenDetail ($json) {
	$skipFields = array(
		'objectPublic'
		// etc
	);
	if (!$json || !validJson($json)) {
		handleError('parseSpecimenDetail : no or invalid json response');
	}
	$data = json_decode($json);
	foreach ($data->searchResults[0]->result as $field => $value) {
		if (!is_array($value) && !is_object($value) &&
			!in_array($field, $skipFields) && $value != '') {
			$output[t(translateNdaField($field))] = $value;
		}
	}
	$output['source'] = isset($data->searchResults[0]->result->sourceSystem) ?
	   $data->searchResults[0]->result->sourceSystem->name : '';
	$output['names'] = getSpecimenTaxonNames($data->searchResults[0]);
	$output['gatheringEvent'] = getGatheringEventSpecimens($data);
	$output['otherSpecimens'] = getOtherSpecimens($data);
	$output['navigation'] = getNavigation($data);
//p($output);
    return $output;
}


// Return previous/next links from result set
function getNavigation ($data) {
	if (isset($data->links) && !empty($data->links)) {
		foreach ($data->links as $link) {
			if ($link->rel == 'prev' || $link->rel == 'next') {
				$output[$link->rel] = $link->href;
			}
		}
	}
	return isset($output) ? $output : null;
}


// Print specimen detail on screen
function printSpecimenDetail ($data) {
	// Determines order to print field/value;
	// fields not in array are printed at the bottom.
	$fieldOrder = array(
	   'unitID',
	   'names',
	   'source',
	   'assemblageID',
	   'otherSpecimens'
		// etc
	);
	// Reorder input array
	$data = array_merge(array_flip($fieldOrder), $data);
//p($data);
	$output = "<h3>" . t('Specimen details') . "</h3>" .
		"<h5 class='source'>" . $data['source'] . "</h5>";
	// Navigation
	$output .= printNavigation($data);
	$output .= "<table class='table-property-list'><tbody>";
	foreach ($data as $field => $value) {
		if (is_array($value)) {
			// Taxon name
			if ($field == 'names') {
				$output .= printNamesWithLinks($value, 'species');
			}
			// Gathering event
			if ($field == 'gatheringEvent') {
                $output .= printTableRow('dateTimeBegin', isset($value['dateTimeBegin']) ?
                    date('Y-m-d', $value['dateTimeBegin'] / 1000) : '');
                $output .= printTableRow('gatheringAgents', isset($value['gatheringAgents']) ?
                    implode(', ', $value['gatheringAgents']) : '');
			    $output .= printTableRow('localityText', isset($value['localityText']) ?
                     $value['localityText'] : '');
                $output .= printTableRow('siteCoordinates', isset($value['siteCoordinates']) ?
                    '[print on Google Maps: lat ' . $value['siteCoordinates']['lat'] . ', lon ' .
                    $value['siteCoordinates']['lon'] . ']' : '');
			}
		} else {
			$output .= printTableRow($field, $value);
		}
	}
	// Other specimens in collection/set are printed in different table
	if (isset($data['otherSpecimens']) && !empty($data['otherSpecimens'])) {
		$output .= "</tbody></table>" .
			"<table class='table-property-list'><tbody>";
		$output .= printNamesWithLinks($data['otherSpecimens'], 'other');
	}
	return $output . "</tbody></table>";
}

// Prints navigation on details page
function printNavigation ($data) {
	$output = "<div class='navigation'>";
	if (isset($data['navigation']) && !empty($data['navigation'])) {
		$links = array_merge(array_flip(array('prev', 'next')), $data['navigation']);
		foreach ($links as $direction => $url) {
			$t = "<div class='$direction";
			$t .= !empty($url) ?
				"'><a href='" . printDrupalLink($url) . "'>" . $direction . "</a></div>" :
				"-disabled'></div>";
			$output .= $t;
		}
	}
	return $output . "</div>";
}

// Prints taxon identifications for specimen (used only for non-name search)
function printNamesWithLinks ($details, $fieldLabel) {
	$output = '';
	foreach ($details as $i => $detail) {
		$name = isset($detail['unitID']) ? $detail['unitID'] : $detail['name'];
		$t = !empty($detail['url']) ?
			'<a href="' . printDrupalLink($detail['url']) . '">$name</a>' : $name;
		$output .= printTableRow(($i == 0 ? t($fieldLabel) : ''), $t);
	}
	return !empty($output) ? $output : null;
}

// Return other specimens for detail page
function getOtherSpecimens ($row) {
	if (!empty($row->searchResults[0]->result->otherSpecimensInSet)) {
		foreach ($row->searchResults[0]->result->otherSpecimensInSet as $i => $specimen) {
			$s = array();
			$s['unitID'] = $specimen->unitID;
			$s['collectionType'] = $specimen->collectionType;
			$s['url'] = getSpecimenInCollectionUrl($row, $i);
			$c[] = $s;
		}
	}
	return isset($c) ? $c : null;
}

// Return gathering event data for detail page
function getGatheringEventSpecimens ($row) {
	if (!empty($row->searchResults[0]->result->gatheringEvent)) {
        $event = $row->searchResults[0]->result->gatheringEvent;
		foreach ($event as $k => $v) {
		    if (!is_array($v) && !is_object($k) && $v != '') {
                $d[$k] = $v;
		    }
		}
		if (!empty($event->gatheringAgents)) {
		    foreach ($event->gatheringAgents as $a) {
                $agent[] = $a->fullName . (!empty($a->organization) ?
                    ' (' . $a->organization . ')' : '');
		    }
		    $d['gatheringAgents'] = $agent;
		}
		if (!empty($event->siteCoordinates)) {
		    foreach ($event->siteCoordinates as $c) {
                if ($c->longitudeDecimal != 0 && $c->latitudeDecimal != 0) {
                    $coordinates['lat'] = $c->latitudeDecimal;
                    $coordinates['lon'] = $c->longitudeDecimal;
                }
		    }
		    $d['siteCoordinates'] = isset($coordinates) ?
		        $coordinates : null;
		}
	}
	return isset($d) ? $d : null;
}



function printTableRow ($field, $value) {
	return "<tr><td>" . ($field != '' ? t(translateNdaField($field)) : '') . "</td><td>" .
		($value != '' ? $value : '') . "</td></tr>";
}


// Parses multimedia json response into array
function parseMultimedia ($json) {
	if (!$json || !validJson($json)) {
		handleError('parseMultimedia: no or invalid json response');
	}
	$data = json_decode($json);
echo '<pre>'; print_r($data); echo '</pre>';
	$output['searchTerms'] = getSearchTerms($data);
	if (!$output['searchTerms']) {
		handleError('parseMultimedia: invalid json response');
	}
	$output['total'] = getTotalRows($data);
	foreach ($data->searchResults as $row) {
		$type = !empty($row->result->associatedTaxon) ? 'associatedTaxon' :
            'associatedSpecimen';
		$d['title'] = $row->result->title;
		$d['caption'] = $row->result->caption;
		$d['score'] = $row->score;
		$d['url'] = getMultimediaDetailLink($row);
		$d['source'] = !empty($row->result->{$type}->sourceSystem) ?
            $row->result->{$type}->sourceSystem->name : '';
		$d['imgSrc'] = getImageUrl($row);
		$d['hits'] = getHits($row);
		$output['results'][] = $d;
	}
//echo '<pre>'; print_r($output); echo '</pre>';
	return isset($output) ? $output : false;
}


function getMultimediaDetailLink ($row) {
    foreach ($row->links as $link) {
        if ($link->rel == '_multimedia') {
            return $link->href;
        }
    }
}


// Prints multimedia on screen
function printMultimedia ($data) {

  // $output = '<h2>' . t('Your search for') . ' ' . printMatches($data) .
	// 	' ' . t('returned') . ' ' . $data['total'] . ' ' . t('images') . ".</h2>\n" .
	// 	"<h3 class='results-set-header'>" . t('Multimedia') . "</h3>\n" .
	// 	"<div class='col-results-set'>\n";

  $output  = sprintf('<h2>%s <span class="count">(%d)</span></h2>', t('Multimedia'), $data['total'] );
  $output  .= "<div class='multimedia-wrapper'>";

//echo '<pre>'; print_r($data); echo '</pre>';

  foreach ($data['results'] as $i => $row) {
		$w = "240";
    $h = 100 + $i * 50;

    // @todo temp fix for medialib
    $row['imgSrc'] = str_replace('file://', '', $row['imgSrc']);

    $output .=
      "<a class='polaroid' href='" . printDrupalLink($row['url']). "' title='" . $row['title'] . "'>" .
      "  <div class='polaroid-image' style='background-image: url(" . $row['imgSrc']. ");' alt='" . $row['title'] . "'></div>" .
      "  <div class='polaroid-caption'>".
      "    <div class='image-title'>" . $row['caption'] . "</div>" .
			"    <div class='image-hits'>" . printHits($row) . "</div>" .
		    "    <div class='image-source'>" . $row['source'] . "</div>".
      "  </div>".
      "</a>";
	}

  $output .=  "</div>";

  return _markUp($output);
}


// Prints matches on screen
function printMatches ($data) {
	$output = '';
	if (isset($data['searchTerms']) && !empty($data['searchTerms'])) {
		foreach ($data['searchTerms'] as $term) {
			$output .= '<span class="result-query">' . $term . '</span>, ';
		}
	}
	return substr($output, 0, -2);
}

// Returns specimens searched for other fields but taxon
function parseSpecimens ($json) {
	if (!$json || !validJson($json)) {
		handleError('parseSpecimens: no or invalid json response');
	}
	$data = json_decode($json);
	$output['searchTerms'] = getSearchTerms($data);
	$output['total'] = getTotalRows($data);
	if (!$output['searchTerms'] || !$output['total']) {
		handleError('parseSpecimens: invalid json response');
	}
	foreach ($data->searchResults as $row) {
		$d = array();
		$d['unitID'] = $row->result->unitID;
		$d['url'] = $row->links[0]->href;
		$d['names'] = getSpecimenTaxonNames($row);
		$d['hits'] = getHits($row);
		$d['source'] = $row->result->sourceSystem->name;
		$d['score'] = $row->score;
		$output['results'][] = $d;
	}
	return isset($output) ? $output : false;
}



// Prints specimen result set on screen.
function printSpecimens ($data, $p = array('sortColumn' => 0, 'sortDirection' => 'asc')) {
	$headers = array(
		array(
			'label' => t('Specimen'),
			'sort' => 1,
			'icon' => 'icon-sort-by-alphabet',
			'url' => '#'
		),
		array(
			'label' => t('Species'),
			'sort' => 1,
			'icon' => 'icon-sort-by-alphabet',
			'url' => '#'
		),
		array(
			'label' => t('Found in'),
			'sort' => 0
		),
		array(
			'label' => t('Match'),
			'sort' => 1,
			'icon' => 'icon-sort-by-attributes',
			'url' => '#'
		)
	);

  $output  = sprintf('<h2>%s <span class="count">(%d)</span></h2>', t('Specimens'), $data['total'] );
  $output .= sprintf('<table><thead>%s</thead><tbody>', printHeaders($headers, $p) );

  foreach ($data['results'] as $i => $row) {
		$output .= "<tr>";
		// Registration number plus hits
		$output .= "<td><a href='" . printDrupalLink($row['url']) . "'>" . $row['unitID'] . "</a>" .
			(!empty($row['hits']) ? '</br>' . printHits($row) : '') .
			"</td>";
		// Species
		$output .= "<td>" . printSpecimenTaxa($row['names']) . "</td>";
		// Source(s)
		$output .= "<td>" . $row['source'] . "</td>";
		// Match
		$output .= "<td>" . decorateScore($row['score']) . "</td>";
		$output .= "</tr>";
	}
	return $output . "</tbody></table>";
}


// Prints hits as field: hits;
// replaces default <span> with <span class="result-query">
function printHits ($row) {
	$output = '';
	if (isset($row['hits']) && !empty($row['hits'])) {
		foreach ($row['hits'] as $field => $hit) {
			$output .= t(translateNdaField($field)) . ': ' .
				str_replace('<span>', '<span class="result-query">', $hit) . '</br>';
		}
	}
	return !empty($output) ? substr($output, 0, -5) : null;
}


// Prints taxon identifications for specimen (used only for non-name search)
function printSpecimenTaxa ($names) {
	$output = '';
	foreach ($names as $name) {
		$t = $name['name'];
		$t = !empty($name['url']) ?
			'<a href="' . printDrupalLink($name['url']) . '">' . $name['name'] . '</a>, ' :
			$t . ', ';
		$output .= $t;
	}
	return !empty($output) ? substr($output, 0, -2) : null;
}


// Returns taxon names for specimens plus their url found by other fields but name
// (for specimens found by taxon name only a single name is returned!)
function getSpecimenTaxonNames ($row) {
	foreach ($row->result->identifications as $i => $id) {
		$output[] = array(
			'name' => formatScientificName(
				$id->scientificName->fullScientificName,
				$id->scientificName
			),
			'url' => getSpecimenTaxonUrl($row, $i)
		);
	}
	return isset($output) ? $output : false;
}


// Returns url for a taxon associated with the specimen
function getSpecimenTaxonUrl ($row, $i) {
	if (!empty($row->links)) {
		foreach ($row->links as $link) {
			if ($link->rel == "identifications[{$i}].scientificName.fullScientificName") {
				return $link->href;
			}
		}
	}
	return null;
}



// Parses specimen json response into array; searched by taxon
function parseSpecimensByTaxon ($json) {
	if (!$json || !validJson($json)) {
		handleError('No or invalid json response');
	}
	$data = json_decode($json);
//p($data);
	$output['searchTerms'] = getSearchTerms($data);
	$output['total'] = getTotalRows($data);
	if (!$output['searchTerms']) {
		handleError('parseSpecimensByTaxon: invalid json response');
	}
	foreach ($data->resultGroups as $row) {
		$d = array();
		$d['name'] = formatScientificName(
			$row->sharedValue,
		    // @todo
			//$row->searchResults[0]->result->identifications[getResultOffset($row)]->scientificName,
			$row->searchResults[0]->result->identifications[0]->scientificName,
		    $output['searchTerms']
		);
		$d['url'] = $row->links[0]->href;
		$d['count'] = count($row->searchResults);
		$d['sources'] = getSources($row);
		$d['score'] = $row->searchResults[0]->score;

		/*
		 *
		 *  // Specimens are stored in a subarray. Brahms may feature "specimen collections"
    		// (or, in other words, a set),  which are virtual entities collecting different parts of the same individual,
    		// e.g. leaves, fruits and flowers of the same plant. If the "collection" contains just
    		// one specimen (as in CRS), there's only a single specimen in the "collection".
    		$c = $s = array();
    		// Collection/set
    		$c['assemblageID'] = $row->searchResults[0]->result->assemblageID;
    		// Specimen(s)
    		$s['unitID'] = $row->searchResults[0]->result->unitID;
    		$s['collectionType'] = $row->searchResults[0]->result->collectionType;
    		$s['url'] = $row->searchResults[0]->links[0]->href;
    		$otherSpecimens = getOtherSpecimens($row);
    		$c['specimens'] = !empty($otherSpecimens) ? array_merge(array($s), $otherSpecimens) : array($s);
    		$d['set'] = $c;
    		$output['results'][] = $d;

		 */


		foreach ($row->searchResults as $i => $sp) {
    		$assemblageID = $sp->result->assemblageID;
    		$s['unitID'] = $sp->result->unitID;
    		$s['collectionType'] = $sp->result->collectionType;
    		$s['url'] = $sp->links[0]->href;
            empty($assemblageID) ? $d['specimens'] = $s : $d['sets'][$assemblageID][] = $s;
		}
		$output['results'][] = $d;
	}
	return isset($output) ? $output : false;
}



// Returns image properties
function getImageUrl ($row) {
	$key = key(get_object_vars($row->result->serviceAccessPoints));
	return $row->result->serviceAccessPoints->{$key}->accessUri;
}


// Return the field containing the hit
function getHits ($row) {
	foreach ($row->matchInfo as $info) {
		$e = explode('.', $info->path);
		$hits[end($e)] = $info->valueHighlighted;
	}
	return isset($hits) ? $hits : array();
}


// Prints specimen result set on screen.
function printSpecimensByTaxon ($data, $p = array('sortColumn' => 0, 'sortDirection' => 'asc')) {
	$headers = array(
		array(
			'label' => t('Name'),
			'sort' => 1,
			'icon' => 'icon-sort-by-alphabet',
			'url' => '#'
		),
		array(
			'label' => t('Number'),
			'sort' => 1,
			'icon' => 'icon-sort-by-attributes',
			'url' => '#'
		),
		array(
			'label' => t('Found in'),
			'sort' => 0
		),
		array(
			'label' => t('Match'),
			'sort' => 1,
			'icon' => 'icon-sort-by-attributes',
			'url' => '#'
		)
	);

  // $output = '<h2>' . t('Your search for') . ' ' . printMatches($data) .
	// 	' ' . t('returned') . ' ' . $data['total'] . ' ' . t('specimens') . ".</h2>\n" .
	// 	"<h3 class='results-set-header'>" . t('Species with specimens') . "</h3>\n" .
	// 	"<table class='table'><thead>" . printHeaders($headers, $p) .
	// 	"</thead><tbody>";

  $output  = sprintf('<h2>%s %s %s <span class="count">(%d)</span></h2>', t('Specimens with'), printMatches($data), t(' occuring in the species&apos; name.'),$data['total'] );

  $output .= sprintf('<table id="specimensByTaxon"><thead>%s</thead>', printHeaders($headers, $p) );

 p($data);

  foreach ($data['results'] as $i => $row) {
		$output .= "<tr class='indent-0' id='taxon-$i'>";
		// Name
		$output .= "<td><a href='" . printDrupalLink($row['url']) . "'>" . $row['name'] . "</a>" .
			(!empty($row['commonNames']) ? '</br>' . implode(', ', array_keys($row['commonNames'])) : '') .
			"</td>";
		// Number (and collection type)
		$output .= "<td>" . $row['count'] . ' ' . ($row['count'] > 1 ? t('specimens') : t('specimen')) . "</td>";
		// Source(s)
		$output .= "<td>" . implode('</br>', $row['sources']) . "</td>";
		// Match
		$output .= "<td>" . decorateScore($row['score']) . "</td>";
		$output .= "</tr>";
		$output .= printSpecimenCollection($row, $i);
	}

  $output .= "</table>";
  return _markUp($output);
}




// Returns collection/set of specimens or just a specimen if a collection contains a single entry
function printSpecimenCollection ($row, $i) {
    $output = '';
	// Single specimen
    if (isset($row['specimens'])) {
        foreach ($row['specimens'] as $specimen) {
            $output .= "<tr class='indent-1' id='taxon-$i-specimen-0' data-parent='taxon-$i'><td><a href='" .
		    printDrupalLink($specimen['url']) . "'>" . $specimen['unitID'] . "</a></td>" . padTds(3) . "</tr>";
        }

    // Specimen collection/set
    } else if (isset($row['sets'])) {
        foreach ($row['sets'] as $set => $specimens) {
        	$output .= "<tr class='indent-1' id='taxon-$i-collection' data-parent='taxon-$i'><td>" .
        	   $set . "</td>" . padTds(3) . "</tr>";
        	foreach ($specimens as $j => $specimen) {
        		$output .= "<tr class='indent-2' id='taxon-$i-specimen-$j' data-parent='taxon-$i-collection'>"
                . "<td><a href='" . printDrupalLink($specimen['url']) . "'>"
                . $specimen['unitID'] . "</a></td>" . padTds(1) . "<td>" .
        		t(translateNdaField($specimen['collectionType'])) . "</td>" . padTds(1) . "</tr>";
        	}
        }
    }
	return $output;
}

// Shorthand function to pad "filler" tds
function padTds ($i) {
	if ((int)$i > 0) {
		return str_repeat("<td></td>", $i);
	}
}

// Return url for specimens in "collection"/set
function getSpecimenInCollectionUrl ($row, $i) {
	if (!empty($row->searchResults[0]->links)) {
		foreach ($row->searchResults[0]->links as $link) {
			if ($link->rel == 'specimen-detail.otherSpecimensInSet.' . $i) {
				return $link->href;
			}
		}
	}
	return null;
}

// Prints headers of result table on screen
function printHeaders ($headers, $p) {
	$output = "<tr>";

  foreach ($headers as $i => $header) {
		$class = "";

    if ( $i == 0)                    { $class="column-first"; }
    if ( $header['label'] == "Match"){ $class="column-match"; }

    $output .= "<th class='$class'>";

    if ($header['sort'] == 1) {
			// Selected header
			if ($i == $p['sortColumn']) {
				$header['url'] .= ($p['sortDirection'] == 'asc' ? '&desc' : '&asc');
				$output .= "<a href='" . printDrupalLink($header['url']) . "'>" .
					$header['label'] . "</a>" .
					"<a href='" . printDrupalLink($header['url']) . "'>" .
					"<span class='sortable glyphicon " . $header['icon'] .
					($p['sortDirection'] == 'desc' ? "-alt" : "") . "'></span></a>";
			// Other headers
			} else {
				$header['url'] .= '&desc';
				$output .= "<a href='" . printDrupalLink($header['url']) . "'>" .
					$header['label'] . "</a>" .
					"<a href='" . printDrupalLink($header['url']) . "'>" .
					"<span class='sortable glyphicon icon-sort'></span></a>";
			}
		} else {
			$output .= $header['label'];
		}
		$output .= "</th>";
	}
	return $output . "</tr>";
}

// Parses taxon/species json response into array
function parseTaxa ($json) {
	if (!$json || !validJson($json)) {
		handleError('parseTaxon: no or invalid json response');
	}
	$data = json_decode($json);

	$output['total'] = getTotalRows($data);
	$output['searchTerms'] = getSearchTerms($data);
	if (!$output['searchTerms']) {
		handleError('parseTaxon: invalid json response');
	}
	foreach ($data->resultGroups as $row) {
		$d = array();
		// Accepted scientific name, synonym, or common name
		$d['type'] = getResultType($row);
		if ($d['type'] == 'accepted') {
			$d['name'] = formatScientificName(
				$row->searchResults[0]->matchInfo[0]->value,
				$row->searchResults[0]->result->acceptedName,
				$output['searchTerms']
			);
		} else if ($d['type'] == 'synonym') {
			$d['name'] = formatScientificName(
				$row->searchResults[0]->matchInfo[0]->value,
				$row->searchResults[0]->result->synonyms[getResultOffset($row)]->scientificName,
				$output['searchTerms']
			);
		} else if ($d['type'] == 'common') {
			$d['name'] = highlightMatch(
				$row->searchResults[0]->matchInfo[0]->value,
				$output['searchTerms']
			);
		}
		$d['acceptedName'] = (
			$d['type'] == 'accepted' ?
			$d['name'] :
			formatScientificName(
				$row->searchResults[0]->result->acceptedName->fullScientificName,
				$row->searchResults[0]->result->acceptedName
			)
		);
		$d['rank'] = $row->searchResults[0]->result->taxonRank;
		$d['url'] = url_decode($row->links[0]->href);
		$d['sources'] = getSources($row);
		$d['commonNames'] = ($d['type'] != 'common' ? getCommonNames($row) : array());
		$d['score'] = $row->searchResults[0]->score;
		$output['results'][] = $d;
	}
echo 'Taxon object has to be changed in order to parse...<pre>'; print_r($data); echo '</pre>';
die();
	return isset($output) ? $output : false;
}




/* Prints taxon result set on screen. Parameters $p should contain:
   'sortColumn', 'sortDirection'

   TODO:
   1. Set truncated (for overview)/non-truncated
   2. Pass $p['total'] dynamically

*/
function printTaxa ($data, $p = array('sortColumn' => 0, 'sortDirection' => 'asc')) {
	$headers = array(
		array(
			'label' => t('Name'),
			'sort' => 1,
			'icon' => 'icon-sort-by-alphabet',
			'url' => '#'
		),
		array(
			'label' => t('Description'),
			'sort' => 0
		),
		array(
			'label' => t('Found in'),
			'sort' => 0
		),
		array(
			'label' => t('Match'),
			'sort' => 1,
			'icon' => 'icon-sort-by-attributes',
			'url' => '#'
		)
	);

  $output  = sprintf('<h2>%s <span class="count">(%d)</span></h2>', t('Species names'), $data['total'] );
  $output .= sprintf('<table><thead>%s</thead><tbody>', printHeaders($headers, $p) );

  foreach ($data['results'] as $i => $row) {
		$output .= "<tr>";

    // Name
		$output .= "<td>";
    $output .= "<a href='" . printDrupalLink($row['url']) . "'>" . $row['name'] . "</a>";
		$output .= (!empty($row['commonNames']) ? '</br>' . implode(', ', array_keys($row['commonNames'])) : '');
		$output .=	"</td>";

    // Description
    $output .= "<td>" . decorateDescription($row) . "</td>";

    // Source(s)
    $output .= "<td>" . implode('</br>', $row['sources']) . "</td>";

    // Match
		$output .= "<td>" . decorateScore($row['score']) . "</td>";

    $output .= "</tr>";
	}

  $output .= "</tbody></table>";
  $output = _markUp($output);

	return $output;
}

// Validates json string
function validJson ($string) {
	return is_object(json_decode($string));
}

// Returns type of result:
// acceptedName.fullScientificName
// acceptedName.synonyms[0].scientificName.fullScientificName
// acceptedName.commonNames[0].name
function getResultType ($row) {
	$path = $row->searchResults[0]->matchInfo[0]->path;
	return strpos($path, 'synonym') !== false ? 'synonym' :
		(strpos($path, 'commonName') !== false ? 'common' : 'accepted');
}

// Returns offset of result; used only for synonyms and common names
// to determine the array key containing the hit
// Used for taxon/specimenByTaxon
function getResultOffset ($row) {
	preg_match('/\[(.*?)\]/', $row->searchResults[0]->matchInfo[0]->path, $m);
	return $m[1];
}

// Returns total number of results
function getTotalRows ($data) {
	if (isset($data->totalSize)) {
		return (int)$data->totalSize;
	}
	return false;
}

// Returns total number of results
function getSearchTerms ($data) {
	if (isset($data->queryParameters)) {
		return (array)$data->queryParameters;
	}
	return false;
}

// Results formatted accepted name with proper use of italics
function formatScientificName ($scientificname, $nameObject, $searchTerm = false) {
	$output = $scientificname;
	$elements = getScientificNameElements($nameObject);
	foreach ($elements as $e) {
		if (!empty($e)) {
			$output = str_replace($e, '<span class="scientific">' . $e . '</span>', $output);
		}
	}
	// Highlight the formatted output
	return $searchTerm ? highlightMatch($output, $searchTerm) : $output;
}

// Returns scientific name elements from name object
// Store as keys and flip to avoid duplicates (as in Larus fuscus fuscus)
function getScientificNameElements ($name) {
	$elements = array(
		$name->genusOrMonomial => 0,
		$name->subgenus => 1,
		$name->specificEpithet => 2,
		$name->infraspecificEpithet => 3
	);
	return array_flip($elements);
}

// Returns all sources for taxon/specimen
function getSources ($row) {
	foreach ($row->searchResults as $i => $obj) {
		$output[$obj->result->sourceSystem->name] = $i;
	}
	return isset($output) ? array_flip($output) : false;
}

// Returns common names for the current interface language;
// format is array(name => language), so duplicates will be avoided
function getCommonNames ($row, $languageCheck = false) {
	global $language;
	foreach ($row->searchResults as $i => $taxon) {
		if (isset($taxon->result->commonNames)) {
			foreach ($taxon->result->commonNames as $name) {
				// If language is set, only store when language of
				// common name matches that of interface...
				if ($languageCheck) {
					if ($name->language == $language->language) {
						$output[$name->name] = $name->language;
					}
				// ... else always return all names
				} else {
					$output[$name->name] = $name->language;
				}
			}
		}
	}
	return isset($output) ? $output : false;
}


// Decorate description in taxon result table
function decorateDescription ($row) {
	return ($row['type'] != 'accepted' ?
		t(ucfirst($row['type'])) . ($row['type'] == 'common' ? ' ' . t('name') : '') .
		' ' . t('for') . ' ' :  '') . ($row['type'] == 'accepted' ? t(ucfirst($row['rank'])) :
		t($row['rank'])) . ' ' . $row['acceptedName'];
}

// Decorate score in result table
function decorateScore ($score) {
	$score = round($score * 100);
	$roundScore = round( $score / 20 );
  $result = "<span class='score' title='$score %'>";

  for ( $i=1; $i<=5; $i++ ){
    if ( $i <= $roundScore ){
      $result.= "<span class='square-filled'>&FilledSmallSquare;</span>";
    } else {
      $result.= "<span class='square-empty'>&EmptySmallSquare;</span>";
    }
  }

  $result .= "</span>";
  return $result;

  //return "<span class='score'><span class='score-bar' style='width: $score%'></span><span class='score-text'>$score%</span></span>";
}

// Highlight match
function highlightMatch($haystack, $needles) {
	foreach ($needles as $needle) {
		if (stripos(strip_tags($haystack), $needle)===false || is_null($needle)) {
			continue;
		}
		$q = str_split($needle);
		$x = ')(\<[^<]*\>)*(';
		$q = str_replace('( )','(\s*)','('.implode($x, $q).')');
		$haystack = preg_replace_callback('/'.$q.'/i','_fsub1', $haystack);
	}
	return $haystack;
}

function _fsub1($m) {
	return "<span class='result-query'>".preg_replace_callback('(<(.*?)>)','_fsub2',$m[0])."</span>";
}

function _fsub2($m) {
	return '</span>'.$m[0]."<span class='result-query'>";
}

function sortArrayByArray ($array, $orderArray) {
    $ordered = array();
    foreach ($orderArray as $key) {
        if (array_key_exists($key,$array)) {
            $ordered[$key] = $array[$key];
            unset($array[$key]);
        }
    }
    return $ordered + $array;
}


// Wrapper for Drupal error handler
function handleError ($message) {
    die($message);
}


// Should be replaced with a function that translates NDS field labels to proper English
function translateNdaField ($str) {
	return $str;
}

// Create Drupal specific link
function printDrupalLink ($url) {
    global $base_root, $base_path;
    return $base_root . $base_path . 'nba/result?nba_request=' . urlencode($url);
}

function _markUp($string){
  $result = $string;
  $result = preg_replace('/^\s+|\n|\r|\s+$/m', '', $result);

  $result = str_replace(
    array("    <h2",  "<table",        "<thead",      "<tbody",      "<tr",        "<td",        "<th ",   "<a class='polaroid'"),
    array("\n\n<h2","\n\n<table","\n\n\t<thead","\n\n\t<tbody","\n\t\t<tr","\n\t\t\t<td","\n\t\t\t<th ", "\n<a class='polaroid' "),
    $result
  );

  $result = str_replace(
    array(  "</table",    "</thead",    "</tbody",     "</tr",        "</td",        "</th>"),
    array("\n</table","\n\t</thead","\n\t</tbody","\n\t\t</tr","\n\t\t\t</td","\n\t\t\t</th>"),
    $result
  );

  return $result;
}






/*
 * DUMMY functions to print mock data on screen. Please keep this at the bottom of this document
 * so these can removed easily once markup has been completed and NDA services run properly
 */
function DUMMYmapNdaRequests() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	'all' => 'group-taxa-by-name.json|groupSpecimenBySpecificName.json|getSpecimensForOtherSearchTerms.json|getMediaObjects.json',
        	'taxa' => 'group-taxa-by-name.json',
        	'specimensByTaxon' => 'groupSpecimenBySpecificName.json',
        	'specimens' => 'groupSpecimenBySpecificName.json',
        	'multimedia' => 'getMediaObjects.json',
        	'taxonDetail' => 'taxon-detail.json',
        	'specimenDetail' => 'specimen-detail.json',
        	'taxonMediaDetail' => 'taxon-media-detail.json',
        	'specimenMediaDetail' => 'specimen-media-detail.json'
        );
    }
    return $var;
}

function DUMMYresultOrder() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	'getMediaObjects.json',
        	'group-taxa-by-name.json',
        	'groupSpecimenBySpecificName.json',
        	'getSpecimensForOtherSearchTerms.json'
        );
    }
    return $var;
}

function DUMMYserviceToFunctions() {
    $var = &drupal_static(__FUNCTION__);
    if (!isset($var)) {
         $var = array(
        	'group-taxa-by-name.json' => array(
        		'parse' => 'parseTaxa',
        		'print' => 'printTaxa'
        	),
        	'groupSpecimenBySpecificName.json' => array(
        		'parse' => 'parseSpecimensByTaxon',
        		'print' => 'printSpecimensByTaxon'
        	),
        	'getMediaObjects.json' => array(
        		'parse' => 'parseMultimedia',
        		'print' => 'printMultimedia'
        	),
        	'getSpecimensForOtherSearchTerms.json' => array(
        		'parse' => 'parseSpecimens',
        		'print' => 'printSpecimens'
        	),
        	'specimen-detail.json' => array(
        		'parse' => 'parseSpecimenDetail',
        		'print' => 'printSpecimenDetail'
        	),
        	'taxon-detail.json' => array(
        		'parse' => 'parseTaxonDetail',
        		'print' => 'printTaxonDetail'
        	),
        	'taxon-media-detail.json' => array(
        		'parse' => 'parseTaxonMediaDetail',
        		'print' => 'printTaxonMediaDetail'
        	),
        	'specimen-media-detail.json' => array(
        		'parse' => 'parseSpecimenMediaDetail',
        		'print' => 'printSpecimenMediaDetail'
        	)
        );
    }
    return $var;
}

function DUMMYperformNdaRequest ($request = false) {
    $serviceToFunctions = DUMMYserviceToFunctions();
	// Translate request url to curl channels
	$channels = DUMMYsetChannels($request);
	if (empty($channels)) {
		handleError('Cannot set curl channels');
	}
	// Get json response(s) with curl
	$remoteData = DUMMYqueryNda($channels);
	// Reorder responses in print order if more than one response
	if (count($remoteData) > 1) {
	   $remoteData = sortArrayByArray($remoteData, DUMMYresultOrder());
	}
	// Map functions to each channel result:
	// parses and prints data
	$output = '';
	foreach ($remoteData as $service => $json) {
		if (!isset($serviceToFunctions[$service]) || empty($json)) {
			continue;
		}
		$parseFunction = $serviceToFunctions[$service]['parse'];
		$printFunction = $serviceToFunctions[$service]['print'];
		$output .= $printFunction($parseFunction($json));
	}
	return $output;
}


function DUMMYsetChannels ($request = false) {
	$mapNdaRequests = DUMMYmapNdaRequests();
	if (!$request || !isset($mapNdaRequests[$request])) {
		return false;
	}
	$t = explode('|', $mapNdaRequests[$request]);
	foreach ($t as $i => $url) {
		$channels[$i]['request'] = $url;
		$channels[$i]['url'] = 'http://dev2.etibioinformatics.nl/nda/' . $url;
	}
	return $channels;
}

function DUMMYqueryNda ($channels = array(), $timeout = false) {
    $mh = curl_multi_init();
    for ($i = 0; $i < count($channels); $i++) {
        $ch[$i] = curl_init();

$url = $channels[$i]['url'] . '/?'  . $channels[$i]['postfields'];
echo $url . "<br>";

        curl_setopt($ch[$i], CURLOPT_URL, $url);
        curl_setopt($ch[$i], CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch[$i], CURLOPT_HEADER, false);
        if ($timeout) {
       		curl_setopt($ch[$i], CURLOPT_TIMEOUT, $timeout);
        }
        curl_multi_add_handle($mh, $ch[$i]);
    }
    // While we're still active, execute curl
	do {
		$mrc = curl_multi_exec($mh, $active);
	} while ($mrc == CURLM_CALL_MULTI_PERFORM);

    while ($active && $mrc == CURLM_OK) {
        // Wait for activity on any curl-connection
        if (curl_multi_select($mh) == -1) {
            usleep(1);
        }
        // Continue to exec until curl is ready to
        // give us more data
        do {
            $mrc = curl_multi_exec($mh, $active);
        } while ($mrc == CURLM_CALL_MULTI_PERFORM);
    }
    // Place results in results array and close handlers
    for ($i = 0; $i < count($channels); $i++) {
        $remoteData[$channels[$i]['request']] = curl_multi_getcontent($ch[$i]);
        curl_multi_remove_handle($mh, $ch[$i]);
    }
    curl_multi_close($mh);

 print_r($remoteData); die();

    return $remoteData;
}

function p ($a) {
    echo '<pre>'; print_r($a); echo '</pre>';
}
